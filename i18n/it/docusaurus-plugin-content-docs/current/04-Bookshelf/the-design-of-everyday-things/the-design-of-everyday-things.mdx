---
sidebar_position: 1
sidebar_label: 'The Design of Everyday Things'
title: 'The Design of Everyday Things'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# The Design of Everyday Things

## Il Libro

Questo √® stato in assoluto il primo libro di UX che ho letto e lo reputo tuttora il manuale operativo fondamentale per comprendere la psicologia dietro l'interazione uomo-macchina. Norman smonta la convinzione che l'errore sia colpa dell'utente, dimostrando come ogni scivolone sia in realt√† il risultato di una cattiva progettazione. Attraverso concetti come Affordance, Mapping e Feedback, il libro trasforma il design da un esercizio puramente estetico a una scienza comportamentale. √à stato fondamentale per me, perch√© credo che un UX Engineer non debba limitarsi a decorare interfacce, bens√¨ progettare percorsi mentali in cui l'utente non debba mai chiedersi come si usa un oggetto o un componente.

## Esempio Pratico: "The State Machine Button"

Per dimostrare i principi di Norman in un contesto puramente software, ho progettato e sviluppato un componente Button "consapevole". Troppo spesso, nei siti web e nelle app (meno nell'ecosistema Apple grazie agli standard imposti dalle Human Interface Guidelines), i bottoni sono rettangoli statici che cambiano colore solo al click, violando il principio di Feedback continuo. Ho creato un componente che rispetta il ciclo di azione completo descritto da Norman. L'Affordance √® garantita da un'elevazione visiva data dall'ombra che suggerisce la cliccabilit√†, mentre il Feedback √® immediato e attraversa cinque stadi distinti: riposo, intenzione, azione, attesa e conferma. Questo assicura che lo spazio tra l'azione dell'utente e la comprensione del risultato sia ridotto a zero.

<div style={{
  display: 'flex',
  flexWrap: 'wrap',
  gap: '20px',
  alignItems: 'flex-start',
  width: '100%',
  margin: '2rem 0'
}}>

  <div style={{ flex: '0.647 1 0px', minWidth: '200px' }}>
    <img 
      src={require('./assets/the-design-of-everyday-things-it.webp').default} 
      alt="Artefatto Visivo Norman Button"
      loading="lazy"
      width="1744"
      height="2693"
      style={{
        borderRadius: '10px',
        width: '100%',
        height: 'auto',
        display: 'block'
      }}
    />
    <p style={{textAlign: 'center', opacity: 0.7, fontSize: '0.9rem', marginTop: '10px'}}>
      Prototipo Figma
    </p>
  </div>

  <div style={{ flex: '1.593 1 0px', minWidth: '280px' }}>
    <video 
      src={require('./assets/the-design-of-everyday-things.webm').default} 
      autoPlay 
      loop 
      muted 
      playsInline
      style={{
        borderRadius: '10px',
        width: '100%',
        height: 'auto',
        display: 'block'
      }}
    />
    <p style={{textAlign: 'center', opacity: 0.7, fontSize: '0.9rem', marginTop: '10px'}}>
      Implementazione Reale (Codice) ‚Ä¢ Velocit√† 0.5x
    </p>
  </div>

</div>

## Codice Sorgente

Per quanto riguarda l'implementazione, ho utilizzato HTML semantico, CSS moderno con Custom Properties per la gestione degli stati e Vanilla JavaScript con Arrow Functions per la logica di interazione.

<Tabs>
<TabItem value="html" label="index.html" default>

```html
<!-- 
   DESIGN
   ------
   * Semantic structure and accessibility first:
   * - Semantic tag: I chose <button> over <div> to gain native keyboard 
   *   focus and screen reader support (Affordance)
   * - ARIA integration: aria-live="polite" is critical here. It ensures 
   *   that the feedback (loading/success) is announced to non-visual users
   * - State readiness: The .loader is present in the DOM but hidden,
   *   ready to appear without causing layout shifts.
-->

<div class="button-container">
    <button id="action-btn" class="norman-btn" aria-live="polite">
        <span class="btn-text">Confirm action</span>
        <span class="loader"></span>
    </button>
</div>

<link rel="stylesheet" href="styles.css">
<script src="script.js"></script>
```

</TabItem>

<TabItem value="css" label="styles.css">

```css
/* DESIGN 
   ------
   * Physics metaphor and state management.
   * - Token-based depth: Shadows represent the Z-axis (elevation)
   *   I defined them in :root to maintain consistent "physical laws"
   *   across the application
   * - Interaction physics: The transition is tuned to mimic a mechanical
   *   spring (ease), providing realistic tactile feedback
   * - Constraint styling: The 'loading' state enforces the constraint
   *   visually (opacity) and functionally (pointer-events: none)
   * - Layout stability: I use CSS Grid Stack technique here. Instead of
   *   absolute positioning, I place both text and loader in the same 
   *   Grid cell (1x1). This guarantees mathematical centering.
*/

/* * Here I manage the "Button physics".
   * The shadow is not decorative but functional, as it suggests
   * elevation (Affordance)
   * When pressed (:active), the shadow decreases and the element goes down,
   * simulating real mechanical resistance (Tactile feedback).
*/

:root {
    /* Colors */
    --primary-color: #ffd500;
    --hover-color: #d5bb3b;
    --bg-body: #524236;
    --btn-text: #000000;
    
    /* Shapes and typography */
    --btn-radius: 14px;
    --btn-weight: 550;
    
    /* Physics */
    --shadow-rest: 0 8px 10px -1px rgba(0, 0, 0, 0.4);
    --shadow-active: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
}

body {
    background-color: var(--bg-body);

    /* Viewport Centering */
    margin: 0;
    height: 100vh; /* Full viewport height */
    display: grid;
    place-items: center; /* Perfect centering */
}

.norman-btn {
    /* GRID STACKING TECHNIQUE: Perfect centering without magic numbers */
    display: inline-grid;
    place-items: center;
    grid-template-areas: "stack";

    position: relative;
    padding: 0.75rem 1.5rem;
    min-width: 160px; /* Prevents width collapse during state change */
    border: none;
    border-radius: var(--btn-radius);
    background-color: var(--primary-color);
    color: var(--btn-text);
    font-weight: var(--btn-weight);
    box-shadow: var(--shadow-rest); /* Affordance: elevation */
    cursor: pointer;
    transition: all 0.1s ease;
}

/* Stacking both elements in the same grid cell */
.btn-text, .loader {
    grid-area: stack;
    transition: opacity 0.2s ease;
}

.norman-btn:hover {
    background-color: var(--hover-color);
    transform: translateY(-1px); /* Intention: it moves closer to the finger/cursor */
}

.norman-btn:active {
    transform: translateY(2px); /* Action: it sinks under pressure */
    box-shadow: var(--shadow-active);
}


/* STATE MANAGEMENT: LOADING */

.norman-btn.loading {
    cursor: wait;
    opacity: 0.8;
    pointer-events: none; /* Constraint: prevents double clicks */
    
    /* UX physics: the button stays "pressed" during work */
    box-shadow: none;           /* Removes elevation (flat against surface) */
    transform: translateY(2px); /* Keeps the pressed position */
    background-color: var(--hover-color); /* Maintains the active/pressed color */
}

.loader {
    /* Visibility handled by opacity for smooth transition */
    visibility: hidden;
    opacity: 0;
    width: 1rem;
    height: 1rem;
    
    /* Loader color inherits from text color token for consistency */
    border: 2px solid var(--btn-text); 
    border-bottom-color: transparent;
    border-radius: 50%;
    animation: rotation 1s linear infinite;
}

.norman-btn.loading .btn-text { 
    visibility: hidden;
    opacity: 0;
}

.norman-btn.loading .loader { 
    visibility: visible;
    opacity: 1;
}

@keyframes rotation {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
```

</TabItem>

<TabItem value="js" label="script.js">

```javascript
/* DESIGN 
   ------
   * State logic and async simulation.
   * - Event-driven architecture: The logic reacts to user intent immediately
   * - Constraint enforcement: The guard clause prevents "Rage clicks" or 
   *   double submissions by checking the current state
   * - Feedback loop: Simulates network latency providing visual 
   *   feedback throughout the entire lifecycle.
*/

/*
   I use arrow functions to manage the logic. On click, the button enters
   a "Loading" state (constraint) preventing further accidental clicks,
   then provides final feedback (success).
*/

const btn = document.getElementById('action-btn');

const handleClick = () => {
    // Constraint: prevent multiple clicks
    if (btn.classList.contains('loading')) return;

    // Feedback: enter the waiting state
    btn.classList.add('loading');
    
    // Simulation of an asynchronous call (e.g., API)
    setTimeout(() => {
        // Feedback: end operation and return to resting state
        btn.classList.remove('loading');
        alert("Action completed!");
    }, 2000);
};

btn.addEventListener('click', handleClick);
```

</TabItem>

<TabItem value="commented" label="spiegato">

```html
<!DOCTYPE html>
<!-- üéØ DICHIARAZIONE HTML5: "Benvenuti nel design di pulsanti interattivi!" -->
<!-- Questo documento segue i principi moderni di HTML semantico per accessibilit√† e interazione! üñ±Ô∏è -->

<html lang="en">
<!-- üåç IMPOSTAZIONE LINGUA: Inglese come lingua del documento -->
<!-- Una corretta dichiarazione della lingua aiuta gli screen reader a usare la pronuncia corretta -->

<head>
    <!-- üß† IL CENTRO DI COMANDO: Dove prepariamo il nostro pulsante interattivo -->
    <!-- Come la sala progetti dove progettiamo la perfetta meccanica del pulsante! -->
    
    <title>Pulsante Interattivo con Stato di Caricamento</title>
    <!-- üìë TITOLO PAGINA: Descrive ci√≤ che questo componente dimostra -->
    
    <meta charset="UTF-8">
    <!-- üìù CODIFICA CARATTERI: Garantisce la corretta visualizzazione del testo -->
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- üì± DESIGN RESPONSIVE: Ridimensionamento corretto su tutti i dispositivi -->
    <!-- Questo assicura che il nostro pulsante appaia perfetto su tutto, dagli smartphone ai desktop -->
    
    <style> 
      /* üé® ===== STILI CSS: L'Aspetto e il Comportamento del Pulsante ===== */
      
      /* üèóÔ∏è ===== SISTEMA DI DESIGN: Le "Leggi Fisiche" della Nostra UI ===== */
      
      :root {
          /* üé® COLORI: La palette del nostro elemento interattivo */
          --primary-color: #ffd500;
          /* üü° GIALLO PRIMARIO: Colore brillante e accattivante per il pulsante */
          /* Il giallo suggerisce attenzione o cautela - perfetto per azioni di conferma */
          
          --hover-color: #d5bb3b;
          /* üü® GIALLO PI√ô SCURO: Mostra lo stato interattivo al passaggio del mouse */
          /* Leggermente pi√π scuro per fornire un chiaro feedback visivo quando il cursore passa sopra */
          
          --bg-body: #524236;
          /* üü§ SFONDO MARRONE: Crea contrasto con il pulsante giallo */
          /* Tonalit√† terrosa ricca che fa risaltare drammaticamente il pulsante brillante */
          
          --btn-text: #000000;
          /* ‚ö´ TESTO NERO: Massima leggibilit√† su sfondo giallo */
          /* L'alto rapporto di contrasto garantisce che il testo sia leggibile per tutti gli utenti */
          
          /* üìê FORME E TIPOGRAFIA: Definizione della forma del pulsante */
          --btn-radius: 14px;
          /* üîÑ ANGOLI ARROTONDATI: Aspetto morbido, raggio di 14px */
          /* N√© troppo rotondo, n√© troppo squadrato - un look moderno ed equilibrato */
          
          --btn-weight: 550;
          /* üî§ CARATTERE SEMI-GRASSETTO: Peso personalizzato per una visibilit√† perfetta */
          /* 550 √® tra regular (400) e bold (700) - distintivo senza gridare */
          
          /* üì¶ FISICA: Le propriet√† dell'ombra creano un senso di profondit√† */
          --shadow-rest: 0 8px 10px -1px rgba(0, 0, 0, 0.4);
          /* üï≥Ô∏è OMBRA A RIPOSO: Ombra pi√π profonda quando il pulsante non √® premuto */
          /* 8px di offset verticale crea un effetto fluttuante sopra la superficie */
          
          --shadow-active: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
          /* üï≥Ô∏è OMBRA ATTIVA: Ombra minima quando il pulsante √® premuto */
          /* 1px di offset verticale imita il pulsante premuto contro la superficie */
      }
      
      /* üìÑ ===== STILE DEL BODY: Tela per il Nostro Pulsante ===== */
      
      body {
          background-color: var(--bg-body);
          /* üü§ SFONDO: Colore marrone dal nostro sistema di design */
          
          /* üìè CONFIGURAZIONE CENTRAGGIO PERFETTO: Posiziona il pulsante al centro del viewport */
          margin: 0;
          /* üö´ NESSUN MARGINE: Rimuove la spaziatura predefinita */
          
          height: 100vh;
          /* üìè ALTEZZA COMPLETA: Utilizza l'intera altezza del viewport */
          /* vh = viewport height, 100vh = 100% dell'altezza visibile dello schermo */
          
          display: grid;
          /* üìä VISUALIZZAZIONE GRIGLIA: Sistema di layout moderno */
          /* Grid fornisce il modo pi√π semplice per centrare perfettamente i contenuti */
          
          place-items: center;
          /* ‚öñÔ∏è CENTRAGGIO PERFETTO: Centra il contenuto orizzontalmente e verticalmente */
          /* Questo √® l'approccio moderno al centraggio - molto pi√π pulito dei vecchi metodi */
      }
      
      /* üîò ===== BASE PULSANTE: La Fondazione del Nostro Elemento Interattivo ===== */
      
      .norman-btn {
          /* üìä TECNICA DI SOVRAPPOSIZIONE GRID: Per allineamento perfetto di testo e loader */
          display: inline-grid;
          /* üìä INLINE-GRID: Si comporta come elemento inline ma con i poteri della griglia */
          /* Ci permette di sovrapporre testo e loader precisamente nello stesso spazio */
          
          place-items: center;
          /* ‚öñÔ∏è ALLINEAMENTO CENTRALE: Centra gli elementi sovrapposti perfettamente */
          /* Sia orizzontalmente che verticalmente all'interno del pulsante */
          
          grid-template-areas: "stack";
          /* üìç AREA GRIGLIA NOMINATA: Crea una singola cella chiamata "stack" */
          /* Questa area singola conterr√† sia gli elementi di testo che il loader */
          
          position: relative;
          /* üìç CONTESTO DI POSIZIONAMENTO: Stabilisce il posizionamento per gli elementi figlio */
          
          padding: 0.75rem 1.5rem;
          /* üìè SPAZIATURA INTERNA: Spazio confortevole attorno al testo */
          /* 0.75rem (12px) sopra/sotto, 1.5rem (24px) sinistra/destra */
          
          min-width: 160px;
          /* üìè LARGHEZZA MINIMA: Assicura che il pulsante non collassi quando il testo √® nascosto */
          /* Previene spostamenti di layout fastidiosi durante i cambiamenti di stato */
          
          border: none;
          /* üö´ NESSUN BORDO: Aspetto pulito e moderno */
          
          border-radius: var(--btn-radius);
          /* üîÑ ANGOLI ARROTONDATI: Utilizzo della variabile del sistema di design */
          
          background-color: var(--primary-color);
          /* üü° RIEMPIMENTO GIALLO: Colore primario dal sistema di design */
          
          color: var(--btn-text);
          /* ‚ö´ COLORE TESTO: Nero dal sistema di design */
          
          font-weight: var(--btn-weight);
          /* üî§ PESO DEL FONT: Semi-grassetto dal sistema di design */
          
          box-shadow: var(--shadow-rest);
          /* üï≥Ô∏è EFFETTO OMBRA: Crea l'illusione di elevazione */
          /* Le ombre non sono solo decorative - aiutano a comunicare come si comporta l'elemento */
          
          cursor: pointer;
          /* üëÜ CURSORE A MANO: Indizio visivo che l'elemento √® cliccabile */
          
          transition: all 0.1s ease;
          /* üé≠ CAMBIAMENTI FLUIDI: Anima tutte le modifiche delle propriet√† */
          /* 0.1s √® abbastanza veloce da sembrare reattivo ma mostra comunque la transizione */
          /* La funzione di temporizzazione "ease" imita la fisica del movimento naturale */
      }
      
      /* üìö ===== ELEMENTI SOVRAPPOSTI: Posizionamento di Testo e Loader ===== */
      
      .btn-text, .loader {
          grid-area: stack;
          /* üìç AREA GRIGLIA CONDIVISA: Entrambi gli elementi occupano lo stesso spazio */
          /* Questo approccio matematico garantisce un centraggio perfetto senza posizionamento assoluto */
          
          transition: opacity 0.2s ease;
          /* ‚ú® EFFETTO DISSOLVENZA: Transizione fluida tra stati visibili e nascosti */
          /* 0.2s offre un effetto di dissolvenza percettibile ma rapido */
      }
      
      /* üëÜ ===== STATO HOVER: Aspetto del Pulsante Quando il Cursore Passa Sopra ===== */
      
      .norman-btn:hover {
          background-color: var(--hover-color);
          /* üü® COLORE PI√ô SCURO: Cambia al colore hover al passaggio del mouse */
          
          transform: translateY(-1px);
          /* ‚¨ÜÔ∏è LEGGERO SOLLEVAMENTO: Il pulsante si solleva leggermente verso il cursore */
          /* Questo movimento sottile crea la sensazione che il pulsante stia rispondendo alla presenza */
          /* Come un pulsante fisico che si solleva leggermente in previsione di essere premuto */
      }
      
      /* üëá ===== STATO ATTIVO: Aspetto del Pulsante Quando Viene Cliccato ===== */
      
      .norman-btn:active {
          transform: translateY(2px);
          /* ‚¨áÔ∏è PRESSIONE VERSO IL BASSO: Il pulsante si muove verso il basso quando cliccato */
          /* 2px di movimento crea l'illusione di una depressione fisica */
          
          box-shadow: var(--shadow-active);
          /* üï≥Ô∏è OMBRA RIDOTTA: L'ombra si riduce mentre il pulsante "si avvicina" alla superficie */
          /* Questo completa la metafora fisica di un pulsante premuto */
      }
      
      
      /* ‚è≥ ===== STATO DI CARICAMENTO: Aspetto del Pulsante Durante l'Elaborazione ===== */
      
      .norman-btn.loading {
          cursor: wait;
          /* ‚è≥ CURSORE DI ATTESA: Cambia il cursore per indicare l'elaborazione in corso */
          
          opacity: 0.8;
          /* üîç LEGGERA TRASPARENZA: Feedback visivo che il pulsante √® in uno stato speciale */
          
          pointer-events: none;
          /* üö´ DISABILITA INTERAZIONI: Previene clic aggiuntivi durante l'elaborazione */
          /* Questo vincolo impedisce agli utenti di fare "clic rabbiosi" o invii doppi */
          
          /* ‚¨áÔ∏è PERSISTENZA VISIVA DELLO STATO DI PRESSIONE FISICA: */
          box-shadow: none;
          /* üö´ NESSUNA OMBRA: Completamente premuto contro la superficie */
          
          transform: translateY(2px);
          /* ‚¨áÔ∏è POSIZIONE PREMUTA: Rimane nella posizione "abbassata" */
          
          background-color: var(--hover-color);
          /* üü® COLORE PI√ô SCURO: Mantiene lo stato di colore attivo */
          /* Tutte queste propriet√† si combinano per mostrare che il pulsante sta "lavorando" */
      }
      
      /* üîÑ ===== ANIMAZIONE LOADER: L'Indicatore Rotante ===== */
      
      .loader {
          /* üëÅÔ∏è GESTIONE VISIBILIT√Ä: Inizialmente nascosto ma pronto ad apparire */
          visibility: hidden;
          /* üö´ INIZIALMENTE NASCOSTO: Non visibile ma ancora nel DOM */
          
          opacity: 0;
          /* üîç COMPLETAMENTE TRASPARENTE: Per una transizione di apparizione fluida */
          
          width: 1rem;
          height: 1rem;
          /* üìè DIMENSIONE LOADER: Quadrato di 16px (1rem = tipicamente 16px) */
          
          /* üí´ DESIGN SPINNER: Crea un indicatore di caricamento circolare */
          border: 2px solid var(--btn-text);
          /* üîò CONTORNO CIRCOLARE: Bordo di 2px che utilizza il colore del testo per coerenza */
          
          border-bottom-color: transparent;
          /* üîç SEGMENTO TRASPARENTE: Crea l'effetto di "cerchio incompleto" */
          /* Questa interruzione visiva nel cerchio √® ci√≤ che crea l'illusione di rotazione */
          
          border-radius: 50%;
          /* üîÑ CERCHIO PERFETTO: Un raggio del 50% crea un cerchio partendo da un quadrato */
          
          animation: rotation 1s linear infinite;
          /* üîÑ ANIMAZIONE ROTANTE: Rotazione continua */
          /* 1s per rivoluzione, temporizzazione lineare (velocit√† costante), non si ferma mai */
      }
      
      /* üîÄ ===== TRANSIZIONI DI STATO: Mostrare/Nascondere Elementi in Base allo Stato ===== */
      
      .norman-btn.loading .btn-text { 
          visibility: hidden;
          /* üö´ NASCONDI TESTO: Rende il testo invisibile durante il caricamento */
          
          opacity: 0;
          /* üîç COMPLETAMENTE TRASPARENTE: Per una transizione di dissolvenza fluida */
      }
      
      .norman-btn.loading .loader { 
          visibility: visible;
          /* üëÅÔ∏è MOSTRA LOADER: Rende il loader visibile durante il caricamento */
          
          opacity: 1;
          /* üîç COMPLETAMENTE OPACO: Per una transizione di apparizione fluida */
      }
      
      /* üîÑ ===== ANIMAZIONE KEYFRAME: Definisce l'Effetto di Rotazione ===== */
      
      @keyframes rotation {
          0% { transform: rotate(0deg); }
          /* üîÑ POSIZIONE INIZIALE: Inizio del ciclo di rotazione a 0 gradi */
          
          100% { transform: rotate(360deg); }
          /* üîÑ POSIZIONE FINALE: Rivoluzione completa di 360 gradi */
          /* L'animazione poi si ripete grazie all'impostazione "infinite" */
      }
    </style>
</head>

<body>
    <!-- üì¶ ===== IL CORPO: Dove Vive il Nostro Pulsante Interattivo! ===== -->
    
    <div class="button-container">
        <!-- üì¶ CONTENITORE PULSANTE: Wrapper per posizionamento e potenziale stile -->
        <!-- Questo contenitore potrebbe essere utilizzato per posizionamento aggiuntivo o decorazioni -->
        
        <button id="action-btn" class="norman-btn" aria-live="polite">
            <!-- üîò L'ELEMENTO PULSANTE: Il nostro componente interattivo -->
            <!-- Usando <button> invece di <div> otteniamo benefici di accessibilit√† gratuiti: -->
            <!-- - Focus da tastiera con il tasto Tab -->
            <!-- - Attivazione con il tasto Invio -->
            <!-- - Riconoscimento come pulsante da parte degli screen reader -->
            
            <!-- üì¢ ATTRIBUTO DI ACCESSIBILIT√Ä: -->
            <!-- aria-live="polite" comunica agli screen reader di annunciare i cambiamenti di stato -->
            <!-- "polite" significa che attender√† finch√© l'utente non avr√† finito ci√≤ che sta facendo -->
            
            <span class="btn-text">Confirm action</span>
            <!-- üìù TESTO PULSANTE: L'etichetta principale del pulsante -->
            <!-- Questo testo svanir√† durante lo stato di caricamento -->
            
            <span class="loader"></span>
            <!-- üîÑ SPINNER DI CARICAMENTO: Appare durante lo stato di caricamento -->
            <!-- Inizialmente invisibile, questo elemento √® pronto ad animarsi quando necessario -->
            <!-- Usare uno span vuoto con stile CSS crea uno spinner compatto ed efficiente -->
        </button>
    </div>

    <script>
      /* üß† ===== JAVASCRIPT: Il Comportamento Interattivo del Pulsante ===== */
      
      const btn = document.getElementById('action-btn');
      /* üîò RIFERIMENTO AL PULSANTE: Ottiene un riferimento all'elemento pulsante */
      /* document.getElementById trova un elemento con l'ID specifico */
      /* Useremo questo riferimento per modificare lo stato del pulsante */
      
      const handleClick = () => {
          /* üéØ GESTORE CLICK: La funzione freccia definisce cosa succede quando il pulsante viene cliccato */
          /* Le funzioni freccia (=>) sono un modo moderno e conciso per scrivere funzioni */
          
          // Vincolo: previeni clic multipli
          if (btn.classList.contains('loading')) return;
          /* üõ°Ô∏è CLAUSOLA DI GUARDIA: Impedisce alla funzione di continuare se √® gi√† in caricamento */
          /* Questa √® una protezione critica contro invii multipli */
          /* Se il pulsante √® gi√† in stato di caricamento, usciamo immediatamente dalla funzione */
          
          // Feedback: entra nello stato di attesa
          btn.classList.add('loading');
          /* ‚è≥ ATTIVA STATO DI CARICAMENTO: Aggiunge la classe CSS che attiva i cambiamenti visivi */
          /* Questa singola riga attiva il nostro spinner di attesa e disabilita ulteriori clic */
          
          // Simulazione di una chiamata asincrona (es. API)
          setTimeout(() => {
              /* ‚è±Ô∏è ESECUZIONE RITARDATA: setTimeout esegue il codice dopo un ritardo specificato */
              /* Questo simula una richiesta di rete o tempo di elaborazione */
              /* In un'app reale, questa sarebbe una chiamata API, operazione su database, ecc. */
              
              // Feedback: termina l'operazione e torna allo stato di riposo
              btn.classList.remove('loading');
              /* ‚úÖ DISATTIVA CARICAMENTO: Rimuove la classe di caricamento */
              /* Questo riporta il pulsante al suo aspetto originale */
              
              alert("Action completed!");
              /* üì¢ MESSAGGIO DI SUCCESSO: Mostra un popup con il messaggio di completamento */
              /* In un'applicazione reale, potresti usare una notifica pi√π sofisticata */
          }, 2000);
          /* ‚è±Ô∏è DURATA TIMEOUT: 2000 millisecondi (2 secondi) */
          /* Questo controlla quanto tempo il pulsante rimane nello stato di caricamento */
      };
      
      btn.addEventListener('click', handleClick);
      /* üñ±Ô∏è CONNESSIONE EVENTO: Collega l'evento di clic alla nostra funzione handler */
      /* Quando il pulsante viene cliccato, il browser chiamer√† la nostra funzione handleClick */
      /* addEventListener √® il modo moderno per collegare eventi senza appesantire l'HTML */
    </script>
</body>

</html>

<!-- üéØ ===== RIASSUNTO DEL PULSANTE INTERATTIVO ===== -->
<!-- 
üîò ARCHITETTURA DEL COMPONENTE:
‚îÇ
‚îú‚îÄ‚îÄ üß† SISTEMA DI DESIGN (Variabili CSS)
‚îÇ   ‚îú‚îÄ‚îÄ üé® Token di colore (primario, hover, sfondo, testo)
‚îÇ   ‚îú‚îÄ‚îÄ üìê Token di forma (border-radius, peso font)
‚îÇ   ‚îî‚îÄ‚îÄ üì¶ Token fisici (effetti ombra per elevazione)
‚îÇ
‚îú‚îÄ‚îÄ üìÑ FONDAMENTA DEL LAYOUT
‚îÇ   ‚îî‚îÄ‚îÄ üìä Griglia centrata sul viewport per posizionamento perfetto
‚îÇ
‚îú‚îÄ‚îÄ üîò DESIGN DEL PULSANTE
‚îÇ   ‚îú‚îÄ‚îÄ üìä Tecnica di sovrapposizione grid per allineamento contenuti
‚îÇ   ‚îú‚îÄ‚îÄ üìè Padding confortevole e larghezza minima
‚îÇ   ‚îî‚îÄ‚îÄ üï≥Ô∏è Effetti di elevazione usando le ombre
‚îÇ
‚îú‚îÄ‚îÄ üîÑ SISTEMA DI STATI
‚îÇ   ‚îú‚îÄ‚îÄ üëÜ Stato hover (cambio colore, leggero sollevamento)
‚îÇ   ‚îú‚îÄ‚îÄ üëá Stato attivo (pressione verso il basso, cambio ombra)
‚îÇ   ‚îî‚îÄ‚îÄ ‚è≥ Stato di caricamento (pressione persistente, spinner)
‚îÇ
‚îî‚îÄ‚îÄ üß† LOGICA DI INTERAZIONE
    ‚îú‚îÄ‚îÄ üõ°Ô∏è Clausola di guardia per prevenire invii multipli
    ‚îú‚îÄ‚îÄ ‚è±Ô∏è Simulazione di operazione asincrona
    ‚îî‚îÄ‚îÄ üì¢ Feedback di successo
    
üéØ CARATTERISTICHE CHIAVE DI DESIGN:
‚îú‚îÄ‚îÄ üé≠ Metafora fisica attraverso elevazione e movimento
‚îú‚îÄ‚îÄ üëÅÔ∏è Chiara comunicazione dello stato attraverso molteplici indizi visivi
‚îú‚îÄ‚îÄ üì± Dimensionamento responsive e layout centrato
‚îú‚îÄ‚îÄ üì¢ Supporto all'accessibilit√† (HTML semantico, attributi ARIA)
‚îî‚îÄ‚îÄ üö´ Prevenzione del doppio invio (sia visuale che funzionale)

Questo pulsante dimostra come un design attento crei esperienze utente intuitive
imitando oggetti fisici e fornendo feedback chiaro ad ogni passo! üîò‚ú®
-->
```

</TabItem>

</Tabs>

## Micro-Patterns

Ho isolato altri concetti chiave dai miei appunti ed ho provato a tradurli in pattern di sviluppo.

### Vincoli e Prevenzione degli Errori

Norman insegna che √® meglio impedire l'errore alla radice piuttosto che curarlo dopo. Invece di mostrare fastidiosi messaggi di errore come "Data non valida" dopo che l'utente ha gi√† cliccato, user√≤ i vincoli nativi dell'HTML5. Ad esempio, impostando gli attributi `min`, `max` e `required` direttamente nell'input, guido l'utente verso l'azione corretta in modo invisibile, sfruttando i vincoli logici per rendere impossibile l'inserimento di dati errati.

### Slips vs. Mistakes

Norman fa una distinzione veramente interessante tra Slips (scivoloni) e Mistakes (errori cognitivi). <br /> 
Uno Slip √® un errore di esecuzione: volevo cliccare 'Modifica' ma il mouse √® "scivolato" su 'Elimina' per distrazione. <br />
Un Mistake, invece, √® un errore di pianificazione: ho eseguito l'azione corretta, ma il mio modello mentale era sbagliato (pensavo che quel bottone facesse un'altra cosa). <br />
Ho capito che, specialmente per gli Slips, la soluzione non √® punire l'utente bloccando il flusso con fastidiosi 'Sei sicuro?', ma offrirgli una via d'uscita elegante. <br />
D'ora in poi, ove possibile, sostituir√≤ la conferma preventiva con un sistema di Undo (Annulla) non intrusivo.
Ecco come immagino questa logica di 'recupero' gestita via codice:

```javascript
// Pattern "Undo" che user√≤ al posto delle modali di conferma
const deleteItem = (itemId) => {
    // Rimuovo l'item dalla vista immediatamente (Feedback istantaneo)
    removeItemFromDOM(itemId);
    
    // Mostro il Toast (una notifica temporanea non intrusiva) con l'opzione Undo
    showToast({
        message: "Elemento eliminato",
        actionText: "Annulla",
        onAction: () => restoreItem(itemId) // Arrow function per il ripristino
    });
};
```

### Il Test del Proiettore Leitz

Il caso del proiettore Leitz citato da Norman, dove un solo tasto gestiva troppe funzioni causando disastri √® anch'esso interessante. Grazie ad esso applicher√≤ una regola che definirei "un'azione = un controllo distinto". Eviter√≤ di creare icone ambigue che cambiano funzione in base al contesto in modo poco chiaro; se un'azione √® diversa, deve avere un controllo visivamente distinto.

## La Rivelazione

Grazie a Don Norman ho capito che l'approccio al CSS non dev'essere focalizzato sulla pura decorazione, un'ombra non serve a rendere il design pi√π moderno o semplicemente gradevole da vedere. Ho compreso che ogni pixel ha un peso comunicativo e la fisica simulata serve a dire al cervello rettiliano dell'utente "questo oggetto si pu√≤ premere". Ho infatti smesso di vedere le micro-interazioni come vezzi stilistici e ho iniziato a vederle come dialoghi necessari, perch√© se il sistema non risponde entro 100 millisecondi con un cambio di stato, l'utente perde inevitabilmente fiducia nell'interfaccia. E, come abbiamo visto, non √® mai colpa dell'utente: se lui sbaglia, significa che sono io ad aver fallito nella progettazione.

## Cosa Ho Imparato

* **Affordance non √® bellezza:** Un bottone bellissimo che non sembra un bottone √® inutile, la funzione deve essere visibile nella forma.
* **Feedback Asincrono:** L'utente deve sempre sapere se il sistema sta lavorando, per questo i Loading States non sono opzionali.
* **Reversibilit√† (Undo > Confirm):** Permettere di rimediare all'errore √® infinitamente meglio che terrorizzare l'utente con modali di conferma continue.
* **Mapping Spaziale:** I controlli devono essere vicini agli oggetti che modificano, raggruppati logicamente per ridurre il carico cognitivo.

## Riflessione

Se dovessi riassumere il libro in una frase direi che il design invisibile √® il design migliore. Se un utente nota il mio bottone perch√© √® esteticamente gradevole, ho fatto un lavoro grafico, ma se lo clicca senza nemmeno pensarci sapendo esattamente cosa succeder√†, ho fatto un lavoro di ingegneria. 
Il mio compito non √® stupire l'occhio, ma liberare la mente da carichi cognitivi inutili. Ogni volta che un utente deve fermarsi a pensare se un elemento √® cliccabile, ho fallito. 
In altre parole il mio codice deve essere la risposta a quella domanda prima ancora che venga formulata.
