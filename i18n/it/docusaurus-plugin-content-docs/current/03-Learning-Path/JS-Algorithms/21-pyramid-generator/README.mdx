---
sidebar_position: 1
sidebar_label: 'Pyramid Generator'
title: 'Pyramid Generator'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Pyramid Generator

<img width="100%" alt="pyramid-generator" src="https://github.com/user-attachments/assets/483436a8-853f-44c2-b52e-71a947c70797" />

### Il Progetto
Generatore di piramidi sviluppato con concetti introduttivi di **JavaScript**, focalizzato su funzioni, loop, condizioni e manipolazione di array per creare pattern di ASCII art.

I started JavaScript enthusiastically, but the enthusiasm quickly faded in the first steps. The syntax, variables, basic concepts didn't give me that sense of "control" I had developed with CSS.

### Codice Sorgente

<Tabs>

<TabItem value="js" label="script.js">

```js
const character = "!";
const count = 10;
const rows = [];
let inverted = false;

function padRow(rowNumber, rowCount) {
  return " ".repeat(rowCount - rowNumber) + character.repeat(2 * rowNumber - 1) + " ".repeat(rowCount - rowNumber);
}

for (let i = 1; i <= count; i++) {
  if (inverted) {
    rows.unshift(padRow(i, count));
  } else {
    rows.push(padRow(i, count));
  }
}

let result = ""

for (const row of rows) {
  result = result + row + "\n";
}

console.log(result);
```

</TabItem> 

<TabItem value="commented" label="spiegato">

```js
// ===== PYRAMID BUILDER: Costruiamo Piramidi con JavaScript! =====

const character = "!";
// MATTONCINO BASE: Il carattere che useremo per costruire
// const = costante, non può essere cambiata dopo
// "!" = il nostro "mattone" per la piramide

const count = 10;
// NUMERO DI PIANI: Quanto alta sarà la piramide
// 10 = una piramide di 10 livelli

const rows = [];
// CONTENITORE RIGHE: Array vuoto che conterrà ogni piano
// [] = array vuoto, come una scatola pronta per essere riempita
// Ogni elemento sarà una riga della piramide

let inverted = false;
// INTERRUTTORE INVERSIONE: Piramide normale o capovolta?
// let = variabile che può cambiare (diverso da const)
// false = piramide normale (punta in alto)
// true = piramide capovolta (punta in basso)

// ===== FUNZIONE COSTRUTTRICE DI RIGHE =====
function padRow(rowNumber, rowCount) {
  // FORMULA MAGICA: Crea una riga perfettamente centrata
  
  return " ".repeat(rowCount - rowNumber) + character.repeat(2 * rowNumber - 1) + " ".repeat(rowCount - rowNumber);
  // SCOMPOSIZIONE DELLA FORMULA:
  
  // 1. SPAZI INIZIALI: " ".repeat(rowCount - rowNumber)
  // Se siamo alla riga 1 di 10: 10 - 1 = 9 spazi
  // Se siamo alla riga 5 di 10: 10 - 5 = 5 spazi
  // Più in alto = più spazi (per centrare)
  
  // 2. CARATTERI CENTRALI: character.repeat(2 * rowNumber - 1)
  // Riga 1: 2 * 1 - 1 = 1 carattere
  // Riga 2: 2 * 2 - 1 = 3 caratteri
  // Riga 3: 2 * 3 - 1 = 5 caratteri
  // Formula per numeri dispari! (1, 3, 5, 7...)
  
  // 3. SPAZI FINALI: " ".repeat(rowCount - rowNumber)
  // Stessi spazi dell'inizio per simmetria
  
  // ESEMPIO riga 3 di 10:
  // 7 spazi + "!!!!!" (5 caratteri) + 7 spazi = riga centrata!
}

// ===== CICLO DI COSTRUZIONE =====
for (let i = 1; i <= count; i++) {
  // COSTRUIAMO PIANO PER PIANO
  // i = 1: primo piano
  // i <= count: continua fino all'ultimo piano (10)
  // i++: sali di un piano ogni volta
  
  if (inverted) {
    rows.unshift(padRow(i, count));
    // PIRAMIDE CAPOVOLTA: Aggiungi all'INIZIO dell'array
    // unshift() = inserisce all'inizio, spingendo gli altri elementi
    // È come mettere i piani dal basso verso l'alto
    
  } else {
    rows.push(padRow(i, count));
    // PIRAMIDE NORMALE: Aggiungi alla FINE dell'array
    // push() = inserisce alla fine dell'array
    // È come costruire dal piano terra verso l'alto
  }
}

// ===== ASSEMBLAGGIO FINALE =====
let result = ""
// STRINGA RISULTATO: Inizia vuota
// Qui assembleremo la piramide completa

for (const row of rows) {
  result = result + row + "\n";
  // INCOLLA LE RIGHE: Una sotto l'altra
  // row = ogni riga della piramide
  // "\n" = "new line", vai a capo
  // È come incollare ogni piano della piramide con una riga vuota sotto
  
  // ALTERNATIVA MODERNA:
  // result += row + "\n";
  // += è shorthand per result = result + ...
}

console.log(result);
// MOSTRA LA PIRAMIDE: Stampa nel terminale
// console.log() = il comando per visualizzare output
// Il momento della verità: vediamo la nostra creazione!

// ===== OUTPUT CON inverted = false =====
//          !           (9 spazi + 1 carattere + 9 spazi)
//         !!!          (8 spazi + 3 caratteri + 8 spazi)
//        !!!!!         (7 spazi + 5 caratteri + 7 spazi)
//       !!!!!!!        (6 spazi + 7 caratteri + 6 spazi)
//      !!!!!!!!!       (5 spazi + 9 caratteri + 5 spazi)
//     !!!!!!!!!!!      (4 spazi + 11 caratteri + 4 spazi)
//    !!!!!!!!!!!!!     (3 spazi + 13 caratteri + 3 spazi)
//   !!!!!!!!!!!!!!!    (2 spazi + 15 caratteri + 2 spazi)
//  !!!!!!!!!!!!!!!!!   (1 spazio + 17 caratteri + 1 spazio)
// !!!!!!!!!!!!!!!!!!! (0 spazi + 19 caratteri + 0 spazi)

// ===== OUTPUT CON inverted = true =====
// !!!!!!!!!!!!!!!!!!!  (base larga in alto)
//  !!!!!!!!!!!!!!!!!   
//   !!!!!!!!!!!!!!!    
//    !!!!!!!!!!!!!     
//     !!!!!!!!!!!      
//      !!!!!!!!!       
//       !!!!!!!        
//        !!!!!         
//         !!!          
//          !           (punta in basso)

// ===== CONCETTI CHIAVE JAVASCRIPT =====
// 1. VARIABILI: const (immutabile) vs let (mutabile)
// 2. ARRAY: Contenitori ordinati di elementi
// 3. FUNZIONI: Blocchi di codice riutilizzabili
// 4. CICLI FOR: Ripetizione controllata
// 5. METODI ARRAY: push() aggiunge alla fine, unshift() all'inizio
// 6. TEMPLATE LITERALS: Anche se qui usiamo concatenazione classica
// 7. OPERATORI: +, -, *, repeat() per stringhe

// ===== ALGORITMO IN BREVE =====
// 1. Definisci i parametri (carattere, altezza, inversione)
// 2. Crea una funzione che costruisce ogni riga con padding
// 3. Usa un ciclo per generare tutte le righe
// 4. Decidi se aggiungerle normalmente o al contrario
// 5. Unisci tutto in una stringa con a capo
// 6. Mostra il risultato!

// È come essere un architetto digitale che costruisce piramidi ASCII!
```
</TabItem>

</Tabs>

Ho iniziato JavaScript con entusiasmo, ma questo è svanito rapidamente nei primi passi. La sintassi, le variabili e i concetti di base non mi davano quella sensazione di “controllo” che avevo sviluppato con il CSS.

### Il Punto di Svolta

La svolta è arrivata con l’introduzione dei **concetti di controllo del flusso** – if ed else. All’improvviso ho visto la struttura logica dietro ogni decisione del codice. Non era più sintassi da memorizzare, ma **logica applicata**: “se questa condizione è vera, fai questo, altrimenti fai quello”.

Ho percepito questi costrutti come naturali, nonostante non avessi mai programmato prima. È stato come se il mio cervello avesse finalmente riconosciuto un linguaggio che parlava la sua stessa lingua: quella delle decisioni logiche.

### L’Approccio Metodico

Pur avendo approfondito la maggior parte degli step con il Code Tutor per garantire una comprensione profonda ed evitare lacune, ho mantenuto una regola ferrea: **approfondire solo dopo aver completato lo step**.

**Risultato:** in sole tre occasioni su 118 step ho dovuto chiedere aiuto al Code Tutor. Questo dimostra che l’approccio “prima completare, poi approfondire” funziona.

### La Mancanza del Lato Visivo

Mi manca il lato visivo, lo ammetto. Non sono soddisfatto di `console.log`, non sono soddisfatto di “parlare con me stesso” tramite il computer. **Voglio che il computer parli con gli utenti.**

### Il Ritorno dell’Entusiasmo

Non sono stati solo i concetti di if ed else a ridarmi energia, ma anche la prospettiva dell’integrazione di JavaScript con HTML e CSS. Sbirciando i prossimi progetti ho visto che a partire dal terzo progetto **mescoleremo JavaScript con HTML e CSS**.

Finalmente potrò vedere i risultati della mia logica in azione nell’interfaccia utente, non più limitati a console.log.

Non vedo l’ora di aggiornare il real-world-handbook con gli ultimi concetti JavaScript appresi!

### Cosa Ho Imparato

**1. Fondamenti delle Variabili:**

* **let** vs **const** – quando usare variabili riassegnabili o costanti
* **undefined** – stato delle variabili non inizializzate
* **Scope** – variabili globali vs locali

**2. Tipi di Dato:**

* **Stringhe** – apici singoli vs doppi, concatenazione, `.repeat()`
* **Numeri** – operazioni aritmetiche, uso nei calcoli
* **Booleani** – true/false, valori falsy (`""`, `0`, `false`)

**3. Array – Le Collezioni:**

* Creazione e accesso tramite indice `[0]`, `[1]`
* **.push()** – aggiungere alla fine
* **.unshift()** – aggiungere all’inizio
* **.length** – proprietà per la lunghezza

**4. Funzioni – I Blocchi Riutilizzabili:**

* Dichiarazione e invocazione
* **Parametri multipli** (es.: `padRow(rowNumber, rowCount)`)
* **Return statement** per restituire valori
* **Scope locale** – variabili interne alle funzioni

**5. Controllo del Flusso:**

* **if/else** – condizioni base e multiple
* **Operatori di confronto** `(<, >, <=, ==, ===, !==)`
* Differenza tra uguaglianza debole (`==`) e stretta (`===`)

**6. Loop – Le Ripetizioni:**

* **for classico** – inizializzazione, condizione, incremento
* **while** – con condizioni complesse
* **for...of** – per iterare sugli array
* **Operatori di incremento** (`i++`, `i+=`, `i--`)

**7. Operatori:**

* **Aritmetici** (`+`, `-`, `*`, precedenza degli operatori)
* **Di assegnazione** (`=`, `+=`, `-=`)
* **Concatenazione di stringhe** con `+`

**8. Console e Output:**

* **console.log()** per output e debug
* Test di valori e funzioni

**9. Commenti:**

* Singola riga (`//`) e multi-linea (`/* */`)
* Best practice per la documentazione

**10. Pattern e Costrutti Pratici:**

* **Boolean flag** per il controllo del flusso (`inverted`)
* **Accumulo del risultato** (`result = result + row + "\n"`)
* **Formula matematica** per i pattern (`2 * rowNumber - 1`)
* **Decisioni condizionali nei loop** (if dentro il for)

**11. Best Practice Osservate:**

* **Naming convention** camelCase
* **Refactoring progressivo** da codice ripetitivo a DRY
* **Testing incrementale** con console.log

### Riflessione

JavaScript inizialmente mi è sembrato astratto rispetto alla concretezza visiva di HTML e CSS. Al momento sto ancora lavorando con console.log e non ho ancora visto JavaScript in azione con la manipolazione del DOM, ma la prospettiva di far **reagire** le interfacce alle azioni dell’utente mi incuriosisce moltissimo.

Il `console.log` è solo l’inizio: quando vedrò finalmente questa logica dare vita a esperienze utente interattive, capirò davvero la potenza di questo linguaggio.

---

**Prossimo Progetto**: Ripassare i fondamenti di JavaScript costruendo una Gradebook App
