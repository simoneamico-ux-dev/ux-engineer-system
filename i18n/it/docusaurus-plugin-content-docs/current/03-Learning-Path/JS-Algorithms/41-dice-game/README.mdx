---
sidebar_position: 16
sidebar_label: 'Dice Game'
title: 'Dice Game'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Dice Game

<img width="100%" alt="Dice game main interface showing game rules and 5 dice" src="https://github.com/user-attachments/assets/bcd9d61b-26eb-430e-aa25-0343060dcba2" />
<img width="100%" alt="Game interface showing a small straight pattern with score of 30 points" src="https://github.com/user-attachments/assets/1b41c462-c3d7-4a61-85bb-994a4d2a0217" />
<img width="100%" alt="Score history panel showing total score of 30 from one small straight worth 30 points" src="https://github.com/user-attachments/assets/82cf4a0c-8b3d-4588-8a12-6acc9319de0c" />
<img width="100%" alt="Game over screen displaying final score" src="https://github.com/user-attachments/assets/496e8e87-4a19-4d0c-b21f-57070f7174c2" />

### Il Progetto
Dice Game sviluppato con JavaScript puro, focalizzato su logica algoritmica, gestione dello stato e manipolazione del DOM. Un progetto che richiede di mettere insieme molteplici concetti precedentemente appresi in un contesto con poca guida strutturata.

### Codice Sorgente

<Tabs>
<TabItem value="html" label="index.html" default>

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Advanced Dice Game</title>
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <header>
    <h1>Advanced Dice Game</h1>
    <button class="btn" id="rules-btn" type="button">Show rules</button>
    <div class="rules-container">
      <h2>Rules</h2>
      <ul>
        <li>There are total of six rounds</li>
        <li>You can only roll the dice three times per round</li>
        <li>To start the game, roll the dice</li>
        <li>
          Then, choose from one of the selected scores or roll the dice again
        </li>
        <li>
          If you choose a selected score, then you will move to the next round
        </li>
        <li>
          If you decline to choose a selected score, then you can roll the
          dice again two more times
        </li>
      </ul>
      <h2 class="points">Points</h2>
      <ul>
        <li>Three of a kind: Sum of all five dice</li>
        <li>Four of a kind: Sum of all five dice</li>
        <li>Full house: Three of a kind and a pair - 25 points</li>
        <li>
          Small straight: Four of the dice have consecutive values - 30 points
        </li>
        <li>
          Large straight: All five dice have consecutive values - 40 points
        </li>
      </ul>
    </div>
  </header>

  <main>
    <form id="game">
      <div id="dice">
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
      </div>

      <p class="rounds-text">
        <strong>Rolls:</strong> <span id="current-round-rolls">0</span> |
        <strong>Round:</strong> <span id="current-round">1</span>
      </p>

      <div id="score-options">
        <div>
          <input type="radio" name="score-options" id="three-of-a-kind" value="three-of-a-kind" disabled />
          <label for="three-of-a-kind">Three of a kind<span></span></label>
        </div>
        <div>
          <input type="radio" name="score-options" id="four-of-a-kind" value="four-of-a-kind" disabled />
          <label for="four-of-a-kind">Four of a kind<span></span></label>
        </div>
        <div>
          <input type="radio" name="score-options" id="full-house" value="full-house" disabled />
          <label for="full-house">Full house<span></span></label>
        </div>
        <div>
          <input type="radio" name="score-options" id="small-straight" value="small-straight" disabled />
          <label for="small-straight">Small straight<span></span></label>
        </div>
        <div>
          <input type="radio" name="score-options" id="large-straight" value="large-straight" disabled />
          <label for="large-straight">Large straight<span></span></label>
        </div>

        <div>
          <input type="radio" name="score-options" id="none" value="none" disabled />
          <label for="none">None of the above<span></span></label>
        </div>
      </div>

      <button class="btn" id="keep-score-btn" type="button">
        Keep the above selected score
      </button>
      <button class="btn" id="roll-dice-btn" type="button">
        Roll the dice
      </button>
    </form>

    <div id="scores">
      <h3>Score history (Total score: <span id="total-score">0</span>)</h3>
      <ol id="score-history"></ol>
    </div>
  </main>
  <script src="./script.js"></script>
</body>

</html>
```
</TabItem>

<TabItem value="css" label="styles.css">

```css
*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  --dark-grey: #1b1b32;
  --light-grey: #f5f6f7;
  --black: #000;
  --white: #fff;
  --grey: #3b3b4f;
  --golden-yellow: #fecc4c;
  --yellow: #ffcc4c;
  --gold: #feac32;
  --orange: #ffac33;
  --dark-orange: #f89808;
}

body {
  background-color: var(--dark-grey);
}

header {
  color: var(--light-grey);
  text-align: center;
}

h1 {
  font-size: 2.5rem;
  margin: 25px 0;
}

.rules-container {
  display: none;
  background-color: var(--light-grey);
  color: var(--black);
  width: 50%;
  margin: 20px auto;
  height: 300px;
  border-radius: 10px;
  overflow-y: scroll;
}

.rules-container ul {
  list-style-type: none;
}

.points {
  margin-top: 15px;
}

main {
  background-color: var(--light-grey);
  padding: 20px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
  gap: 1rem;
  margin: auto;
  justify-items: center;
  width: 50%;
  border-radius: 10px;
}

#dice {
  display: flex;
  justify-content: space-around;
  margin-bottom: 15px;
}

.die {
  width: 40px;
  height: 40px;
  text-align: center;
  margin-right: 15px;
  border: 4px solid var(--black);
  padding: 10px;
}

.rounds-text {
  text-align: center;
}

input[type="radio"]:disabled + label {
  color: var(--grey);
}

#score-history {
  margin-top: 15px;
  text-align: center;
  list-style-position: inside;
}

.btn {
  cursor: pointer;
  width: 200px;
  margin: 10px 0 10px 0.5rem;
  color: var(--black);
  background-color: var(--gold);
  background-image: linear-gradient(var(--golden-yellow), var(--orange));
  border-color: var(--gold);
  border-width: 3px;
}

.btn:hover:enabled {
  background-image: linear-gradient(var(--yellow), var(--dark-orange));
}

@media (max-width: 992px) {
  main {
    width: 100%;
  }
}

@media (max-width: 500px) {
  .btn {
    width: 120px;
  }
}
```
</TabItem>

<TabItem value="js" label="script.js">

```js
const listOfAllDice = document.querySelectorAll(".die");
const scoreInputs = document.querySelectorAll("#score-options input");
const scoreSpans = document.querySelectorAll("#score-options span");
const roundElement = document.getElementById("current-round");
const rollsElement = document.getElementById("current-round-rolls");
const totalScoreElement = document.getElementById("total-score");
const scoreHistory = document.getElementById("score-history");
const rollDiceBtn = document.getElementById("roll-dice-btn");
const keepScoreBtn = document.getElementById("keep-score-btn");
const rulesContainer = document.querySelector(".rules-container");
const rulesBtn = document.getElementById("rules-btn");

let diceValuesArr = [];
let isModalShowing = false;
let score = 0;
let round = 1;
let rolls = 0;

const rollDice = () => {
  diceValuesArr = [];

  for (let i = 0; i < 5; i++) {
    const randomDice = Math.floor(Math.random() * 6) + 1;
    diceValuesArr.push(randomDice);
  };

  listOfAllDice.forEach((dice, index) => {
    dice.textContent = diceValuesArr[index];
  });
};

const updateStats = () => {
  rollsElement.textContent = rolls;
  roundElement.textContent = round;
};

const updateRadioOption = (index, score) => {
  scoreInputs[index].disabled = false;
  scoreInputs[index].value = score;
  scoreSpans[index].textContent = `, score = ${score}`;
};

const updateScore = (selectedValue, achieved) => {
  score += parseInt(selectedValue);
  totalScoreElement.textContent = score;

  scoreHistory.innerHTML += `<li>${achieved} : ${selectedValue}</li>`;
};


const getHighestDuplicates = (arr) => {
  const counts = {};

  for (const num of arr) {
    if (counts[num]) {
      counts[num]++;
    } else {
      counts[num] = 1;
    }
  }

  let highestCount = 0;

  for (const num of arr) {
    const count = counts[num];
    if (count >= 3 && count > highestCount) {
      highestCount = count;
    }
    if (count >= 4 && count > highestCount) {
      highestCount = count;
    }
  }

  const sumOfAllDice = arr.reduce((a, b) => a + b, 0);

  if (highestCount >= 4) {
    updateRadioOption(1, sumOfAllDice);
  }

  if (highestCount >= 3) {
    updateRadioOption(0, sumOfAllDice);
  }

};

const detectFullHouse = (arr) => {
  const counts = {};

  for (const num of arr) {
    counts[num] = counts[num] ? counts[num] + 1 : 1;
  }

  const hasThreeOfAKind = Object.values(counts).includes(3);
  const hasPair = Object.values(counts).includes(2);

  if (hasThreeOfAKind && hasPair) {
    updateRadioOption(2, 25);
  }

};

const checkForStraights = (arr) => {
  const sortedNumbersArr = arr.sort((a, b) => a - b);
  const uniqueNumbersArr = [...new Set(sortedNumbersArr)];
  const uniqueNumbersStr = uniqueNumbersArr.join("");

  const smallStraightsArr = ["1234", "2345", "3456"];
  const largeStraightsArr = ["12345", "23456"];

  if (smallStraightsArr.some(straight => uniqueNumbersStr.includes(straight))) {
    updateRadioOption(3, 30);
  }

  if (largeStraightsArr.includes(uniqueNumbersStr)) {
    updateRadioOption(4, 40);
  }

};

const resetRadioOptions = () => {
  scoreInputs.forEach((input) => {
    input.disabled = true;
    input.checked = false;
  });

  scoreSpans.forEach((span) => {
    span.textContent = "";
  });
};

const resetGame = () => {
  diceValuesArr = [0, 0, 0, 0, 0];
  score = 0;
  round = 1;
  rolls = 0;

  listOfAllDice.forEach((dice, index) => {
    dice.textContent = diceValuesArr[index];
  });

  totalScoreElement.textContent = score;
  scoreHistory.innerHTML = "";

  rollsElement.textContent = rolls;
  roundElement.textContent = round;

  resetRadioOptions();
};

rollDiceBtn.addEventListener("click", () => {
  if (rolls === 3) {
    alert("You have made three rolls this round. Please select a score.");
  } else {
    rolls++;
    resetRadioOptions();
    rollDice();
    updateStats();
    getHighestDuplicates(diceValuesArr);
    detectFullHouse(diceValuesArr);
    checkForStraights(diceValuesArr);
    updateRadioOption(5, 0);
  }
});

rulesBtn.addEventListener("click", () => {
  isModalShowing = !isModalShowing;

  if (isModalShowing) {
    rulesBtn.textContent = "Hide rules";
    rulesContainer.style.display = "block";
  } else {
    rulesBtn.textContent = "Show rules";
    rulesContainer.style.display = "none";
  }
});

keepScoreBtn.addEventListener("click", () => {
  let selectedValue;
  let achieved;

  for (const radioButton of scoreInputs) {
    if (radioButton.checked) {
      selectedValue = radioButton.value;
      achieved = radioButton.id;
      break;
    }
  }

  if (selectedValue) {
    rolls = 0;
    round++;
    updateStats();
    resetRadioOptions();
    updateScore(selectedValue, achieved);
    if (round > 6) {
      setTimeout(() => {
        alert(`Game Over! Your total score is ${score}`);
        resetGame();
      }, 500);
    }
  } else {
    alert("Please select an option or roll the dice");
  }
});
```

</TabItem> 

<TabItem value="commented" label="spiegato">

```html
<!DOCTYPE html>
<!-- üéØ DICHIARAZIONE HTML5: "Benvenuti nell'universo dei giochi di dadi!" -->
<!-- √à come annunciare le regole del gioco prima di una serata di giochi da tavolo! üé≤ -->

<html lang="en">
<!-- üåç CONTENITORE PRINCIPALE: La nostra applicazione interattiva di gioco con dadi -->
<!-- lang="en" = Inglese, per rendere il nostro gioco accessibile a livello internazionale -->

<head>
  <!-- üß† IL CENTRO DI COMANDO: Dove impostiamo l'ambiente di gioco -->
  <!-- Proprio come preparare un tavolo prima di giocare a un gioco da tavolo - disponendo regole e pezzi! -->
  
  <meta charset="utf-8" />
  <!-- üìù CODIFICA DEI CARATTERI: UTF-8 assicura che simboli come i dadi (‚öÄ ‚öÅ ‚öÇ ‚öÉ ‚öÑ ‚öÖ) vengano visualizzati correttamente -->
  <!-- Senza una codifica adeguata, i caratteri speciali potrebbero apparire corrotti -->
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- üì± DESIGN RESPONSIVE: "Gioca a questo gioco su qualsiasi dispositivo!" -->
  <!-- Proprio come i giochi da tavolo possono essere giocati su tavoli di qualsiasi dimensione -->
  
  <title>Advanced Dice Game</title>
  <!-- üìë TITOLO DEL GIOCO: Appare nella scheda del browser -->
  <!-- Semplice e descrittivo - dice esattamente ai giocatori cosa stanno per provare! -->
  
  <style>
    /* üé® ===== STILI CSS: Il Design Visuale del Gioco ===== */
    
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      /* üì¶ BOX-SIZING: Include padding e bordi nelle dimensioni degli elementi */
      /* Previene problemi di layout - come assicurarsi che i pezzi del gioco si adattino ai loro spazi! */
      
      margin: 0;
      padding: 0;
      /* üßπ RESET: Cancella la spaziatura predefinita del browser */
      /* Come ripulire un tavolo prima di preparare un gioco da tavolo */
    }
    
    :root {
      /* üé® PALETTE DI COLORI: Colori a tema del gioco definiti come variabili */
      /* Come scegliere un tema di colori specifico per i pezzi del gioco */
      
      --dark-grey: #1b1b32;
      /* ‚ö´ SFONDO SCURO: Grigio-blu profondo per il tavolo da gioco */
      
      --light-grey: #f5f6f7;
      /* ‚ö™ GRIGIO CHIARO: Per le aree di gioco e le carte */
      
      --black: #000;
      /* ‚ö´ NERO PURO: Per testo e bordi */
      
      --white: #fff;
      /* ‚ö™ BIANCO PURO: Per elementi di contrasto */
      
      --grey: #3b3b4f;
      /* üîò GRIGIO MEDIO: Per elementi disabilitati */
      
      --golden-yellow: #fecc4c;
      /* üü° GIALLO DORATO: Colore di accento brillante */
      
      --yellow: #ffcc4c;
      /* üíõ GIALLO: Leggermente diverso per sfumature */
      
      --gold: #feac32;
      /* ü•á ORO: Colore primario dei pulsanti */
      
      --orange: #ffac33;
      /* üü† ARANCIONE: Per sfumature dei pulsanti */
      
      --dark-orange: #f89808;
      /* üî∂ ARANCIONE SCURO: Per effetti hover dei pulsanti */
    }
    
    body {
      background-color: var(--dark-grey);
      /* üéÆ SFONDO DEL GIOCO: Tema scuro come un tavolo da casin√≤ */
      /* Crea un ambiente di gioco immersivo */
    }
    
    header {
      color: var(--light-grey);
      /* ‚ö™ TESTO DELL'INTESTAZIONE: Testo chiaro su sfondo scuro */
      /* Alto contrasto rende il titolo e le regole facili da leggere */
      
      text-align: center;
      /* ‚öñÔ∏è TESTO CENTRATO: Titolo e regole allineati al centro */
      /* Come avere il titolo del gioco centrato sulla copertina della scatola */
    }
    
    h1 {
      font-size: 2.5rem;
      /* üìè TITOLO GRANDE: 2,5 volte la dimensione del carattere base */
      /* Fa risaltare il titolo del gioco, come sulla copertina di una scatola */
      
      margin: 25px 0;
      /* üå¨Ô∏è SPAZIATURA VERTICALE: Spazio sopra e sotto il titolo */
      /* Crea spazio di respiro tra gli elementi */
    }
    
    .rules-container {
      display: none;
      /* üôà INIZIALMENTE NASCOSTO: Le regole partono nascoste */
      /* Come tenere il manuale chiuso fino a quando non serve */
      
      background-color: var(--light-grey);
      /* üìÑ SFONDO CHIARO: Regole su carta chiara per leggibilit√† */
      
      color: var(--black);
      /* üñãÔ∏è TESTO NERO: Massimo contrasto per una facile lettura */
      
      width: 50%;
      /* üìè LARGHEZZA CONTENITORE: Occupa met√† della larghezza disponibile */
      /* Mantiene le regole leggibili senza sovrastare lo schermo */
      
      margin: 20px auto;
      /* ‚öñÔ∏è CENTRATO: Margini uguali a sinistra e destra */
      /* Posiziona la casella delle regole al centro dello schermo */
      
      height: 300px;
      /* üìè ALTEZZA FISSA: Scrolling per contenuti aggiuntivi */
      /* Come un manuale compatto con pi√π pagine */
      
      border-radius: 10px;
      /* üîÑ ANGOLI ARROTONDATI: Aspetto visivo pi√π morbido */
      /* Fa sembrare le regole come una carta da gioco */
      
      overflow-y: scroll;
      /* üìú SCROLLING VERTICALE: Per regole che non entrano */
      /* Permette l'accesso a tutti i contenuti senza occupare troppo spazio */
    }
    
    .rules-container ul {
      list-style-type: none;
      /* üö´ NESSUN PUNTO ELENCO: Aspetto lista pulito */
      /* Rende le regole simili a un manuale professionale */
    }
    
    .points {
      margin-top: 15px;
      /* ‚¨ÜÔ∏è SPAZIATURA SUPERIORE: Spazio prima della sezione punti */
      /* Separa visivamente le sezioni delle regole */
    }
    
    main {
      background-color: var(--light-grey);
      /* üìÑ SFONDO CHIARO: L'area di gioco risalta contro lo sfondo scuro */
      /* Come il panno su un tavolo da gioco */
      
      padding: 20px;
      /* üå¨Ô∏è SPAZIATURA INTERNA: Spazio attorno a tutti i contenuti */
      /* Impedisce agli elementi di toccare i bordi */
      
      display: grid;
      /* üì¶ LAYOUT A GRIGLIA: Organizza gli elementi del gioco in colonne */
      /* Come organizzare diverse aree su un gioco da tavolo */
      
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      /* üìè GRIGLIA RESPONSIVE: Le colonne si adattano allo spazio disponibile */
      /* Le colonne devono essere larghe almeno 500px, poi condividono lo spazio disponibile */
      /* Su schermi pi√π piccoli, si impilano verticalmente */
      
      gap: 1rem;
      /* üìè SPAZIO TRA ELEMENTI: Spazio tra gli elementi della griglia */
      /* Separa chiaramente le sezioni del gioco */
      
      margin: auto;
      /* ‚öñÔ∏è CENTRATO: Centrato orizzontalmente sulla pagina */
      
      justify-items: center;
      /* ‚öñÔ∏è ELEMENTI CENTRATI: Elementi della griglia centrati nelle loro celle */
      
      width: 50%;
      /* üìè LARGHEZZA CONTENITORE: Occupa met√† della larghezza disponibile */
      /* Impedisce all'area di gioco di essere troppo larga su schermi grandi */
      
      border-radius: 10px;
      /* üîÑ ANGOLI ARROTONDATI: Aspetto visivo pi√π morbido */
      /* Fa sembrare la tavola da gioco come una carta o un tappetino da gioco */
    }
    
    #dice {
      display: flex;
      /* üì¶ LAYOUT FLESSIBILE: Dispone i dadi in una riga */
      /* Come allineare i dadi dopo un lancio */
      
      justify-content: space-around;
      /* ‚öñÔ∏è DISTRIBUZIONE UNIFORME: Spazio distribuito tra i dadi */
      /* D√† a ciascun dado spazio per respirare */
      
      margin-bottom: 15px;
      /* ‚¨áÔ∏è SPAZIO INFERIORE: Spazio dopo i dadi */
      /* Separa i dadi dalle opzioni sottostanti */
    }
    
    .die {
      width: 40px;
      /* üìè LARGHEZZA DADO: Dimensioni quadrate */
      
      height: 40px;
      /* üìè ALTEZZA DADO: Dimensioni quadrate */
      
      text-align: center;
      /* ‚öñÔ∏è TESTO CENTRATO: Valore del dado centrato */
      /* Come i dadi reali con punti centrati */
      
      margin-right: 15px;
      /* ‚û°Ô∏è SPAZIO A DESTRA: Spazio tra i dadi */
      /* Impedisce ai dadi di toccarsi */
      
      border: 4px solid var(--black);
      /* üî≤ BORDO SPESSO: Contorno in grassetto per ogni dado */
      /* Fa risaltare i dadi come pezzi fisici del gioco */
      
      padding: 10px;
      /* üå¨Ô∏è SPAZIATURA INTERNA: Spazio attorno al valore del dado */
      /* Assicura che il numero non tocchi i bordi */
    }
    
    .rounds-text {
      text-align: center;
      /* ‚öñÔ∏è TESTO CENTRATO: Contatore dei round centrato */
      /* Enfatizza questa importante informazione di gioco */
    }
    
    input[type="radio"]:disabled + label {
      color: var(--grey);
      /* üîò COLORE DISABILITATO: Testo grigio per opzioni non disponibili */
      /* Feedback visivo che queste opzioni non possono essere selezionate */
    }
    
    #score-history {
      margin-top: 15px;
      /* ‚¨ÜÔ∏è SPAZIO SUPERIORE: Spazio prima della cronologia punteggi */
      /* Separa la cronologia dagli altri elementi */
      
      text-align: center;
      /* ‚öñÔ∏è TESTO CENTRATO: Cronologia centrata sulla pagina */
      
      list-style-position: inside;
      /* üìå POSIZIONE PUNTI ELENCO: Punti all'interno del contenitore */
      /* Mantiene l'elenco allineato correttamente anche se centrato */
    }
    
    .btn {
      cursor: pointer;
      /* üëÜ CURSORE MANO: Mostra che i pulsanti sono cliccabili */
      /* Feedback interattivo per gli utenti */
      
      width: 200px;
      /* üìè LARGHEZZA PULSANTE: Larghezza fissa per coerenza */
      
      margin: 10px 0 10px 0.5rem;
      /* üå¨Ô∏è MARGINI PULSANTE: Spazio attorno a tutti i pulsanti */
      /* Impedisce ai pulsanti di toccarsi */
      
      color: var(--black);
      /* ‚ö´ COLORE TESTO: Testo scuro per contrasto */
      
      background-color: var(--gold);
      /* üü° COLORE BASE: Fallback se la sfumatura fallisce */
      
      background-image: linear-gradient(var(--golden-yellow), var(--orange));
      /* üåÖ RIEMPIMENTO SFUMATO: Dal giallo all'arancione */
      /* Crea un effetto pulsante 3D */
      
      border-color: var(--gold);
      /* üî≤ COLORE BORDO: Corrisponde al tema del pulsante */
      
      border-width: 3px;
      /* üìè SPESSORE BORDO: Bordo sostanziale */
      /* Rende i pulsanti pi√π tattili e cliccabili */
    }
    
    .btn:hover:enabled {
      background-image: linear-gradient(var(--yellow), var(--dark-orange));
      /* üîÜ STATO HOVER: Sfumatura pi√π luminosa quando il mouse passa sopra */
      /* Si applica solo quando il pulsante √® abilitato (:enabled) */
      /* Feedback visivo per elementi interattivi */
    }
    
    @media (max-width: 992px) {
      /* üì± SCHERMI MEDI: Tablet e portatili pi√π piccoli */
      
      main {
        width: 100%;
        /* üìè LARGHEZZA INTERA: L'area di gioco si espande a tutta larghezza */
        /* Sfrutta meglio lo spazio disponibile su schermi pi√π piccoli */
      }
    }
    
    @media (max-width: 500px) {
      /* üì± SCHERMI PICCOLI: Telefoni cellulari */
      
      .btn {
        width: 120px;
        /* üìè PULSANTI PI√ô STRETTI: Si adattano meglio a schermi piccoli */
        /* Assicura che i pulsanti non straripino su dispositivi minuscoli */
      }
    }
  </style>
</head>

<body>
  <!-- üé≤ ===== IL CORPO: Dove Vive Il Nostro Gioco di Dadi! ===== -->
  
  <header>
    <!-- üìú INTESTAZIONE DEL GIOCO: Sezione titolo e regole -->
    
    <h1>Advanced Dice Game</h1>
    <!-- üéÆ TITOLO DEL GIOCO: Annuncio chiaro e in grassetto di cosa stiamo giocando -->
    
    <button class="btn" id="rules-btn" type="button">Show rules</button>
    <!-- üìú TOGGLE REGOLE: Pulsante per mostrare/nascondere le regole del gioco -->
    <!-- Mantiene l'interfaccia pulita fino a quando le regole non sono necessarie -->
    
    <div class="rules-container">
      <!-- üìú SEZIONE REGOLE: Inizialmente nascosta, si mostra quando richiesto -->
      
      <h2>Rules</h2>
      <!-- üìù TITOLO SEZIONE: Etichetta chiaramente questa come sezione delle regole -->
      
      <ul>
        <!-- üìã ELENCO REGOLE: Istruzioni strutturate del gioco -->
        
        <li>There are total of six rounds</li>
        <!-- üî¢ DURATA DEL GIOCO: Stabilisce aspettative chiare per la durata del gioco -->
        
        <li>You can only roll the dice three times per round</li>
        <!-- üé≤ LIMITE DI LANCIO: Regola critica che limita le azioni del giocatore -->
        
        <li>To start the game, roll the dice</li>
        <!-- üé¨ AZIONE INIZIALE: Primo passo per il giocatore -->
        
        <li>
          Then, choose from one of the selected scores or roll the dice again
        </li>
        <!-- üîÑ SCELTA DEL GIOCATORE: Spiega il punto decisionale dopo il lancio -->
        
        <li>
          If you choose a selected score, then you will move to the next round
        </li>
        <!-- ‚û°Ô∏è AVANZAMENTO DEL ROUND: Come progredire nel gioco -->
        
        <li>
          If you decline to choose a selected score, then you can roll the
          dice again two more times
        </li>
        <!-- üîÑ OPZIONE DI RILANCIO: Alternativa alla selezione del punteggio -->
      </ul>
      
      <h2 class="points">Points</h2>
      <!-- üíØ SEZIONE PUNTEGGI: Spiega come si guadagnano i punti -->
      
      <ul>
        <!-- üìã ELENCO PUNTEGGI: Diversi modi per ottenere punti -->
        
        <li>Three of a kind: Sum of all five dice</li>
        <!-- üé≤ OPZIONE PUNTEGGIO: Tre dadi uguali ottengono la somma -->
        
        <li>Four of a kind: Sum of all five dice</li>
        <!-- üé≤ OPZIONE PUNTEGGIO: Quattro dadi uguali ottengono la somma -->
        
        <li>Full house: Three of a kind and a pair - 25 points</li>
        <!-- üé≤ OPZIONE PUNTEGGIO: Tre uguali + una coppia ottengono 25 punti fissi -->
        
        <li>
          Small straight: Four of the dice have consecutive values - 30 points
        </li>
        <!-- üé≤ OPZIONE PUNTEGGIO: Quattro dadi consecutivi ottengono 30 punti fissi -->
        
        <li>
          Large straight: All five dice have consecutive values - 40 points
        </li>
        <!-- üé≤ OPZIONE PUNTEGGIO: Cinque dadi consecutivi ottengono 40 punti fissi -->
      </ul>
    </div>
  </header>

  <main>
    <!-- üéÆ AREA PRINCIPALE DEL GIOCO: Dove avviene il gameplay -->
    
    <form id="game">
      <!-- üìã FORM DEL GIOCO: Contenitore per elementi interattivi -->
      <!-- I form forniscono struttura per gli input dell'utente -->
      
      <div id="dice">
        <!-- üé≤ CONTENITORE DADI: Contiene i cinque dadi -->
        
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
        <!-- üé≤ DADI INDIVIDUALI: Cinque dadi per il gioco -->
        <!-- Ciascuno mostrer√† un numero casuale quando lanciato -->
      </div>

      <p class="rounds-text">
        <!-- üìä STATO DEL GIOCO: Mostra round e lanci correnti -->
        
        <strong>Rolls:</strong> <span id="current-round-rolls">0</span> |
        <!-- üé≤ CONTATORE LANCI: Tiene traccia dei lanci nel round corrente -->
        <!-- Limitato a 3 per round come da regole -->
        
        <strong>Round:</strong> <span id="current-round">1</span>
        <!-- üî¢ CONTATORE ROUND: Tiene traccia di quale dei sei round stiamo giocando -->
      </p>

      <div id="score-options">
        <!-- üìä OPZIONI DI PUNTEGGIO: Combinazioni disponibili da selezionare -->
        
        <div>
          <input type="radio" name="score-options" id="three-of-a-kind" value="three-of-a-kind" disabled />
          <label for="three-of-a-kind">Three of a kind<span></span></label>
          <!-- üé≤ OPZIONE PUNTEGGIO: Tre dadi uguali -->
          <!-- Inizialmente disabilitata finch√© questa combinazione non viene lanciata -->
          <!-- <span> mostrer√† il punteggio calcolato -->
        </div>
        
        <div>
          <input type="radio" name="score-options" id="four-of-a-kind" value="four-of-a-kind" disabled />
          <label for="four-of-a-kind">Four of a kind<span></span></label>
          <!-- üé≤ OPZIONE PUNTEGGIO: Quattro dadi uguali -->
        </div>
        
        <div>
          <input type="radio" name="score-options" id="full-house" value="full-house" disabled />
          <label for="full-house">Full house<span></span></label>
          <!-- üé≤ OPZIONE PUNTEGGIO: Tre uguali + coppia -->
        </div>
        
        <div>
          <input type="radio" name="score-options" id="small-straight" value="small-straight" disabled />
          <label for="small-straight">Small straight<span></span></label>
          <!-- üé≤ OPZIONE PUNTEGGIO: Quattro valori consecutivi -->
        </div>
        
        <div>
          <input type="radio" name="score-options" id="large-straight" value="large-straight" disabled />
          <label for="large-straight">Large straight<span></span></label>
          <!-- üé≤ OPZIONE PUNTEGGIO: Cinque valori consecutivi -->
        </div>

        <div>
          <input type="radio" name="score-options" id="none" value="none" disabled />
          <label for="none">None of the above<span></span></label>
          <!-- üé≤ OPZIONE FALLBACK: Quando non si ottiene alcuna combinazione di punteggio -->
          <!-- Permette al giocatore di procedere con zero punti -->
        </div>
      </div>

      <button class="btn" id="keep-score-btn" type="button">
        Keep the above selected score
      </button>
      <!-- ‚úÖ PULSANTE CONFERMA: Blocca l'opzione di punteggio selezionata -->
      <!-- Avanza al round successivo dopo la selezione -->
      
      <button class="btn" id="roll-dice-btn" type="button">
        Roll the dice
      </button>
      <!-- üé≤ PULSANTE LANCIO: Genera nuovi valori casuali dei dadi -->
      <!-- Limitato a 3 usi per round -->
    </form>

    <div id="scores">
      <!-- üìä SEZIONE PUNTEGGIO: Tiene traccia dell'andamento del gioco -->
      
      <h3>Score history (Total score: <span id="total-score">0</span>)</h3>
      <!-- üìä TOTALE IN CORSO: Mostra i punti accumulati -->
      
      <ol id="score-history"></ol>
      <!-- üìã ELENCO PUNTEGGI: Elenco ordinato di tutte le selezioni di punteggio -->
      <!-- Il punteggio di ogni round verr√† aggiunto qui -->
    </div>
  </main>
  <script>
    /* üé≤ ===== JAVASCRIPT: Il Cervello del Nostro Gioco di Dadi! ===== */
    
    /* üîç ===== SELEZIONE ELEMENTI DOM: Collegamento alla Nostra Interfaccia ===== */
    
    const listOfAllDice = document.querySelectorAll(".die");
    /* üé≤ ELEMENTI DADI: Tutti e cinque i dadi sullo schermo */
    /* querySelectorAll ottiene MULTIPLI elementi che corrispondono a ".die" */
    /* Restituisce una NodeList (simile a un array) con tutti e 5 i dadi */
    
    const scoreInputs = document.querySelectorAll("#score-options input");
    /* üìã RADIO PUNTEGGI: Tutti gli input di tipo radio */
    /* #score-options input = trova tutti gli input dentro il div score-options */
    /* Selettore discendente - trova qualsiasi input a qualsiasi livello dentro quel contenitore */
    
    const scoreSpans = document.querySelectorAll("#score-options span");
    /* üìä VISUALIZZAZIONE PUNTEGGI: Gli span vuoti che mostreranno i valori dei punti */
    /* Questi saranno riempiti con testo come ", score = 25" quando le opzioni diventano disponibili */
    
    const roundElement = document.getElementById("current-round");
    /* üî¢ DISPLAY ROUND: Mostra quale round stiamo giocando (1-6) */
    /* getElementById ottiene un SINGOLO elemento con l'ID esatto */
    
    const rollsElement = document.getElementById("current-round-rolls");
    /* üé≤ DISPLAY LANCI: Mostra quanti lanci nel round corrente (0-3) */
    
    const totalScoreElement = document.getElementById("total-score");
    /* üìä PUNTEGGIO TOTALE: Mostra il punteggio accumulato finora */
    
    const scoreHistory = document.getElementById("score-history");
    /* üìã CRONOLOGIA PUNTEGGI: La lista che mostrer√† tutti i punteggi ottenuti */
    /* Inizia vuota e viene riempita man mano che il gioco procede */
    
    const rollDiceBtn = document.getElementById("roll-dice-btn");
    /* üé≤ PULSANTE LANCIO: Riferimento al pulsante "Roll the dice" */
    
    const keepScoreBtn = document.getElementById("keep-score-btn");
    /* ‚úÖ PULSANTE MANTIENI: Riferimento al pulsante "Keep score" */
    
    const rulesContainer = document.querySelector(".rules-container");
    /* üìú BOX REGOLE: La sezione espandibile delle regole */
    
    const rulesBtn = document.getElementById("rules-btn");
    /* üìú TOGGLE REGOLE: Pulsante per mostrare/nascondere le regole */
    
    /* üèÅ ===== VARIABILI STATO DEL GIOCO: Monitoraggio Avanzamento Gioco ===== */
    
    let diceValuesArr = []; 
    /* üé≤ VALORI DEI DADI: Array che memorizza i numeri correnti dei dadi */
    /* Inizia vuoto, conterr√† cinque numeri (1-6) dopo il lancio */
    
    let isModalShowing = false; 
    /* üìú VISIBILIT√Ä REGOLE: Tiene traccia se le regole sono mostrate/nascoste */
    /* false = nascoste (predefinito), true = visibili */
    
    let score = 0; 
    /* üìä PUNTEGGIO TOTALE: Punti accumulati dal giocatore */
    /* Aumenta quando il giocatore mantiene un'opzione di punteggio */
    
    let round = 1; 
    /* üî¢ ROUND CORRENTE: Quale round stiamo giocando (1-6) */
    /* Il gioco termina dopo il round 6 */
    
    let rolls = 0; 
    /* üé≤ CONTEGGIO LANCI: Numero di volte che i dadi sono stati lanciati in questo round */
    /* Limitato a 3 per round */
    
    /* üé≤ ===== FUNZIONE LANCIO DADI: Genera Valori Casuali ===== */
    
    const rollDice = () => {
      /* üé≤ LANCIATORE DADI: Crea valori casuali per tutti e cinque i dadi */
      
      diceValuesArr = [];
      /* üßπ CANCELLA ARRAY: Azzera i valori dei dadi */
      /* Assicura che non continuiamo ad aggiungere ai valori precedenti */
    
      for (let i = 0; i < 5; i++) {
        /* üîÑ CICLO 5 VOLTE: Una volta per ogni dado */
        
        const randomDice = Math.floor(Math.random() * 6) + 1;
        /* üé≤ NUMERO CASUALE: Genera 1-6 come un dado reale */
        /* Math.random() = da 0 a meno di 1 (es. 0,74382) */
        /* * 6 = da 0 a meno di 6 (es. 4,46292) */
        /* Math.floor() = arrotonda per difetto all'intero (es. 4) */
        /* + 1 = ci d√† 1-6 invece di 0-5 (es. 5) */
        
        diceValuesArr.push(randomDice);
        /* ‚ûï AGGIUNGI ALL'ARRAY: Memorizza ogni valore del dado */
        /* Dopo il completamento del ciclo, l'array avr√† 5 valori */
      };
    
      listOfAllDice.forEach((dice, index) => {
        /* üîÑ AGGIORNA DISPLAY: Imposta il numero visibile di ogni dado */
        /* forEach scorre tutti gli elementi dei dadi */
        /* index = 0,1,2,3,4 (posizione nella NodeList) */
        
        dice.textContent = diceValuesArr[index];
        /* üìù IMPOSTA NUMERO: Aggiorna il testo all'interno di ogni dado */
        /* textContent √® pi√π sicuro di innerHTML per il testo semplice */
      });
    };
    
    /* üìä ===== FUNZIONE AGGIORNAMENTO STATISTICHE: Aggiorna Display ===== */
    
    const updateStats = () => {
      /* üìä AGGIORNA DISPLAY: Aggiorna i contatori dei round e dei lanci */
      
      rollsElement.textContent = rolls;
      /* üé≤ AGGIORNA LANCI: Mostra il conteggio corrente dei lanci (0-3) */
      
      roundElement.textContent = round;
      /* üî¢ AGGIORNA ROUND: Mostra il numero del round corrente (1-6) */
    };
    
    /* üîò ===== FUNZIONE AGGIORNAMENTO OPZIONE RADIO: Abilita Opzioni di Punteggio ===== */
    
    const updateRadioOption = (index, score) => {
      /* üîò ABILITA OPZIONE: Attiva un'opzione di punteggio quando disponibile */
      /* index = quale pulsante radio aggiornare (0-5) */
      /* score = il valore del punto da assegnare (es. 25) */
      
      scoreInputs[index].disabled = false;
      /* ‚úÖ ABILITA INPUT: Rende il pulsante radio cliccabile */
      /* Cambia da grigio a aspetto normale */
      
      scoreInputs[index].value = score;
      /* üíØ IMPOSTA VALORE: Memorizza il valore del punto nell'input */
      /* Questo valore sar√† utilizzato quando si mantiene il punteggio */
      
      scoreSpans[index].textContent = `, score = ${score}`;
      /* üìù MOSTRA PUNTEGGIO: Visualizza i punti accanto all'opzione */
      /* Usa un template literal per creare ", score = 25" */
    };
    
    /* üìä ===== FUNZIONE AGGIORNAMENTO PUNTEGGIO: Registra Punteggio Selezionato ===== */
    
    const updateScore = (selectedValue, achieved) => {
      /* üìä REGISTRA PUNTEGGIO: Aggiunge i punti selezionati al totale */
      /* selectedValue = valore del punto come stringa (es. "25") */
      /* achieved = quale combinazione √® stata ottenuta (es. "full-house") */
      
      score += parseInt(selectedValue);
      /* ‚ûï AGGIUNGI AL TOTALE: Converte stringa in numero e somma */
      /* parseInt() assicura una corretta addizione (non concatenazione di stringhe) */
      
      totalScoreElement.textContent = score;
      /* üìù AGGIORNA DISPLAY: Mostra il nuovo punteggio totale */
    
      scoreHistory.innerHTML += `<li>${achieved} : ${selectedValue}</li>`;
      /* ‚ûï AGGIUNGI ELEMENTO CRONOLOGIA: Registra questo punteggio nella lista */
      /* Template literal crea un elemento lista HTML */
      /* Visualizza qualcosa come "full-house : 25" */
    };
    
    /* üîç ===== FUNZIONE RILEVAMENTO DUPLICATI: Trova Dadi Corrispondenti ===== */
    
    const getHighestDuplicates = (arr) => {
      /* üîç TROVA CORRISPONDENZE: Rileva tre o quattro dello stesso tipo */
      /* arr = array di valori dei dadi da analizzare */
      
      const counts = {};
      /* üìä OGGETTO CONTATORE: Tiene traccia delle occorrenze di ogni numero */
      /* Conterr√† voci come { 3: 2, 5: 3 } che significa "due 3, tre 5" */
    
      for (const num of arr) {
        /* üîÑ CONTA OCCORRENZE: Scorre ogni valore del dado */
        
        if (counts[num]) {
          counts[num]++; 
          /* ‚ûï INCREMENTA: Questo numero √® stato visto prima */
        } else {
          counts[num] = 1; 
          /* üÜï NUOVA VOCE: Prima volta che vedo questo numero */
        }
      }
    
      let highestCount = 0;
      /* üî¢ TRACCIA MASSIMO: Numero pi√π alto di dadi corrispondenti */
      /* Inizia a 0, sar√† aggiornato a 3, 4 o 5 se vengono trovate corrispondenze */
    
      for (const num of arr) {
        /* üîÑ TROVA MAX: Scorre i dadi di nuovo */
        
        const count = counts[num];
        /* üî¢ OTTIENI CONTEGGIO: Quante volte appare questo valore */
        
        if (count >= 3 && count > highestCount) {
          highestCount = count;
          /* ‚¨ÜÔ∏è AGGIORNA MAX: Trovato nuovo conteggio pi√π alto */
          /* Solo se almeno 3 dadi corrispondenti (minimo per punteggio) */
        }
        if (count >= 4 && count > highestCount) {
          highestCount = count;
          /* ‚¨ÜÔ∏è AGGIORNA MAX: Quattro dadi corrispondenti */
          /* Questa condizione sembra ridondante con quella sopra, ma mantiene il codice chiaro */
        }
      }
    
      const sumOfAllDice = arr.reduce((a, b) => a + b, 0);
      /* ‚ûï CALCOLA SOMMA: Totale di tutti i valori dei dadi */
      /* reduce() √® come unire tutti i dadi in una singola somma */
      /* (a, b) => a + b significa "aggiungi ogni elemento all'accumulatore" */
      /* 0 √® il valore iniziale per l'accumulatore */
    
      if (highestCount >= 4) {
        updateRadioOption(1, sumOfAllDice);
        /* ‚úÖ ABILITA POKER: Se trovati 4+ dadi corrispondenti */
        /* Usa indice 1 (seconda opzione nella lista) */
      }
    
      if (highestCount >= 3) {
        updateRadioOption(0, sumOfAllDice);
        /* ‚úÖ ABILITA TRIS: Se trovati 3+ dadi corrispondenti */
        /* Usa indice 0 (prima opzione nella lista) */
        /* Nota: Se ne vengono trovati 4+, entrambe le opzioni sono abilitate */
      }
    };
    
    /* üè† ===== FUNZIONE RILEVAMENTO FULL HOUSE: Trova Pattern 3 + 2 ===== */
    
    const detectFullHouse = (arr) => {
      /* üè† TROVA FULL HOUSE: Rileva tris pi√π una coppia */
      /* arr = array di valori dei dadi da analizzare */
      
      const counts = {};
      /* üìä OGGETTO CONTATORE: Stessa tecnica di conteggio di prima */
    
      for (const num of arr) {
        /* üîÑ CONTA OCCORRENZE: Usando operatore ternario */
        
        counts[num] = counts[num] ? counts[num] + 1 : 1;
        /* ‚ûï CONTA: Se esiste, incrementa; altrimenti inizializza a 1 */
        /* Versione compatta dell'if/else della funzione precedente */
      }
    
      const hasThreeOfAKind = Object.values(counts).includes(3);
      /* üîç CONTROLLA TRIS: C'√® un numero che appare esattamente 3 volte? */
      /* Object.values(counts) prende solo i conteggi: [2,3] */
      /* .includes(3) verifica se esattamente 3 appare in quell'array */
      
      const hasPair = Object.values(counts).includes(2);
      /* üîç CONTROLLA COPPIA: C'√® un numero che appare esattamente 2 volte? */
    
      if (hasThreeOfAKind && hasPair) {
        updateRadioOption(2, 25); 
        /* ‚úÖ ABILITA FULL HOUSE: Se entrambe le condizioni sono vere */
        /* Usa indice 2 (terza opzione) con punteggio fisso di 25 */
      }
    };
    
    /* üìà ===== FUNZIONE RILEVAMENTO SCALE: Trova Dadi Sequenziali ===== */
    
    const checkForStraights = (arr) => {
      /* üìà TROVA SCALE: Rileva valori di dadi consecutivi */
      /* arr = array di valori dei dadi da analizzare */
      
      const sortedNumbersArr = arr.sort((a, b) => a - b);
      /* üìä ORDINA NUMERI: Dispone i dadi in ordine crescente */
      /* (a, b) => a - b √® una funzione di confronto per ordinamento numerico */
      /* Trasforma [3,1,5,4,2] in [1,2,3,4,5] */
      
      const uniqueNumbersArr = [...new Set(sortedNumbersArr)];
      /* üîÑ RIMUOVI DUPLICATI: Mantieni solo valori unici */
      /* new Set() crea una collezione senza duplicati */
      /* [...Set] la espande di nuovo in un array */
      /* Trasforma [1,2,2,3,4] in [1,2,3,4] */
      
      const uniqueNumbersStr = uniqueNumbersArr.join("");
      /* üîó CREA STRINGA: Unisce i numeri senza separatori */
      /* Rende il confronto di pattern molto pi√π facile */
      /* Trasforma [1,2,3,4] in "1234" */
    
      const smallStraightsArr = ["1234", "2345", "3456"]; 
      /* üìã PATTERN SCALA PICCOLA: Quattro numeri consecutivi */
      
      const largeStraightsArr = ["12345", "23456"];      
      /* üìã PATTERN SCALA GRANDE: Cinque numeri consecutivi */
    
      if (smallStraightsArr.some(straight => uniqueNumbersStr.includes(straight))) {
        updateRadioOption(3, 30); 
        /* ‚úÖ ABILITA SCALA PICCOLA: Se pattern trovato */
        /* .some() verifica se QUALSIASI pattern corrisponde */
        /* .includes() verifica se la stringa contiene il pattern */
        /* Usa indice 3 (quarta opzione) con punteggio fisso di 30 */
      }
    
      if (largeStraightsArr.includes(uniqueNumbersStr)) {
        updateRadioOption(4, 40); 
        /* ‚úÖ ABILITA SCALA GRANDE: Se pattern esatto trovato */
        /* Qui abbiamo bisogno di una corrispondenza ESATTA, non solo contenere il pattern */
        /* Usa indice 4 (quinta opzione) con punteggio fisso di 40 */
      }
    };
    
    /* üßπ ===== FUNZIONE RESET OPZIONI RADIO: Cancella Selezioni ===== */
    
    const resetRadioOptions = () => {
      /* üßπ RESET OPZIONI: Cancella e disabilita tutte le opzioni di punteggio */
      
      scoreInputs.forEach((input) => {
        /* üîÑ ELABORA OGNI INPUT: Scorre tutti i pulsanti radio */
        
        input.disabled = true;
        /* üîí DISABILITA: Rende l'opzione non cliccabile */
        /* Rende l'opzione grigia finch√© non diventa disponibile */
        
        input.checked = false;
        /* üîò DESELEZIONA: Rimuove qualsiasi selezione precedente */
      });
    
      scoreSpans.forEach((span) => {
        /* üîÑ ELABORA OGNI SPAN: Scorre tutti i display di punteggio */
        
        span.textContent = "";
        /* üßπ CANCELLA TESTO: Rimuove i punteggi precedenti */
        /* Rimuove il testo ", score = 25" dal lancio precedente */
      });
    };
    
    /* üîÑ ===== FUNZIONE RESET GIOCO: Ricomincia da Capo ===== */
    
    const resetGame = () => {
      /* üîÑ RESET GIOCO: Riporta tutto allo stato iniziale */
      /* Chiamato dopo il completamento del gioco (dopo 6 round) */
      
      diceValuesArr = [0, 0, 0, 0, 0];
      /* üßπ RESET DADI: Torna a tutti zeri */
      /* Questi verranno visualizzati fino al primo lancio */
      
      score = 0;
      /* üßπ RESET PUNTEGGIO: Torna a zero punti */
      
      round = 1;
      /* üßπ RESET ROUND: Torna al primo round */
      
      rolls = 0;
      /* üßπ RESET LANCI: Torna a zero lanci */
    
      listOfAllDice.forEach((dice, index) => {
        dice.textContent = diceValuesArr[index];
        /* üßπ RESET VISUALIZZAZIONE DADI: Mostra zeri sullo schermo */
      });
    
      totalScoreElement.textContent = score;
      /* üßπ RESET VISUALIZZAZIONE PUNTEGGIO: Mostra zero punti */
      
      scoreHistory.innerHTML = "";
      /* üßπ CANCELLA CRONOLOGIA: Rimuove tutti i punteggi precedenti */
      /* innerHTML = "" sostituisce tutto il contenuto con niente */
    
      rollsElement.textContent = rolls;
      roundElement.textContent = round;
      /* üßπ RESET CONTATORI: Aggiorna i display ai valori iniziali */
    
      resetRadioOptions();
      /* üßπ RESET OPZIONI: Riutilizza la funzione esistente */
      /* Segue il principio DRY (Don't Repeat Yourself) */
    };
    
    /* üé≤ ===== EVENTO PULSANTE LANCIO DADI: Azione Principale del Gioco ===== */
    
    rollDiceBtn.addEventListener("click", () => {
      /* üé≤ CLICK PULSANTE LANCIO: Gestisce l'azione di lancio dei dadi */
      
      if (rolls === 3) {
        /* üõë CONTROLLA LIMITE: Il giocatore ha gi√† lanciato 3 volte? */
        
        alert("You have made three rolls this round. Please select a score.");
        /* ‚ö†Ô∏è AVVISA UTENTE: Mostra messaggio di errore */
        /* Impedisce di superare il limite di lanci per round */
      } else {
        /* ‚úÖ PROCEDI: Il lancio √® consentito */
        
        rolls++; 
        /* ‚¨ÜÔ∏è INCREMENTA LANCI: Conta questo lancio */
        
        resetRadioOptions(); 
        /* üßπ RESET OPZIONI: Cancella le opzioni precedenti */
        
        rollDice(); 
        /* üé≤ LANCIA DADI: Genera nuovi numeri casuali */
        
        updateStats(); 
        /* üìä AGGIORNA DISPLAY: Mostra nuovo conteggio lanci */
        
        getHighestDuplicates(diceValuesArr);
        detectFullHouse(diceValuesArr);
        checkForStraights(diceValuesArr);
        /* üîç RILEVA COMBINAZIONI: Controlla tutte le possibili opzioni di punteggio */
        
        updateRadioOption(5, 0);
        /* ‚úÖ ABILITA OPZIONE "NESSUNA": Permette sempre di saltare */
        /* Indice 5 = "None of the above" con 0 punti */
        /* Questa opzione √® sempre disponibile dopo il lancio */
      }
    });
    
    /* üìú ===== EVENTO PULSANTE REGOLE: Mostra/Nascondi Regole ===== */
    
    rulesBtn.addEventListener("click", () => {
      /* üìú CLICK PULSANTE REGOLE: Mostra o nascondi le regole */
      
      isModalShowing = !isModalShowing;
      /* üîÑ CAMBIA STATO: Alterna tra true/false */
      /* ! (NOT logico) inverte il valore booleano */
    
      if (isModalShowing) {
        /* ‚úÖ REGOLE VISIBILI: Aggiorna UI per regole visibili */
        
        rulesBtn.textContent = "Hide rules";
        /* üìù AGGIORNA PULSANTE: Cambia testo per riflettere l'azione */
        
        rulesContainer.style.display = "block";
        /* üìù MOSTRA REGOLE: Rende visibile il contenitore delle regole */
      } else {
        /* ‚ùå REGOLE NASCOSTE: Aggiorna UI per regole nascoste */
        
        rulesBtn.textContent = "Show rules";
        /* üìù AGGIORNA PULSANTE: Cambia testo per riflettere l'azione */
        
        rulesContainer.style.display = "none";
        /* üìù NASCONDI REGOLE: Rende invisibile il contenitore delle regole */
      }
    });
    
    /* üíæ ===== EVENTO PULSANTE MANTIENI PUNTEGGIO: Salva Punteggio Selezionato ===== */
    
    keepScoreBtn.addEventListener("click", () => {
      /* üíæ CLICK MANTIENI PUNTEGGIO: Registra i punti selezionati e avanza */
      
      let selectedValue; 
      /* üî¢ PUNTEGGIO SELEZIONATO: Memorizzer√† il valore del punteggio scelto */
      
      let achieved;     
      /* üìã COMBINAZIONE OTTENUTA: Memorizzer√† il tipo di punteggio */
    
      for (const radioButton of scoreInputs) {
        /* üîÑ CONTROLLA SELEZIONI: Scorre tutti i pulsanti radio */
        
        if (radioButton.checked) {
          /* ‚úÖ TROVATA SELEZIONE: Questo radio √® selezionato */
          
          selectedValue = radioButton.value; 
          /* üíæ MEMORIZZA VALORE: Ottiene il valore dei punti */
          
          achieved = radioButton.id;         
          /* üíæ MEMORIZZA TIPO: Ottiene il nome della combinazione */
          
          break; 
          /* üõë INTERROMPI RICERCA: Abbiamo trovato la selezione */
          /* break esce dal ciclo prima per efficienza */
        }
      }
    
      if (selectedValue) {
        /* ‚úÖ SELEZIONE VALIDA: L'utente ha scelto un'opzione */
        
        rolls = 0;  
        /* üßπ RESET LANCI: Ricomincia da capo per il nuovo round */
        
        round++;   
        /* ‚¨ÜÔ∏è PROSSIMO ROUND: Incrementa il contatore dei round */
        
        updateStats(); 
        /* üìä AGGIORNA DISPLAY: Mostra il nuovo round */
        
        resetRadioOptions(); 
        /* üßπ RESET OPZIONI: Pulisci per il prossimo round */
        
        updateScore(selectedValue, achieved); 
        /* üìä REGISTRA PUNTEGGIO: Aggiungi al totale e alla cronologia */
        
        if (round > 6) {
          /* üèÅ CONTROLLO FINE GIOCO: Sono stati giocati tutti e 6 i round? */
          
          setTimeout(() => {
            /* ‚è±Ô∏è LEGGERO RITARDO: Attendi 500ms prima di mostrare l'avviso */
            /* Questo assicura che gli aggiornamenti dell'interfaccia siano visibili prima */
            
            alert(`Game Over! Your total score is ${score}`);
            /* üèÜ PUNTEGGIO FINALE: Mostra messaggio di fine gioco */
            
            resetGame();
            /* üîÑ RICOMINCIA: Reimposta tutto per un nuovo gioco */
          }, 500);
        }
      } else {
        /* ‚ùå NESSUNA SELEZIONE: L'utente non ha scelto un'opzione */
        
        alert("Please select an option or roll the dice");
        /* ‚ö†Ô∏è AVVISA UTENTE: Mostra messaggio di errore */
        /* Ricorda al giocatore che deve selezionare un'opzione o lanciare */
      }
    });
  </script>
</body>

</html>

<!-- üéØ ===== RIASSUNTO ARCHITETTURA DEL GIOCO DI DADI ===== -->
<!-- 
üé≤ STRUTTURA DEL GIOCO:
‚îÇ
‚îú‚îÄ‚îÄ üß† HEAD (configurazione)
‚îÇ   ‚îî‚îÄ‚îÄ üé® CSS con tema da gioco:
‚îÇ       ‚îú‚îÄ‚îÄ üéÆ Sfondo scuro con accenti dorati
‚îÇ       ‚îú‚îÄ‚îÄ üì¶ Layout a griglia e flex per le aree di gioco
‚îÇ       ‚îú‚îÄ‚îÄ üé≤ Stile visivo per elementi dei dadi
‚îÇ       ‚îî‚îÄ‚îÄ üì± Design responsive per tutti i dispositivi
‚îÇ
‚îú‚îÄ‚îÄ üìÑ BODY (interfaccia)
‚îÇ   ‚îú‚îÄ‚îÄ üìú Intestazione con sezione regole
‚îÇ   ‚îî‚îÄ‚îÄ üéÆ Area principale di gioco
‚îÇ       ‚îú‚îÄ‚îÄ üé≤ Cinque elementi dadi
‚îÇ       ‚îú‚îÄ‚îÄ üìä Contatori di round e lanci
‚îÇ       ‚îú‚îÄ‚îÄ üîò Opzioni di punteggio (pulsanti radio)
‚îÇ       ‚îú‚îÄ‚îÄ üîò Pulsanti di controllo del gioco
‚îÇ       ‚îî‚îÄ‚îÄ üìã Sezione cronologia punteggi
‚îÇ
‚îî‚îÄ‚îÄ üßÆ JAVASCRIPT (logica di gioco)
    ‚îú‚îÄ‚îÄ üé≤ Meccaniche di lancio dei dadi
    ‚îú‚îÄ‚îÄ üîç Algoritmi di rilevamento pattern
    ‚îÇ   ‚îú‚îÄ‚îÄ Tris/poker
    ‚îÇ   ‚îú‚îÄ‚îÄ Rilevamento full house
    ‚îÇ   ‚îî‚îÄ‚îÄ Sequenze di scale
    ‚îú‚îÄ‚îÄ üìä Sistema di punteggio
    ‚îú‚îÄ‚îÄ üéÆ Gestione stato del gioco
    ‚îî‚îÄ‚îÄ üîÑ Logica di progressione dei round

üéÆ MECCANICHE DI GIOCO:
‚îú‚îÄ‚îÄ 6 round totali con 3 lanci per round
‚îú‚îÄ‚îÄ 5 opzioni di punteggio con diversi valori di punti
‚îú‚îÄ‚îÄ Decisioni strategiche tra rilancio e mantenimento del punteggio
‚îî‚îÄ‚îÄ Monitoraggio dello stato del gioco tramite aggiornamenti DOM

üß† CONCETTI DI PROGRAMMAZIONE:
‚îú‚îÄ‚îÄ üì¶ Manipolazione array (sort, filter, reduce)
‚îú‚îÄ‚îÄ üîç Rilevamento pattern con confronto stringhe
‚îú‚îÄ‚îÄ üé≤ Randomizzazione con Math.random()
‚îú‚îÄ‚îÄ üîÑ Architettura basata su eventi
‚îî‚îÄ‚îÄ üìä Monitoraggio dati orientato agli oggetti

Un perfetto esempio di combinazione di HTML, CSS e JavaScript per creare un gioco di dadi interattivo! üé≤‚ú®
-->
```
</TabItem>

</Tabs>

### Il Progetto Pi√π Difficile

√à stato il progetto pi√π difficile in assoluto. Erano pochi step ma molto complessi. Ora capisco perch√© sia il corso di freeCodeCamp con il pi√π alto tasso di abbandono.<br />
Non mi √® piaciuto in s√© per una questione di argomento: non era un gioco che conoscevo e non mi ha emozionato giocarci prima di iniziare il progetto per capire la logica, e nemmeno dopo averla implementata. Fatto sta che ho imparato tanto. In progetti come questo, che lasciano "carta bianca", proprio come nei certification project, la difficolt√† principale sta nel mettere insieme i pezzi e quindi nel riassumere tutto ci√≤ che si √® imparato prima.<br />
Mi √® mancato il non avere un unico vademecum completo ma sono ugualmente riuscito a reperire le informazioni dato che √® come se ne avessi due, aspettavo di finire il corso per unirli ma √® possibile che lo faccia prima, perch√© √® un passaggio che mi ha sempre aiutato a riordinare i concetti nella mente.

### La Riflessione: Strategia di Apprendimento

Sono indeciso tra fare il corso 6 di Google UX o iniziare subito il certification project, ma leggendo quanto ho scritto, la cosa pi√π logica che emerge √®: unire il vademecum, fare il corso Google UX per staccare dalla full immersion con freeCodeCamp, poi iniziare il 4¬∞ certification project con massima carica.<br />
Riflettendoci, sarebbe intelligente anche per capire se il vademecum necessita di modifiche, dopotutto, la maggior parte di queste le ho fatte proprio mentre lo usavo per i certification project, dove diventava essenziale. Quando ho dubbi, consultare il vademecum √® il mio primo step, il secondo MDN Web Docs, anche se ultimamente meno, il terzo, come ultima spiaggia, √® il code tutor.<br />
L'AI per approfondire i concetti √® eccezionale, sebbene tu stia un po' giocando a testa o croce nella speranza che sia giusto ci√≤ che dice. √à ottima anche per suggerire alternative, ma √® uno strumento che impigrisce parecchio. Una bici con le rotelle che se non impari a togliere te le tieni a vita.<br />
Per mitigare il rischio allucinazione, da quasi 2 mesi ho sostituito Claude con Perplexity, impostando sempre Claude o Gemini come modello, entrambi con chain of thought attiva, spazio tra un modello all'altro in base al temperamento desiderato. Cos√¨ mi assicuro le prestazioni dei migliori modelli accompagnate da fonti verificabili. A volte lo faccio attivamente, anche se dovrei farlo pi√π spesso, e scopro siti veramente interessanti.

### I Tre Concetti Critici

Mi sono appuntato alcuni concetti basati su confronti tra l'approccio di freeCodeCamp e alternative migliori. Niente era sbagliato, d'altronde chi sono io per dirlo? Ma approfondire le alternative mi ha portato a ragionare con pensiero critico.

#### 1. style.display vs classList.toggle() - Il SRP

FreeCodeCamp ha proposto:

```javascript
if (isModalShowing) {
  rulesBtn.textContent = "Hide rules";
  rulesContainer.style.display = "block";
} else {
  rulesBtn.textContent = "Show rules";
  rulesContainer.style.display = "none";
}
```

Questa soluzione modifica direttamente gli stili inline dell'elemento HTML. Seguendo il Single Responsibility Principle ha molto pi√π senso separare il CSS dal JavaScript:

```css
.rules-container {
  display: none;
}

.rules-container.show {
  display: block;
}
```

E nel JavaScript:

```javascript
rulesContainer.classList.toggle("show");
rulesBtn.textContent = isModalShowing ? "Hide rules" : "Show rules";
```

Cos√¨ facendo non abbiamo pezzi di CSS nel JavaScript, bens√¨ due documenti ben distinti: il JavaScript si occupa solo di richiamare lo stile nel CSS, non di crearlo.

#### 2. parseInt() vs Number() - Rigore Semantico

L'approccio di freeCodeCamp √® stato `score += parseInt(selectedValue);`

Io avevo inserito `score += Number(selectedValue);`

Sono corrette entrambe, ma **Number() sembra essere pi√π rigoroso**. Ecco perch√©:

| Aspetto | parseInt() | Number() |
|---------|-----------|----------|
| "15" | 15 ‚úÖ | 15 ‚úÖ |
| "15.7" | 15 (tronca i decimali) | 15.7 (mantiene decimali) |
| "15px" | 15 (ignora resto) | NaN (errore) |
| "" | NaN | 0 |

Number() √® pi√π rigoroso perch√© fallisce quando incontra input invalidi, mentre parseInt() fa conversioni "ottimiste". A seconda del contesto, la rigorosit√† di Number() pu√≤ essere preferibile per catturare errori di input.

#### 3. innerHTML += vs createElement() - Performance e DOM Integrity

Questo punto √® emerso dal code tutor che ha giustamente fatto notare che:

```javascript
scoreHistory.innerHTML += `<li>${achieved} : ${selectedValue}</li>`;
```

√à breve e leggibile, ma la soluzione migliore, seppur pi√π prolissa, √®:

```javascript
const historyItem = document.createElement("li");
historyItem.textContent = `${achieved} : ${selectedValue}`;
scoreHistory.appendChild(historyItem);
```

Il perch√© √® veramente interessante: con `innerHTML +=`, avendo gi√† presenti gli elementi:

```html
<li>Three of a kind : 15</li>
<li>Four of a kind : 20</li>
<li>Full house : 25</li>
```

Aggiungendo il 4¬∞ elemento con `innerHTML +=`, il browser distrugge i primi 3 e ricrea tutti e 4 da zero! Con `appendChild()` viene semplicemente aggiunto un nuovo elemento, lasciando intatti gli altri.<br />
Questo accade perch√© in scoreHistory, trovandosi gli altri 3 elementi, il browser andr√† a leggere tutto l'HTML esistente (riferito solo a scoreHistory in questo caso), convertire in stringa, aggiungere quella nuova e distruggere quindi gli altri elementi del DOM, rischiando che cambi gli stati da com'erano prima.<br />
`innerHTML` rimane ottimo quando si vuole creare da zero il contenuto di un elemento (con assegnazione, non con aggiunta), ma per append iterativi `createElement()` + `appendChild()` √® decisamente superiore.<br />

### Cosa Ho Imparato

**Algoritmi di Pattern Matching:**
- Rilevamento Three/Four of a Kind contando occorrenze di numeri
- Rilevamento Full House verificando la presenza di gruppi di 3 e 2
- Rilevamento Straight convertendo array in stringhe per pattern matching
- Uso di `Set` per rimuovere duplicati: `[...new Set(arr)]`

**Array Methods e Iterazione:**
- `.forEach()` per iterare e modificare elementi DOM
- `.reduce()` per accumulare valori (somma dei dadi)
- `.sort()` con callback numerica per ordinare array
- `.includes()` per cercare patterns in stringhe
- `.some()` per verificare se almeno uno elemento soddisfa una condizione

**Manipolazione Oggetti:**
- Conteggio occorrenze di elementi creando oggetti `{ numero: count }`
- `Object.values()` per estrarre solo i valori da un oggetto
- Operatore ternario inline: `counts[num] = counts[num] ? counts[num] + 1 : 1`

**Event Handling e Validazione:**
- Guard clauses per controllare precondizioni prima di eseguire codice
- Validazione input prima di processare selezioni utente
- `addEventListener()` per gestire interazioni
- `setTimeout()` per ritardare esecuzione (permette UI update prima di alert)

**Pattern di Codice Professionali:**
- DRY (Don't Repeat Yourself): refactoring della chiamata `updateRadioOption(5, 0)` in un'unica posizione
- Separazione delle responsabilit√†: funzioni specifiche per ogni tipo di rilevamento
- Early exit: uso di `break` per uscire da loop quando trovato ci√≤ che cerchi
- Nomi semantici che spiegano il "cosa" non il "come"

**Differenze Critiche tra Metodi:**
- `textContent` vs `innerHTML`: textContent √® pi√π sicuro, innerHTML ricrea DOM
- Assegnazione vs concatenazione: `=` vs `+=` hanno implicazioni di performance diverse
- `style.display` vs `classList.toggle()`: separazione CSS/JS vs inline styles

***

**Prossimo Progetto**: Costruire un Cash Register (CERTIFICATION PROJECT!)
