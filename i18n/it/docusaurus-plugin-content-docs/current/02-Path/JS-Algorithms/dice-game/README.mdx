---
sidebar_position: 18
sidebar_label: 'Dice Game'
title: 'Dice Game'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Dice Game

<img
  src={require('./assets/dice-game-1.webp').default}
  alt="Interfaccia principale del gioco dei dadi che mostra le regole di gioco e 5 dadi"
  width="2702"
  height="1658"
  loading="lazy"
  decoding="async"
  style={{
    width: '100%',
    height: 'auto',
    borderRadius: '10px'
  }}
/>

<img
  src={require('./assets/dice-game-2.webp').default}
  alt="Interfaccia di gioco che mostra una scala minore con un punteggio di 30 punti"
  width="2702"
  height="1002"
  loading="lazy"
  decoding="async"
  style={{
    width: '100%',
    height: 'auto',
    borderRadius: '10px'
  }}
/>

<img
  src={require('./assets/dice-game-3.webp').default}
  alt="Pannello della cronologia dei punteggi che mostra un punteggio totale di 30, ottenuto da una scala minore del valore di 30 punti"
  width="2702"
  height="1002"
  loading="lazy"
  decoding="async"
  style={{
    width: '100%',
    height: 'auto',
    borderRadius: '10px'
  }}
/>

<img
  src={require('./assets/dice-game-4.webp').default}
  alt="Schermata di fine partita che mostra il punteggio finale"
  width="2702"
  height="1226"
  loading="lazy"
  decoding="async"
  style={{
    width: '100%',
    height: 'auto',
    borderRadius: '10px'
  }}
/>

### Il Progetto
Dice Game sviluppato con JavaScript puro, focalizzato su logica algoritmica, gestione dello stato e manipolazione del DOM. Un progetto che richiede di mettere insieme molteplici concetti precedentemente appresi in un contesto con poca guida strutturata.

### Codice Sorgente

<Tabs>
<TabItem value="html" label="index.html" default>

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Advanced Dice Game</title>
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <header>
    <h1>Advanced Dice Game</h1>
    <button class="btn" id="rules-btn" type="button">Show rules</button>
    <div class="rules-container">
      <h2>Rules</h2>
      <ul>
        <li>There are total of six rounds</li>
        <li>You can only roll the dice three times per round</li>
        <li>To start the game, roll the dice</li>
        <li>
          Then, choose from one of the selected scores or roll the dice again
        </li>
        <li>
          If you choose a selected score, then you will move to the next round
        </li>
        <li>
          If you decline to choose a selected score, then you can roll the
          dice again two more times
        </li>
      </ul>
      <h2 class="points">Points</h2>
      <ul>
        <li>Three of a kind: Sum of all five dice</li>
        <li>Four of a kind: Sum of all five dice</li>
        <li>Full house: Three of a kind and a pair - 25 points</li>
        <li>
          Small straight: Four of the dice have consecutive values - 30 points
        </li>
        <li>
          Large straight: All five dice have consecutive values - 40 points
        </li>
      </ul>
    </div>
  </header>

  <main>
    <form id="game">
      <div id="dice">
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
      </div>

      <p class="rounds-text">
        <strong>Rolls:</strong> <span id="current-round-rolls">0</span> |
        <strong>Round:</strong> <span id="current-round">1</span>
      </p>

      <div id="score-options">
        <div>
          <input type="radio" name="score-options" id="three-of-a-kind" value="three-of-a-kind" disabled />
          <label for="three-of-a-kind">Three of a kind<span></span></label>
        </div>
        <div>
          <input type="radio" name="score-options" id="four-of-a-kind" value="four-of-a-kind" disabled />
          <label for="four-of-a-kind">Four of a kind<span></span></label>
        </div>
        <div>
          <input type="radio" name="score-options" id="full-house" value="full-house" disabled />
          <label for="full-house">Full house<span></span></label>
        </div>
        <div>
          <input type="radio" name="score-options" id="small-straight" value="small-straight" disabled />
          <label for="small-straight">Small straight<span></span></label>
        </div>
        <div>
          <input type="radio" name="score-options" id="large-straight" value="large-straight" disabled />
          <label for="large-straight">Large straight<span></span></label>
        </div>

        <div>
          <input type="radio" name="score-options" id="none" value="none" disabled />
          <label for="none">None of the above<span></span></label>
        </div>
      </div>

      <button class="btn" id="keep-score-btn" type="button">
        Keep the above selected score
      </button>
      <button class="btn" id="roll-dice-btn" type="button">
        Roll the dice
      </button>
    </form>

    <div id="scores">
      <h3>Score history (Total score: <span id="total-score">0</span>)</h3>
      <ol id="score-history"></ol>
    </div>
  </main>
  <script src="./script.js"></script>
</body>

</html>
```
</TabItem>

<TabItem value="css" label="styles.css">

```css
*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  --dark-grey: #1b1b32;
  --light-grey: #f5f6f7;
  --black: #000;
  --white: #fff;
  --grey: #3b3b4f;
  --golden-yellow: #fecc4c;
  --yellow: #ffcc4c;
  --gold: #feac32;
  --orange: #ffac33;
  --dark-orange: #f89808;
}

body {
  background-color: var(--dark-grey);
}

header {
  color: var(--light-grey);
  text-align: center;
}

h1 {
  font-size: 2.5rem;
  margin: 25px 0;
}

.rules-container {
  display: none;
  background-color: var(--light-grey);
  color: var(--black);
  width: 50%;
  margin: 20px auto;
  height: 300px;
  border-radius: 10px;
  overflow-y: scroll;
}

.rules-container ul {
  list-style-type: none;
}

.points {
  margin-top: 15px;
}

main {
  background-color: var(--light-grey);
  padding: 20px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
  gap: 1rem;
  margin: auto;
  justify-items: center;
  width: 50%;
  border-radius: 10px;
}

#dice {
  display: flex;
  justify-content: space-around;
  margin-bottom: 15px;
}

.die {
  width: 40px;
  height: 40px;
  text-align: center;
  margin-right: 15px;
  border: 4px solid var(--black);
  padding: 10px;
}

.rounds-text {
  text-align: center;
}

input[type="radio"]:disabled + label {
  color: var(--grey);
}

#score-history {
  margin-top: 15px;
  text-align: center;
  list-style-position: inside;
}

.btn {
  cursor: pointer;
  width: 200px;
  margin: 10px 0 10px 0.5rem;
  color: var(--black);
  background-color: var(--gold);
  background-image: linear-gradient(var(--golden-yellow), var(--orange));
  border-color: var(--gold);
  border-width: 3px;
}

.btn:hover:enabled {
  background-image: linear-gradient(var(--yellow), var(--dark-orange));
}

@media (max-width: 992px) {
  main {
    width: 100%;
  }
}

@media (max-width: 500px) {
  .btn {
    width: 120px;
  }
}
```
</TabItem>

<TabItem value="js" label="script.js">

```js
const listOfAllDice = document.querySelectorAll(".die");
const scoreInputs = document.querySelectorAll("#score-options input");
const scoreSpans = document.querySelectorAll("#score-options span");
const roundElement = document.getElementById("current-round");
const rollsElement = document.getElementById("current-round-rolls");
const totalScoreElement = document.getElementById("total-score");
const scoreHistory = document.getElementById("score-history");
const rollDiceBtn = document.getElementById("roll-dice-btn");
const keepScoreBtn = document.getElementById("keep-score-btn");
const rulesContainer = document.querySelector(".rules-container");
const rulesBtn = document.getElementById("rules-btn");

let diceValuesArr = [];
let isModalShowing = false;
let score = 0;
let round = 1;
let rolls = 0;

const rollDice = () => {
  diceValuesArr = [];

  for (let i = 0; i < 5; i++) {
    const randomDice = Math.floor(Math.random() * 6) + 1;
    diceValuesArr.push(randomDice);
  };

  listOfAllDice.forEach((dice, index) => {
    dice.textContent = diceValuesArr[index];
  });
};

const updateStats = () => {
  rollsElement.textContent = rolls;
  roundElement.textContent = round;
};

const updateRadioOption = (index, score) => {
  scoreInputs[index].disabled = false;
  scoreInputs[index].value = score;
  scoreSpans[index].textContent = `, score = ${score}`;
};

const updateScore = (selectedValue, achieved) => {
  score += parseInt(selectedValue);
  totalScoreElement.textContent = score;

  scoreHistory.innerHTML += `<li>${achieved} : ${selectedValue}</li>`;
};


const getHighestDuplicates = (arr) => {
  const counts = {};

  for (const num of arr) {
    if (counts[num]) {
      counts[num]++;
    } else {
      counts[num] = 1;
    }
  }

  let highestCount = 0;

  for (const num of arr) {
    const count = counts[num];
    if (count >= 3 && count > highestCount) {
      highestCount = count;
    }
    if (count >= 4 && count > highestCount) {
      highestCount = count;
    }
  }

  const sumOfAllDice = arr.reduce((a, b) => a + b, 0);

  if (highestCount >= 4) {
    updateRadioOption(1, sumOfAllDice);
  }

  if (highestCount >= 3) {
    updateRadioOption(0, sumOfAllDice);
  }

};

const detectFullHouse = (arr) => {
  const counts = {};

  for (const num of arr) {
    counts[num] = counts[num] ? counts[num] + 1 : 1;
  }

  const hasThreeOfAKind = Object.values(counts).includes(3);
  const hasPair = Object.values(counts).includes(2);

  if (hasThreeOfAKind && hasPair) {
    updateRadioOption(2, 25);
  }

};

const checkForStraights = (arr) => {
  const sortedNumbersArr = arr.sort((a, b) => a - b);
  const uniqueNumbersArr = [...new Set(sortedNumbersArr)];
  const uniqueNumbersStr = uniqueNumbersArr.join("");

  const smallStraightsArr = ["1234", "2345", "3456"];
  const largeStraightsArr = ["12345", "23456"];

  if (smallStraightsArr.some(straight => uniqueNumbersStr.includes(straight))) {
    updateRadioOption(3, 30);
  }

  if (largeStraightsArr.includes(uniqueNumbersStr)) {
    updateRadioOption(4, 40);
  }

};

const resetRadioOptions = () => {
  scoreInputs.forEach((input) => {
    input.disabled = true;
    input.checked = false;
  });

  scoreSpans.forEach((span) => {
    span.textContent = "";
  });
};

const resetGame = () => {
  diceValuesArr = [0, 0, 0, 0, 0];
  score = 0;
  round = 1;
  rolls = 0;

  listOfAllDice.forEach((dice, index) => {
    dice.textContent = diceValuesArr[index];
  });

  totalScoreElement.textContent = score;
  scoreHistory.innerHTML = "";

  rollsElement.textContent = rolls;
  roundElement.textContent = round;

  resetRadioOptions();
};

rollDiceBtn.addEventListener("click", () => {
  if (rolls === 3) {
    alert("You have made three rolls this round. Please select a score.");
  } else {
    rolls++;
    resetRadioOptions();
    rollDice();
    updateStats();
    getHighestDuplicates(diceValuesArr);
    detectFullHouse(diceValuesArr);
    checkForStraights(diceValuesArr);
    updateRadioOption(5, 0);
  }
});

rulesBtn.addEventListener("click", () => {
  isModalShowing = !isModalShowing;

  if (isModalShowing) {
    rulesBtn.textContent = "Hide rules";
    rulesContainer.style.display = "block";
  } else {
    rulesBtn.textContent = "Show rules";
    rulesContainer.style.display = "none";
  }
});

keepScoreBtn.addEventListener("click", () => {
  let selectedValue;
  let achieved;

  for (const radioButton of scoreInputs) {
    if (radioButton.checked) {
      selectedValue = radioButton.value;
      achieved = radioButton.id;
      break;
    }
  }

  if (selectedValue) {
    rolls = 0;
    round++;
    updateStats();
    resetRadioOptions();
    updateScore(selectedValue, achieved);
    if (round > 6) {
      setTimeout(() => {
        alert(`Game Over! Your total score is ${score}`);
        resetGame();
      }, 500);
    }
  } else {
    alert("Please select an option or roll the dice");
  }
});
```

</TabItem> 

</Tabs>

### Il Progetto Più Difficile

È stato il progetto più difficile in assoluto. Erano pochi step ma molto complessi. Ora capisco perché sia il corso di freeCodeCamp con il più alto tasso di abbandono.<br />
Non mi è piaciuto in sé per una questione di argomento: non era un gioco che conoscevo e non mi ha emozionato giocarci prima di iniziare il progetto per capire la logica, e nemmeno dopo averla implementata. Fatto sta che ho imparato tanto. In progetti come questo, che lasciano "carta bianca", proprio come nei certification project, la difficoltà principale sta nel mettere insieme i pezzi e quindi nel riassumere tutto ciò che si è imparato prima.<br />
Mi è mancato il non avere un unico vademecum completo ma sono ugualmente riuscito a reperire le informazioni dato che è come se ne avessi due, aspettavo di finire il corso per unirli ma è possibile che lo faccia prima, perché è un passaggio che mi ha sempre aiutato a riordinare i concetti nella mente.

### La Riflessione: Strategia di Apprendimento

Sono indeciso tra fare il corso 6 di Google UX o iniziare subito il certification project, ma leggendo quanto ho scritto, la cosa più logica che emerge è: unire il vademecum, fare il corso Google UX per staccare dalla full immersion con freeCodeCamp, poi iniziare il 4° certification project con massima carica.<br />
Riflettendoci, sarebbe intelligente anche per capire se il vademecum necessita di modifiche, dopotutto, la maggior parte di queste le ho fatte proprio mentre lo usavo per i certification project, dove diventava essenziale. Quando ho dubbi, consultare il vademecum è il mio primo step, il secondo MDN Web Docs, anche se ultimamente meno, il terzo, come ultima spiaggia, è il code tutor.<br />
L'AI per approfondire i concetti è eccezionale, sebbene tu stia un po' giocando a testa o croce nella speranza che sia giusto ciò che dice. È ottima anche per suggerire alternative, ma è uno strumento che impigrisce parecchio. Una bici con le rotelle che se non impari a togliere te le tieni a vita.<br />
Per mitigare il rischio allucinazione, da quasi 2 mesi ho sostituito Claude con Perplexity, impostando sempre Claude o Gemini come modello, entrambi con chain of thought attiva, spazio tra un modello all'altro in base al temperamento desiderato. Così mi assicuro le prestazioni dei migliori modelli accompagnate da fonti verificabili. A volte lo faccio attivamente, anche se dovrei farlo più spesso, e scopro siti veramente interessanti.

### I Tre Concetti Critici

Mi sono appuntato alcuni concetti basati su confronti tra l'approccio di freeCodeCamp e alternative migliori. Niente era sbagliato, d'altronde chi sono io per dirlo? Ma approfondire le alternative mi ha portato a ragionare con pensiero critico.

#### 1. style.display vs classList.toggle() - Il SRP

FreeCodeCamp ha proposto:

```javascript
if (isModalShowing) {
  rulesBtn.textContent = "Hide rules";
  rulesContainer.style.display = "block";
} else {
  rulesBtn.textContent = "Show rules";
  rulesContainer.style.display = "none";
}
```

Questa soluzione modifica direttamente gli stili inline dell'elemento HTML. Seguendo il Single Responsibility Principle ha molto più senso separare il CSS dal JavaScript:

```css
.rules-container {
  display: none;
}

.rules-container.show {
  display: block;
}
```

E nel JavaScript:

```javascript
rulesContainer.classList.toggle("show");
rulesBtn.textContent = isModalShowing ? "Hide rules" : "Show rules";
```

Così facendo non abbiamo pezzi di CSS nel JavaScript, bensì due documenti ben distinti: il JavaScript si occupa solo di richiamare lo stile nel CSS, non di crearlo.

#### 2. parseInt() vs Number() - Rigore Semantico

L'approccio di freeCodeCamp è stato `score += parseInt(selectedValue);`

Io avevo inserito `score += Number(selectedValue);`

Sono corrette entrambe, ma **Number() sembra essere più rigoroso**. Ecco perché:

| Aspetto | parseInt() | Number() |
|---------|-----------|----------|
| "15" | 15 ✅ | 15 ✅ |
| "15.7" | 15 (tronca i decimali) | 15.7 (mantiene decimali) |
| "15px" | 15 (ignora resto) | NaN (errore) |
| "" | NaN | 0 |

Number() è più rigoroso perché fallisce quando incontra input invalidi, mentre parseInt() fa conversioni "ottimiste". A seconda del contesto, la rigorosità di Number() può essere preferibile per catturare errori di input.

#### 3. innerHTML += vs createElement() - Performance e DOM Integrity

Questo punto è emerso dal code tutor che ha giustamente fatto notare che:

```javascript
scoreHistory.innerHTML += `<li>${achieved} : ${selectedValue}</li>`;
```

È breve e leggibile, ma la soluzione migliore, seppur più prolissa, è:

```javascript
const historyItem = document.createElement("li");
historyItem.textContent = `${achieved} : ${selectedValue}`;
scoreHistory.appendChild(historyItem);
```

Il perché è veramente interessante: con `innerHTML +=`, avendo già presenti gli elementi:

```html
<li>Three of a kind : 15</li>
<li>Four of a kind : 20</li>
<li>Full house : 25</li>
```

Aggiungendo il 4° elemento con `innerHTML +=`, il browser distrugge i primi 3 e ricrea tutti e 4 da zero! Con `appendChild()` viene semplicemente aggiunto un nuovo elemento, lasciando intatti gli altri.<br />
Questo accade perché in scoreHistory, trovandosi gli altri 3 elementi, il browser andrà a leggere tutto l'HTML esistente (riferito solo a scoreHistory in questo caso), convertire in stringa, aggiungere quella nuova e distruggere quindi gli altri elementi del DOM, rischiando che cambi gli stati da com'erano prima.<br />
`innerHTML` rimane ottimo quando si vuole creare da zero il contenuto di un elemento (con assegnazione, non con aggiunta), ma per append iterativi `createElement()` + `appendChild()` è decisamente superiore.<br />

### Cosa Ho Imparato

**Algoritmi di Pattern Matching:**
- Rilevamento Three/Four of a Kind contando occorrenze di numeri
- Rilevamento Full House verificando la presenza di gruppi di 3 e 2
- Rilevamento Straight convertendo array in stringhe per pattern matching
- Uso di `Set` per rimuovere duplicati: `[...new Set(arr)]`

**Array Methods e Iterazione:**
- `.forEach()` per iterare e modificare elementi DOM
- `.reduce()` per accumulare valori (somma dei dadi)
- `.sort()` con callback numerica per ordinare array
- `.includes()` per cercare patterns in stringhe
- `.some()` per verificare se almeno uno elemento soddisfa una condizione

**Manipolazione Oggetti:**
- Conteggio occorrenze di elementi creando oggetti `{ numero: count }`
- `Object.values()` per estrarre solo i valori da un oggetto
- Operatore ternario inline: `counts[num] = counts[num] ? counts[num] + 1 : 1`

**Event Handling e Validazione:**
- Guard clauses per controllare precondizioni prima di eseguire codice
- Validazione input prima di processare selezioni utente
- `addEventListener()` per gestire interazioni
- `setTimeout()` per ritardare esecuzione (permette UI update prima di alert)

**Pattern di Codice Professionali:**
- DRY (Don't Repeat Yourself): refactoring della chiamata `updateRadioOption(5, 0)` in un'unica posizione
- Separazione delle responsabilità: funzioni specifiche per ogni tipo di rilevamento
- Early exit: uso di `break` per uscire da loop quando trovato ciò che cerchi
- Nomi semantici che spiegano il "cosa" non il "come"

**Differenze Critiche tra Metodi:**
- `textContent` vs `innerHTML`: textContent è più sicuro, innerHTML ricrea DOM
- Assegnazione vs concatenazione: `=` vs `+=` hanno implicazioni di performance diverse
- `style.display` vs `classList.toggle()`: separazione CSS/JS vs inline styles

***

**Prossimo Progetto**: Costruire un Cash Register (CERTIFICATION PROJECT!)
