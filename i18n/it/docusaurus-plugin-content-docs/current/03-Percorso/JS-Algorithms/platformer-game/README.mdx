---
sidebar_position: 4
sidebar_label: 'Platformer Game'
title: 'Platformer Game'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Platformer Game

<img alt="Main menu showing Code Warrior title with Start Game button" src="https://github.com/user-attachments/assets/e70fcae2-8c73-4f3f-96eb-9dca9beea1bf" />
<img alt="Platformer game started with player character on platforms" src="https://github.com/user-attachments/assets/e81626f0-009c-47ac-96e0-f70c91ac0870" />
<img alt="Player character near yellow intermediate checkpoint" src="https://github.com/user-attachments/assets/36b7107b-727a-4a0e-928c-a30ada65c4cd" />
<img alt="Victory screen showing congratulations for reaching final checkpoint" src="https://github.com/user-attachments/assets/3c2c7a83-18e5-4546-b936-2e381c7d1ec9" />

### Il Progetto
Platformer game sviluppato con programmazione orientata agli oggetti intermedia in JavaScript. Un'applicazione che dimostra animazioni fluide, physics engine, collision detection e gestione avanzata dello stato per creare un gioco platform completo.

### Codice Sorgente

<Tabs>
<TabItem value="html" label="index.html" default>

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Learn Intermediate OOP by Building a Platformer Game</title>
  </head>
  <body>
    <div class="start-screen">
      <h1 class="main-title">freeCodeCamp Code Warrior</h1>
      <p class="instructions">
        Help the main player navigate to the yellow checkpoints.
      </p>
      <p class="instructions">
        Use the keyboard arrows to move the player around.
      </p>
      <p class="instructions">You can also use the spacebar to jump.</p>
      <div class="btn-container">
        <button class="btn" id="start-btn">Start Game</button>
      </div>
    </div>
    <div class="checkpoint-screen">
      <h2>Congrats!</h2>
      <p>You reached the last checkpoint.</p>
    </div>
    <canvas id="canvas"></canvas>
    <script src="./script.js"></script>
  </body>
</html>
```
</TabItem>

<TabItem value="css" label="styles.css">

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --main-bg-color: #0a0a23;
  --section-bg-color: #ffffff;
  --golden-yellow: #feac32;
}

body {
  background-color: var(--main-bg-color);
}

.start-screen {
  background-color: var(--section-bg-color);
  width: 100%;
  position: absolute;
  top: 50%;
  left: 50%;
  margin-right: -50%;
  transform: translate(-50%, -50%);
  border-radius: 30px;
  padding: 20px;
  padding-bottom: 5px;
}

.main-title {
  text-align: center;
}

.instructions {
  text-align: center;
  font-size: 1.2rem;
  margin: 15px;
  line-height: 2rem;
}

.btn {
  cursor: pointer;
  width: 100px;
  margin: 10px;
  color: #0a0a23;
  font-size: 18px;
  background-color: var(--golden-yellow);
  background-image: linear-gradient(#fecc4c, #ffac33);
  border-color: var(--golden-yellow);
  border-width: 3px;
}

.btn:hover {
  background-image: linear-gradient(#ffcc4c, #f89808);
}

.btn-container {
  display: flex;
  align-items: center;
  justify-content: center;
}

.checkpoint-screen {
  position: absolute;
  left: 0;
  right: 0;
  margin-left: auto;
  margin-right: auto;
  width: 100%;
  text-align: center;
  background-color: var(--section-bg-color);
  border-radius: 20px;
  padding: 10px;
  display: none;
}

#canvas {
  display: none;
}

@media (min-width: 768px) {
  .start-screen {
    width: 60%;
    max-width: 700px;
  }

  .checkpoint-screen {
    max-width: 300px;
  }
}
```
</TabItem>

<TabItem value="js" label="script.js">

```js
const startBtn = document.getElementById("start-btn");
const canvas = document.getElementById("canvas");
const startScreen = document.querySelector(".start-screen");
const checkpointScreen = document.querySelector(".checkpoint-screen");
const checkpointMessage = document.querySelector(".checkpoint-screen > p");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;
const gravity = 0.5;
let isCheckpointCollisionDetectionActive = true;

const proportionalSize = (size) => {
  return innerHeight < 500 ? Math.ceil((size / 500) * innerHeight) : size;
}

class Player {
  constructor() {
    this.position = {
      x: proportionalSize(10),
      y: proportionalSize(400),
    };
    this.velocity = {
      x: 0,
      y: 0,
    };
    this.width = proportionalSize(40);
    this.height = proportionalSize(40);
  }
  draw() {
    ctx.fillStyle = "#99c9ff";
    ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
  }
  
  update() {
    this.draw();
    this.position.x += this.velocity.x;
    this.position.y += this.velocity.y;

    if (this.position.y + this.height + this.velocity.y <= canvas.height) {
      if (this.position.y < 0) {
        this.position.y = 0;
        this.velocity.y = gravity;
      }
      this.velocity.y += gravity;
    } else {
      this.velocity.y = 0;
    }

    if (this.position.x < this.width) {
      this.position.x = this.width;
    }

    if (this.position.x >= canvas.width - this.width * 2) {
      this.position.x = canvas.width - this.width * 2;
    }
  }
}

class Platform {
  constructor(x, y) {
    this.position = {
      x,
      y,
    };
    this.width = 200;
    this.height = proportionalSize(40);
  }
  draw() {
    ctx.fillStyle = "#acd157";
    ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
  }
}

class CheckPoint {
  constructor(x, y, z) {
    this.position = {
      x,
      y,
    };
    this.width = proportionalSize(40);
    this.height = proportionalSize(70);
    this.claimed = false;
  };

  draw() {
    ctx.fillStyle = "#f1be32";
    ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
  }
  claim() {
    this.width = 0;
    this.height = 0;
    this.position.y = Infinity;
    this.claimed = true;
  }
};

const player = new Player();

const platformPositions = [
  { x: 500, y: proportionalSize(450) },
  { x: 700, y: proportionalSize(400) },
  { x: 850, y: proportionalSize(350) },
  { x: 900, y: proportionalSize(350) },
  { x: 1050, y: proportionalSize(150) },
  { x: 2500, y: proportionalSize(450) },
  { x: 2900, y: proportionalSize(400) },
  { x: 3150, y: proportionalSize(350) },
  { x: 3900, y: proportionalSize(450) },
  { x: 4200, y: proportionalSize(400) },
  { x: 4400, y: proportionalSize(200) },
  { x: 4700, y: proportionalSize(150) },
];

const platforms = platformPositions.map(
  (platform) => new Platform(platform.x, platform.y)
);

const checkpointPositions = [
  { x: 1170, y: proportionalSize(80), z: 1 },
  { x: 2900, y: proportionalSize(330), z: 2 },
  { x: 4800, y: proportionalSize(80), z: 3 },
];

const checkpoints = checkpointPositions.map(
  (checkpoint) => new CheckPoint(checkpoint.x, checkpoint.y, checkpoint.z)
);

const animate = () => {
  requestAnimationFrame(animate);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  platforms.forEach((platform) => {
    platform.draw();
  });

  checkpoints.forEach(checkpoint => {
    checkpoint.draw();
  });

  player.update();

  if (keys.rightKey.pressed && player.position.x < proportionalSize(400)) {
    player.velocity.x = 5;
  } else if (keys.leftKey.pressed && player.position.x > proportionalSize(100)) {
    player.velocity.x = -5;
  } else {
    player.velocity.x = 0;

    if (keys.rightKey.pressed && isCheckpointCollisionDetectionActive) {
      platforms.forEach((platform) => {
        platform.position.x -= 5;
      });

      checkpoints.forEach((checkpoint) => {
        checkpoint.position.x -= 5;
      });
    
    } else if (keys.leftKey.pressed && isCheckpointCollisionDetectionActive) {
      platforms.forEach((platform) => {
        platform.position.x += 5;
      });

      checkpoints.forEach((checkpoint) => {
        checkpoint.position.x += 5;
      });
    }
  }

  platforms.forEach((platform) => {
    const collisionDetectionRules = [
      player.position.y + player.height <= platform.position.y,
      player.position.y + player.height + player.velocity.y >= platform.position.y,
      player.position.x >= platform.position.x - player.width / 2,
      player.position.x <=
        platform.position.x + platform.width - player.width / 3,
    ];

    if (collisionDetectionRules.every((rule) => rule)) {
      player.velocity.y = 0;
      return;
    }

    const platformDetectionRules = [
      player.position.x >= platform.position.x - player.width / 2,
      player.position.x <=
        platform.position.x + platform.width - player.width / 3,
      player.position.y + player.height >= platform.position.y,
      player.position.y <= platform.position.y + platform.height,
    ];

    if (platformDetectionRules.every(rule => rule)) {
      player.position.y = platform.position.y + player.height;
      player.velocity.y = gravity;
    };
  });

  checkpoints.forEach((checkpoint, index, checkpoints) => {
    const checkpointDetectionRules = [
      player.position.x >= checkpoint.position.x,
      player.position.y >= checkpoint.position.y,
      player.position.y + player.height <=
        checkpoint.position.y + checkpoint.height,
      isCheckpointCollisionDetectionActive,
      player.position.x - player.width <=
        checkpoint.position.x - checkpoint.width + player.width * 0.9,
      index === 0 || checkpoints[index - 1].claimed === true,
    ];

    if (checkpointDetectionRules.every((rule) => rule)) {
      checkpoint.claim();


      if (index === checkpoints.length - 1) {
        isCheckpointCollisionDetectionActive = false;
        showCheckpointScreen("You reached the final checkpoint!");
        movePlayer("ArrowRight", 0, false);
      } else if (player.position.x >= checkpoint.position.x && player.position.x <= checkpoint.position.x + 40) {
        showCheckpointScreen("You reached a checkpoint!");
      }


    };
  });
}


const keys = {
  rightKey: {
    pressed: false
  },
  leftKey: {
    pressed: false
  }
};

const movePlayer = (key, xVelocity, isPressed) => {
  if (!isCheckpointCollisionDetectionActive) {
    player.velocity.x = 0;
    player.velocity.y = 0;
    return;
  }

  switch (key) {
    case "ArrowLeft":
      keys.leftKey.pressed = isPressed;
      if (xVelocity === 0) {
        player.velocity.x = xVelocity;
      }
      player.velocity.x -= xVelocity;
      break;
    case "ArrowUp":
    case " ":
    case "Spacebar":
      player.velocity.y -= 8;
      break;
    case "ArrowRight":
      keys.rightKey.pressed = isPressed;
      if (xVelocity === 0) {
        player.velocity.x = xVelocity;
      }
      player.velocity.x += xVelocity;
  }
}

const startGame = () => {
  canvas.style.display = "block";
  startScreen.style.display = "none";
  animate();
}

const showCheckpointScreen = (msg) => {
  checkpointScreen.style.display = "block";
  checkpointMessage.textContent = msg;
  if (isCheckpointCollisionDetectionActive) {
    setTimeout(() => (checkpointScreen.style.display = "none"), 2000);
  }
};

startBtn.addEventListener("click", startGame);

window.addEventListener("keydown", ({ key }) => {
  movePlayer(key, 8, true);
});

window.addEventListener("keyup", ({ key }) => {
  movePlayer(key, 0, false);
});
```

</TabItem> 

<TabItem value="commented" label="spiegato">

```html
<!DOCTYPE html>
<!-- üéÆ DICHIARAZIONE HTML5: "Benvenuti nel nostro Gioco Platformer 2D!" -->
<!-- √à come porre le fondamenta per il nostro parco giochi digitale! üèóÔ∏è -->

<html lang="en">
<!-- üåç CONTENITORE PRINCIPALE: L'intero universo di gioco -->
<!-- lang="en" = Lingua inglese, universale per le esperienze di codifica -->

  <head>
    <!-- üß† CENTRO DI COMANDO: Dove impostiamo l'ambiente di gioco -->
    <!-- Come la sala di controllo di un cabinato arcade! üïπÔ∏è -->
    
    <meta charset="UTF-8" />
    <!-- üìù CODIFICA CARATTERI: Supporta tutti i simboli di testo necessari per il nostro gioco -->
    <!-- UTF-8 assicura che tutto, dal testo del gioco ai commenti di codice, venga visualizzato correttamente -->
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- üîÑ COMPATIBILIT√Ä BROWSER: Garantisce il rendering moderno di IE -->
    <!-- Dice a Internet Explorer di utilizzare il suo motore di rendering pi√π moderno -->
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- üì± CONFIGURAZIONE RESPONSIVE: "Questo gioco si adatta a qualsiasi schermo!" -->
    <!-- Rende il nostro gioco correttamente dimensionato su tutti i dispositivi, dai telefoni ai desktop -->
    
    <title>Learn Intermediate OOP by Building a Platformer Game</title>
    <!-- üìë TITOLO SCHEDA: Scopo educativo chiaramente definito -->
    <!-- OOP = Programmazione Orientata agli Oggetti, la base dello sviluppo di giochi moderni -->
    
    <style>
      /* üé® ===== STILI CSS: Il Mondo Visivo del Gioco ===== */
      
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        /* üßπ PULIZIA TOTALE: Resetta tutti gli spazi predefiniti del browser */
        /* Assicura che il nostro gioco abbia un aspetto coerente su tutti i browser */
        /* √à come livellare il terreno prima di costruire il nostro mondo di gioco */
      }
      
      :root {
        --main-bg-color: #0a0a23;
        --section-bg-color: #ffffff;
        --golden-yellow: #feac32;
        /* üé® VARIABILI COLORE: Definizione centrale della palette */
        /* L'uso di variabili CSS rende i cambiamenti di tema facili e coerenti */
        /* √à come definire i colori principali per il nostro mondo di gioco */
      }
      
      body {
        background-color: var(--main-bg-color);
        /* üåå SFONDO BLU SCURO: Crea un'atmosfera immersiva */
        /* Gli sfondi scuri riducono l'affaticamento degli occhi durante il gioco */
      }
      
      .start-screen {
        background-color: var(--section-bg-color);
        width: 100%;
        position: absolute;
        top: 50%;
        left: 50%;
        margin-right: -50%;
        transform: translate(-50%, -50%);
        /* ‚öñÔ∏è CENTRATURA PERFETTA: Il trucco transform centra l'elemento con precisione */
        /* Centrato orizzontalmente E verticalmente indipendentemente dalla dimensione del contenuto */
        
        border-radius: 30px;
        /* üîÑ ANGOLI ARROTONDATI: Ammorbidiscono l'aspetto visivo */
        /* Crea un'interfaccia utente pi√π moderna e amichevole per i giocatori */
        
        padding: 20px;
        padding-bottom: 5px;
        /* üìè SPAZIATURA INTERNA: Spazio di respiro per il contenuto */
        /* Un padding diverso sopra/sotto crea equilibrio visivo */
      }
      
      .main-title {
        text-align: center;
        /* ‚öñÔ∏è TITOLO CENTRATO: Punto focale della schermata iniziale */
        /* La prima cosa che i giocatori vedono - crea gerarchia e focus */
      }
      
      .instructions {
        text-align: center;
        font-size: 1.2rem;
        margin: 15px;
        line-height: 2rem;
        /* üìù ISTRUZIONI CHIARE: Testo ottimizzato per la leggibilit√† */
        /* font-size: 1.2rem = 20% pi√π grande del testo predefinito */
        /* line-height: 2rem = interlinea doppia per una lettura pi√π facile */
        /* Assicura che i giocatori comprendano come giocare prima di iniziare */
      }
      
      .btn {
        cursor: pointer;
        /* üëÜ CURSORE A MANO: Indicazione visiva che l'elemento √® cliccabile */
        
        width: 100px;
        margin: 10px;
        /* üìè DIMENSIONI PULSANTE: Dimensione confortevole per l'area di click */
        /* 100px di larghezza con 10px di margine crea una buona spaziatura */
        
        color: #0a0a23;
        font-size: 18px;
        /* üî§ STILE TESTO: Testo scuro su pulsante chiaro per leggibilit√† */
        /* 18px di dimensione assicura che il testo sia facilmente leggibile su tutti i dispositivi */
        
        background-color: var(--golden-yellow);
        background-image: linear-gradient(#fecc4c, #ffac33);
        /* üåÖ SFONDO GRADIENTE: Crea effetto pulsante 3D */
        /* Parte superiore pi√π chiara, inferiore pi√π scura crea l'illusione di luce dall'alto */
        
        border-color: var(--golden-yellow);
        border-width: 3px;
        /* üî≤ STILE BORDO: Bordo spesso che si abbina allo sfondo */
        /* 3px di larghezza rende il bordo chiaramente visibile */
      }
      
      .btn:hover {
        background-image: linear-gradient(#ffcc4c, #f89808);
        /* ‚ú® EFFETTO HOVER: Il pulsante si illumina quando il mouse ci passa sopra */
        /* Feedback visivo prima di cliccare migliora l'esperienza utente */
        /* Un gradiente leggermente diverso crea un aspetto "attivato" */
      }
      
      .btn-container {
        display: flex;
        align-items: center;
        justify-content: center;
        /* üì¶ CENTRATURA FLEXBOX: Allineamento orizzontale perfetto */
        /* Approccio moderno alla centratura con CSS */
        /* Assicura che il pulsante sia perfettamente centrato indipendentemente dalla dimensione dello schermo */
      }
      
      .checkpoint-screen {
        position: absolute;
        left: 0;
        right: 0;
        margin-left: auto;
        margin-right: auto;
        /* ‚öñÔ∏è CENTRATURA ORIZZONTALE: Tecnica tradizionale */
        /* Impostare left/right a 0 con margini automatici centra l'elemento */
        
        width: 100%;
        text-align: center;
        background-color: var(--section-bg-color);
        border-radius: 20px;
        padding: 10px;
        /* üìã STILE POPUP: Notifica pulita e leggibile */
        /* Sfondo bianco con angoli arrotondati per un look moderno */
        
        display: none;
        /* üôà INIZIALMENTE NASCOSTO: Appare solo ai checkpoint */
        /* JavaScript cambier√† questo in "block" quando necessario */
      }
      
      #canvas {
        display: none;
        /* üôà CANVAS NASCOSTO: Rivelato quando il gioco inizia */
        /* Inizialmente nascosto per mostrare invece la schermata iniziale */
      }
      
      @media (min-width: 768px) {
        /* üì± BREAKPOINT RESPONSIVE: Tablet e schermi pi√π grandi */
        /* 768px √® la larghezza standard di un tablet in portrait */
        
        .start-screen {
          width: 60%;
          max-width: 700px;
          /* üìè DIMENSIONAMENTO DESKTOP: Pannello pi√π stretto e centrato */
          /* Impedisce che la schermata iniziale si estenda troppo sui grandi schermi */
          /* 60% di larghezza con 700px di massimo crea una larghezza di lettura ideale */
        }
      
        .checkpoint-screen {
          max-width: 300px;
          /* üìè DIMENSIONAMENTO NOTIFICHE: Compatto su schermi pi√π grandi */
          /* 300px √® abbastanza largo per il contenuto ma non invadente */
        }
      }
    </style>
  </head>
  <body>
    <!-- üéÆ ===== INTERFACCIA DEL GIOCO: La Finestra del Giocatore sul Mondo ===== -->
    
    <div class="start-screen">
      <!-- üé¨ SCHERMATA INIZIALE: Il menu iniziale del gioco -->
      <!-- Come la schermata del titolo dei giochi arcade classici! -->
      
      <h1 class="main-title">freeCodeCamp Code Warrior</h1>
      <!-- üìë TITOLO DEL GIOCO: Stabilisce il tema e il brand -->
      <!-- "Code Warrior" suggerisce un'avventura a tema coding -->
      
      <p class="instructions">
        Help the main player navigate to the yellow checkpoints.
      </p>
      <!-- üìù OBIETTIVO DEL GIOCO: Descrizione chiara degli obiettivi -->
      <!-- Dice esattamente al giocatore cosa deve fare -->
      
      <p class="instructions">
        Use the keyboard arrows to move the player around.
      </p>
      <!-- üéÆ SCHEMA DI CONTROLLO 1: Spiegazione dei controlli di movimento -->
      <!-- I tasti freccia sono intuitivi per il movimento 2D -->
      
      <p class="instructions">You can also use the spacebar to jump.</p>
      <!-- üéÆ SCHEMA DI CONTROLLO 2: Meccanica di salto spiegata -->
      <!-- La barra spaziatrice √® il pulsante di salto standard nella maggior parte dei platformer -->

      <div class="btn-container">
        <!-- üì¶ WRAPPER PULSANTE: Centra il pulsante di avvio -->
        
        <button class="btn" id="start-btn">Start Game</button>
        <!-- üéØ PULSANTE AVVIO: Inizia il gioco -->
        <!-- Elemento interattivo cruciale con ID unico per JavaScript -->
      </div>
    </div>

    <div class="checkpoint-screen">
      <!-- üèÜ NOTIFICA CHECKPOINT: Appare quando si raggiungono gli obiettivi -->
      <!-- Fornisce feedback positivo per i traguardi del giocatore -->
      
      <h2>Congrats!</h2>
      <!-- üéâ INTESTAZIONE CELEBRATIVA: Rinforzo positivo -->
      <!-- Un messaggio di congratulazioni crea soddisfazione -->
      
      <p>You reached the last checkpoint.</p>
      <!-- üìù MESSAGGIO DI TRAGUARDO: Chiarisce cosa √® successo -->
      <!-- Sar√† aggiornato via JavaScript per i diversi checkpoint -->
    </div>

    <canvas id="canvas"></canvas>
    <!-- üñºÔ∏è ELEMENTO CANVAS: La superficie di rendering effettiva del gioco -->
    <!-- Il Canvas HTML5 √® come una tavola da disegno vuota per il nostro JavaScript -->
    <!-- Tutte le visuali del gioco saranno disegnate qui programmaticamente -->

    <script>
      /* üéÆ ===== JAVASCRIPT: Il Motore del Gioco! ===== */
      
      /* üîç ===== SELEZIONE ELEMENTI DOM: Collegamento di JS a HTML ===== */
      
      const startBtn = document.getElementById("start-btn");
      /* üîò RIFERIMENTO PULSANTE AVVIO: Accesso diretto tramite ID */
      /* getElementById √® il metodo di selezione pi√π veloce - perfetto per elementi critici */
      /* Come afferrare l'interruttore di accensione per il motore del nostro gioco */
      
      const canvas = document.getElementById("canvas");
      /* üñºÔ∏è RIFERIMENTO CANVAS: La nostra superficie di disegno */
      /* Questo elemento diventer√† il nostro intero mondo di gioco */
      /* Come ottenere una tela vuota prima di dipingere un capolavoro */
      
      const startScreen = document.querySelector(".start-screen");
      /* üé¨ RIFERIMENTO SCHERMATA INIZIALE: Uso del selettore di classe */
      /* querySelector trova il primo elemento corrispondente con questa classe */
      /* Lo nasconderemo quando il gioco inizia */
      
      const checkpointScreen = document.querySelector(".checkpoint-screen");
      /* üèÜ RIFERIMENTO SCHERMATA CHECKPOINT: Per i messaggi di vittoria */
      /* Questo popup apparir√† quando i giocatori raggiungono i checkpoint */
      
      const checkpointMessage = document.querySelector(".checkpoint-screen > p");
      /* üìù RIFERIMENTO MESSAGGIO: Selettore figlio diretto */
      /* Il simbolo ">" seleziona SOLO i figli diretti (non i nipoti) */
      /* Aggiorneremo questo testo quando verranno raggiunti diversi checkpoint */
      
      /* üé® ===== CONFIGURAZIONE CANVAS: Preparazione della Superficie di Disegno ===== */
      
      const ctx = canvas.getContext("2d");
      /* üñåÔ∏è CONTESTO DI DISEGNO: L'API di disegno effettiva */
      /* getContext("2d") ci d√† accesso agli strumenti di disegno Canvas */
      /* Come ottenere un pennello da usare sulla nostra tela */
      /* √à ci√≤ che useremo per disegnare forme, colori e il mondo di gioco */
      
      canvas.width = innerWidth;
      canvas.height = innerHeight;
      /* üìè DIMENSIONI CANVAS: Dimensione a schermo intero */
      /* L'impostazione di larghezza/altezza in JS sovrascrive qualsiasi dimensionamento CSS */
      /* Questo crea un rapporto pixel 1:1 per un rendering nitido */
      /* Senza questo, il canvas avrebbe un default di 300x150px e risulterebbe sfocato se allungato */
      
      /* üåç ===== COSTANTI DELLA FISICA DI GIOCO: Le Regole del Nostro Mondo ===== */
      
      const gravity = 0.5;
      /* ‚¨áÔ∏è COSTANTE DI GRAVIT√Ä: Forza che tira il giocatore verso il basso */
      /* Questa non √® la gravit√† realistica della Terra (9,8 m/s¬≤) ma un valore che "si sente bene" */
      /* Ogni frame aggiunge 0,5 alla velocit√† verticale ‚Üí caduta accelerata */
      /* Valori pi√π alti = caduta pi√π rapida, valori pi√π bassi = salti pi√π fluttuanti */
      
      let isCheckpointCollisionDetectionActive = true;
      /* üö¶ FLAG DI COLLISIONE: Controlla il rilevamento dei checkpoint */
      /* Questo booleano funziona come un interruttore on/off per le interazioni con i checkpoint */
      /* Quando √® false, impedisce che lo stesso checkpoint attivi pi√π volte */
      /* Fondamentale per evitare che il checkpoint si attivi 60 volte al secondo! */
      
      /* üìè ===== FUNZIONE DI SCALATURA: Elementi di Gioco Responsive ===== */
      
      const proportionalSize = (size) => {
        return innerHeight < 500 ? Math.ceil((size / 500) * innerHeight) : size;
        /* üì± SCALATURA ADATTIVA: Gli elementi si ridimensionano per schermi piccoli */
        /* Se l'altezza dello schermo < 500px: scala tutto proporzionalmente */
        /* Formula: (dimensione √∑ altezza di riferimento) √ó altezza effettiva */
        /* Math.ceil() arrotonda per eccesso per evitare elementi di dimensione zero */
        /* Su schermi pi√π alti: usa i valori di dimensione originali */
        /* Come avere un progetto responsive per il nostro mondo di gioco */
      }
      
      /* üßç ===== CLASSE PLAYER: Il Personaggio Principale ===== */
      
      class Player {
        /* üìò DEFINIZIONE CLASSE: Blueprint per creare i giocatori */
        /* Le classi sono modelli che definiscono propriet√† e comportamenti */
        /* Come definire cosa fa un "giocatore" nel nostro universo di gioco */
        
        constructor() {
          /* üèóÔ∏è METODO COSTRUTTORE: Eseguito quando si crea un nuovo Player */
          /* Questo metodo inizializza tutte le propriet√† del giocatore */
          /* Come costruire il personaggio giocatore da zero */
          
          this.position = {
            x: proportionalSize(10),
            y: proportionalSize(400),
          };
          /* üìç POSIZIONE INIZIALE: Dove inizia il giocatore */
          /* Coordinate dall'angolo in alto a sinistra dello schermo */
          /* L'uso di proportionalSize garantisce che funzioni su tutti i formati di schermo */
          
          this.velocity = {
            x: 0, /* Velocit√† orizzontale (pixel per frame) */
            y: 0, /* Velocit√† verticale (pixel per frame) */
          };
          /* üèéÔ∏è VETTORE VELOCIT√Ä: Velocit√† e direzione */
          /* Componenti x/y separate consentono movimento orizzontale/verticale indipendente */
          /* 0 significa fermo in ogni direzione */
          
          this.width = proportionalSize(40);
          this.height = proportionalSize(40);
          /* üìè DIMENSIONI GIOCATORE: Dimensione del personaggio */
          /* 40x40px crea un giocatore quadrato (responsive su piccoli schermi) */
          /* La dimensione influisce sia sugli aspetti visivi che sul rilevamento delle collisioni */
        }
        
        draw() {
          /* üé® METODO DI DISEGNO: Renderizza il giocatore sullo schermo */
          /* Chiamato ogni frame per mostrare il giocatore */
          
          ctx.fillStyle = "#99c9ff";
          /* üé® COLORE GIOCATORE: Azzurro chiaro */
          /* Imposta il "colore della pittura" prima di disegnare */
          
          ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
          /* üì¶ DISEGNA RETTANGOLO: Crea la forma del giocatore */
          /* fillRect(x, y, width, height) disegna un rettangolo pieno */
          /* Questo semplice quadrato rappresenta il nostro personaggio */
          /* Nei giochi professionali, questo sarebbe sostituito con immagini sprite */
        }
        
        update() {
          /* üîÑ METODO DI AGGIORNAMENTO: Fisica e logica di gioco */
          /* Chiamato ogni frame (60 volte al secondo) */
          /* Il cuore del comportamento del giocatore nel gioco */
          
          this.draw();
          /* üé® RENDERIZZA PRIMA: Assicura che il giocatore sia visibile */
          /* Disegna sempre prima di muoversi per prevenire glitch visivi */
          
          this.position.x += this.velocity.x;
          this.position.y += this.velocity.y;
          /* üö∂ FISICA DEL MOVIMENTO: La posizione cambia in base alla velocit√† */
          /* Questa √® l'equazione fondamentale del movimento: posizione += velocit√† */
          /* La direzione e la velocit√† del movimento dipendono dai valori di velocit√† */
          
          if (this.position.y + this.height + this.velocity.y <= canvas.height) {
            /* üå°Ô∏è CONTROLLO GRAVIT√Ä: Il giocatore √® ancora in aria? */
            /* La condizione verifica se il giocatore non ha raggiunto il fondo dello schermo */
            /* Posizione bordo inferiore = posizione y + altezza */
            
            if (this.position.y < 0) {
              /* üõë CONTROLLO LIMITE SUPERIORE: Il giocatore sta cercando di uscire dallo schermo? */
              /* y < 0 significa che il giocatore sta cercando di saltare sopra il canvas */
              
              this.position.y = 0;
              this.velocity.y = gravity;
              /* üîÑ COLLISIONE CON SOFFITTO: Rimbalza il giocatore verso il basso */
              /* Impedisce di andare sopra lo schermo e inizia a cadere */
            }
            
            this.velocity.y += gravity;
            /* ‚¨áÔ∏è APPLICA GRAVIT√Ä: Aumenta la velocit√† di caduta */
            /* Questo crea accelerazione - la caduta diventa pi√π veloce nel tempo */
            /* La base della fisica di salto realistica! */
          } else {
            /* üõë COLLISIONE COL PAVIMENTO: Il giocatore ha raggiunto il fondo */
            
            this.velocity.y = 0;
            /* üõë FERMA LA CADUTA: Imposta la velocit√† verticale a zero */
            /* Impedisce al giocatore di cadere attraverso il pavimento */
          }
      
          if (this.position.x < this.width) {
            /* üõë CONTROLLO LIMITE SINISTRO: Impedisce di uscire dallo schermo a sinistra */
            
            this.position.x = this.width;
            /* üîô RESPINGE: Imposta la posizione al bordo dello schermo */
            /* Crea un muro invisibile al bordo sinistro dello schermo */
          }
      
          if (this.position.x >= canvas.width - this.width * 2) {
            /* üõë CONTROLLO LIMITE DESTRO: Impedisce di uscire dallo schermo a destra */
            
            this.position.x = canvas.width - this.width * 2;
            /* üîô RESPINGE: Imposta la posizione al bordo dello schermo */
            /* La moltiplicazione crea un limite visivo migliore */
          }
        }
      }
      
      /* üß± ===== CLASSE PLATFORM: Il Terreno Solido ===== */
      
      class Platform {
        /* üìò DEFINIZIONE CLASSE: Blueprint per le piattaforme */
        /* Ogni piattaforma √® una superficie su cui il giocatore pu√≤ stare */
        
        constructor(x, y) {
          /* üèóÔ∏è COSTRUTTORE CON PARAMETRI: Piattaforme personalizzabili */
          /* Prende le coordinate x,y per posizionare piattaforme ovunque */
          /* Come posizionare blocchi di costruzione nel nostro mondo */
          
          this.position = {
            x, /* Abbreviazione per x: x */
            y, /* Abbreviazione per y: y */
          };
          /* üìç POSIZIONE PIATTAFORMA: Posizionamento personalizzato */
          /* JS moderno permette l'abbreviazione quando nome propriet√† = nome variabile */
          /* Questo crea la piattaforma alle coordinate esatte specificate */
          
          this.width = 200;
          this.height = proportionalSize(40);
          /* üìè DIMENSIONE PIATTAFORMA: Larghezza e altezza */
          /* 200px di larghezza crea piattaforme su cui il giocatore pu√≤ correre */
          /* L'altezza si adatta alla dimensione dello schermo per coerenza */
        }
        
        draw() {
          /* üé® METODO DI DISEGNO: Renderizza la piattaforma sullo schermo */
          
          ctx.fillStyle = "#acd157";
          /* üé® COLORE PIATTAFORMA: Verde chiaro */
          /* Un colore simile all'erba distingue le piattaforme dal giocatore */
          
          ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
          /* üì¶ DISEGNA RETTANGOLO: Crea la forma della piattaforma */
          /* Un semplice rettangolo rappresenta ogni piattaforma */
        }
      }
      
      /* üö© ===== CLASSE CHECKPOINT: I Marcatori degli Obiettivi ===== */
      
      class CheckPoint {
        /* üìò DEFINIZIONE CLASSE: Blueprint per i marcatori degli obiettivi */
        /* Questi sono gli obiettivi che il giocatore deve raggiungere */
        
        constructor(x, y, z) {
          /* üèóÔ∏è COSTRUTTORE CON PARAMETRI: Checkpoint personalizzabili */
          /* x,y = posizione, z = numero/sequenza del checkpoint */
          
          this.position = {
            x,
            y,
          };
          /* üìç POSIZIONE CHECKPOINT: Posizionamento personalizzato */
          /* Usa la stessa sintassi abbreviata di Platform */
          
          this.width = proportionalSize(40);
          this.height = proportionalSize(70);
          /* üìè DIMENSIONE CHECKPOINT: Alto e stretto */
          /* Pi√π alto del giocatore per essere facilmente visibile */
          
          this.claimed = false;
          /* üö© FLAG CLAIMED: Tiene traccia dello stato del checkpoint */
          /* false = non ancora raggiunto, true = gi√† raccolto */
          /* Come una bandierina virtuale "Sono stato qui" che il giocatore pianta */
        };
      
        draw() {
          /* üé® METODO DI DISEGNO: Renderizza il checkpoint sullo schermo */
          
          ctx.fillStyle = "#f1be32";
          /* üé® COLORE CHECKPOINT: Giallo dorato */
          /* Il colore brillante fa risaltare i checkpoint come obiettivi */
          
          ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
          /* üì¶ DISEGNA RETTANGOLO: Crea la forma del checkpoint */
          /* Il rettangolo verticale assomiglia a una bandiera del traguardo */
        }
        
        claim() {
          /* üèÅ METODO CLAIM: "Raccoglie" il checkpoint */
          /* Chiamato quando il giocatore raggiunge questo checkpoint */
          
          this.width = 0;
          this.height = 0;
          /* üôà RENDI INVISIBILE: Dimensioni zero lo nascondono */
          /* Piuttosto che rimuoverlo dall'array, lo rendiamo invisibile */
          
          this.position.y = Infinity;
          /* üå† MANDA VIA: Sposta fuori dallo schermo */
          /* Infinity garantisce che non possa mai pi√π essere colpito */
          /* Questo √® pi√π sicuro che modificare l'array durante l'iterazione */
          
          this.claimed = true;
          /* üö© SEGNA COME CLAIMED: Aggiorna il flag di stato */
          /* Questo aiuta a tenere traccia del progresso e della sequenza dei checkpoint */
          /* Usato per la logica condizionale nel rilevamento delle collisioni */
        }
      };
      
      /* üè≠ ===== CREAZIONE OGGETTI DI GIOCO: Costruzione del Mondo ===== */
      
      const player = new Player();
      /* üßç CREA GIOCATORE: Istanza della classe Player */
      /* new Player() chiama il costruttore e crea un oggetto funzionante */
      /* Come premere il pulsante "stampa" sul nostro blueprint del giocatore */
      
      const platformPositions = [
        { x: 500, y: proportionalSize(450) },
        { x: 700, y: proportionalSize(400) },
        { x: 850, y: proportionalSize(350) },
        { x: 900, y: proportionalSize(350) },
        { x: 1050, y: proportionalSize(150) },
        { x: 2500, y: proportionalSize(450) },  /* Gap grande ‚Üí sfida! */
        { x: 2900, y: proportionalSize(400) },
        { x: 3150, y: proportionalSize(350) },
        { x: 3900, y: proportionalSize(450) },  /* Altro gap */
        { x: 4200, y: proportionalSize(400) },
        { x: 4400, y: proportionalSize(200) },
        { x: 4700, y: proportionalSize(150) },
      ];
      /* üó∫Ô∏è DESIGN DEL LIVELLO: Array delle coordinate delle piattaforme */
      /* Ogni oggetto contiene la posizione x,y per una piattaforma */
      /* Questo √® il nostro "progetto del livello" - separa i dati dalla logica */
      /* I commenti indicano dove si verificano gap impegnativi nel livello */
      
      const platforms = platformPositions.map(
        (platform) => new Platform(platform.x, platform.y)
      );
      /* üè≠ CREAZIONE PIATTAFORME: Trasforma i dati in oggetti */
      /* map() converte ogni posizione in una Platform funzionante */
      /* √à come una catena di montaggio: dati in ingresso ‚Üí oggetti in uscita */
      /* Arrow function con return implicito crea ogni Platform */
      
      const checkpointPositions = [
        { x: 1170, y: proportionalSize(80), z: 1 },
        { x: 2900, y: proportionalSize(330), z: 2 },
        { x: 4800, y: proportionalSize(80), z: 3 },
      ];
      /* üö© POSIZIONI CHECKPOINT: Coordinate degli obiettivi */
      /* Tre checkpoint sono posizionati in punti strategici del livello */
      /* Il valore z tiene traccia del numero di sequenza del checkpoint */
      
      const checkpoints = checkpointPositions.map(
        (checkpoint) => new CheckPoint(checkpoint.x, checkpoint.y, checkpoint.z)
      );
      /* üè≠ CREAZIONE CHECKPOINT: Trasforma i dati in oggetti */
      /* Stesso schema di mapping delle piattaforme, crea oggetti CheckPoint */
      
      /* üîÑ ===== GAME LOOP: Il Motore di Animazione ===== */
      
      const animate = () => {
        /* üé¨ GAME LOOP PRINCIPALE: Funzione eseguita ogni frame */
        /* Questo √® il battito cardiaco del nostro gioco - tutto accade qui */
        
        requestAnimationFrame(animate);
        /* üîÑ CREAZIONE LOOP: API di animazione del browser */
        /* Chiede al browser di chiamare animate() prima del prossimo repaint */
        /* Crea un ciclo fluido a 60fps ottimizzato per le prestazioni */
        /* Auto-referenziale - animate chiama se stesso creando un loop infinito */
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        /* üßπ PULISCI CANVAS: Cancella il frame precedente */
        /* Come cancellare una lavagna prima di disegnare il prossimo stato */
        /* Senza questo, i movimenti lascerebbero tracce dietro di loro */
      
        platforms.forEach((platform) => {
          platform.draw();
        });
        /* üé® DISEGNA PIATTAFORME: Renderizza tutte le piattaforme */
        /* forEach esegue la funzione su ogni elemento dell'array */
        /* Viene chiamato il metodo draw() di ogni piattaforma per renderizzarla */
      
        checkpoints.forEach(checkpoint => {
          checkpoint.draw();
        });
        /* üé® DISEGNA CHECKPOINT: Renderizza tutti i checkpoint */
        /* Stesso schema delle piattaforme - disegna ogni checkpoint */
      
        player.update();
        /* üîÑ AGGIORNA GIOCATORE: Fisica e rendering */
        /* Questo chiama il metodo update del giocatore che:
           1. Disegna il giocatore
           2. Aggiorna la posizione in base alla velocit√†
           3. Applica gravit√† e controlli dei limiti */
      
        /* üì∑ ===== MOVIMENTO DELLA CAMERA: Scorrimento del Mondo ===== */
        
        if (keys.rightKey.pressed && player.position.x < proportionalSize(400)) {
          /* üèÉ‚Äç‚ôÇÔ∏è MOVIMENTO GIOCATORE DESTRA: Sposta il giocatore quando √® lontano dal centro */
          /* Quando il tasto destro √® premuto E il giocatore √® a sinistra del punto centrale */
          
          player.velocity.x = 5;
          /* ‚û°Ô∏è IMPOSTA VELOCIT√Ä: Muove il giocatore a destra */
          /* 5 pixel per frame creano un movimento fluido */
        } else if (keys.leftKey.pressed && player.position.x > proportionalSize(100)) {
          /* üèÉ‚Äç‚ôÇÔ∏è MOVIMENTO GIOCATORE SINISTRA: Sposta il giocatore quando √® lontano dal bordo sinistro */
          /* Quando il tasto sinistro √® premuto E il giocatore √® a destra del limite sinistro */
          
          player.velocity.x = -5;
          /* ‚¨ÖÔ∏è IMPOSTA VELOCIT√Ä: Muove il giocatore a sinistra */
          /* Velocit√† negativa significa movimento verso sinistra */
        } else {
          /* üõë POSIZIONE CENTRALE: Giocatore vicino al centro o ai bordi */
          
          player.velocity.x = 0;
          /* üõë FERMA MOVIMENTO ORIZZONTALE: Giocatore fermo */
          /* Reimposta la velocit√† a zero - il giocatore smette di muoversi orizzontalmente */
      
          /* üåé SCORRIMENTO MONDO: Sposta l'ambiente invece del giocatore */
          /* Questo crea l'illusione di una camera che segue il giocatore */
          
          if (keys.rightKey.pressed && isCheckpointCollisionDetectionActive) {
            /* ‚û°Ô∏è SCORRI DESTRA: Sposta il mondo quando il giocatore √® centrato */
            /* Attivo solo quando la rilevazione delle collisioni con checkpoint √® abilitata */
            
            platforms.forEach((platform) => {
              platform.position.x -= 5;
              /* ‚¨ÖÔ∏è SPOSTA PIATTAFORME A SINISTRA: Il mondo scorre in direzione opposta al giocatore */
              /* Crea l'illusione che il giocatore si muova verso destra */
            });
      
            checkpoints.forEach((checkpoint) => {
              checkpoint.position.x -= 5;
              /* ‚¨ÖÔ∏è SPOSTA CHECKPOINT A SINISTRA: Mantiene sincronizzati con le piattaforme */
              /* Tutto nel mondo si muove insieme per uno scorrimento coerente */
            });
          
          } else if (keys.leftKey.pressed && isCheckpointCollisionDetectionActive) {
            /* ‚¨ÖÔ∏è SCORRI SINISTRA: Sposta il mondo quando il giocatore √® centrato */
            
            platforms.forEach((platform) => {
              platform.position.x += 5;
              /* ‚û°Ô∏è SPOSTA PIATTAFORME A DESTRA: Il mondo scorre in direzione opposta al giocatore */
              /* Crea l'illusione che il giocatore si muova verso sinistra */
            });
      
            checkpoints.forEach((checkpoint) => {
              checkpoint.position.x += 5;
              /* ‚û°Ô∏è SPOSTA CHECKPOINT A DESTRA: Mantiene sincronizzati con le piattaforme */
            });
          }
        }
      
        /* üí• ===== RILEVAMENTO COLLISIONI CON PIATTAFORME ===== */
        
        platforms.forEach((platform) => {
          /* üîç CONTROLLA OGNI PIATTAFORMA: Itera attraverso tutte le piattaforme */
          
          const collisionDetectionRules = [
            player.position.y + player.height <= platform.position.y,
            /* ‚¨áÔ∏è REGOLA 1: Fondo del giocatore sopra la parte superiore della piattaforma */
            /* Assicura che il giocatore stia scendendo sulla piattaforma dall'alto */
            
            player.position.y + player.height + player.velocity.y >= platform.position.y,
            /* ‚¨áÔ∏è REGOLA 2: La prossima posizione del giocatore intersecher√† la piattaforma */
            /* Prevede la collisione basata sulla velocit√† attuale */
            
            player.position.x >= platform.position.x - player.width / 2,
            /* ‚¨ÖÔ∏è REGOLA 3: Giocatore non troppo a sinistra della piattaforma */
            /* Controllo posizione orizzontale - bordo sinistro */
            
            player.position.x <=
              platform.position.x + platform.width - player.width / 3,
            /* ‚û°Ô∏è REGOLA 4: Giocatore non troppo a destra della piattaforma */
            /* Controllo posizione orizzontale - bordo destro */
          ];
      
          if (collisionDetectionRules.every((rule) => rule)) {
            /* ‚úÖ TUTTE LE REGOLE VERE: In piedi sulla piattaforma */
            /* every() verifica se TUTTE le condizioni restituiscono true */
            /* Questo √® come un AND logico tra tutte le condizioni */
            
            player.velocity.y = 0;
            /* üõë FERMA CADUTA: Atterra sulla piattaforma */
            /* Velocit√† verticale zero impedisce di cadere attraverso la piattaforma */
            
            return;
            /* üö™ ESCI DAL LOOP: Salta le piattaforme rimanenti */
            /* Una volta trovata una collisione, non c'√® bisogno di controllare le altre */
          }
      
          /* üí• COLLISIONE DAL BASSO: Colpisce la piattaforma da sotto */
          
          const platformDetectionRules = [
            player.position.x >= platform.position.x - player.width / 2,
            /* ‚¨ÖÔ∏è REGOLA 1: Controllo sovrapposizione orizzontale (sinistra) */
            
            player.position.x <=
              platform.position.x + platform.width - player.width / 3,
            /* ‚û°Ô∏è REGOLA 2: Controllo sovrapposizione orizzontale (destra) */
            
            player.position.y + player.height >= platform.position.y,
            /* ‚¨ÜÔ∏è REGOLA 3: Fondo del giocatore sotto la parte superiore della piattaforma */
            
            player.position.y <= platform.position.y + platform.height,
            /* ‚¨áÔ∏è REGOLA 4: Parte superiore del giocatore sopra la parte inferiore della piattaforma */
          ];
      
          if (platformDetectionRules.every(rule => rule)) {
            /* ‚úÖ TUTTE LE REGOLE VERE: Colpisce la piattaforma dal basso */
            
            player.position.y = platform.position.y + player.height;
            /* ‚¨áÔ∏è SPINGE GI√ô: Sposta il giocatore sotto la piattaforma */
            /* Impedisce di rimanere bloccati all'interno della piattaforma */
            
            player.velocity.y = gravity;
            /* ‚¨áÔ∏è INIZIA A CADERE: Applica la gravit√† */
            /* Rimbalza il giocatore verso il basso dopo aver colpito con la testa */
          };
        });
      
        /* üö© ===== RILEVAMENTO COLLISIONI CON CHECKPOINT ===== */
        
        checkpoints.forEach((checkpoint, index, checkpoints) => {
          /* üîç CONTROLLA OGNI CHECKPOINT: Itera attraverso tutti i checkpoint */
          /* index = posizione nell'array, checkpoints = l'array completo */
          
          const checkpointDetectionRules = [
            player.position.x >= checkpoint.position.x,
            /* ‚û°Ô∏è REGOLA 1: Bordo destro del giocatore oltre il bordo sinistro del checkpoint */
            
            player.position.y >= checkpoint.position.y,
            /* ‚¨áÔ∏è REGOLA 2: Giocatore sotto la parte superiore del checkpoint */
            
            player.position.y + player.height <=
              checkpoint.position.y + checkpoint.height,
            /* ‚¨ÜÔ∏è REGOLA 3: Giocatore entro i limiti verticali del checkpoint */
            
            isCheckpointCollisionDetectionActive,
            /* üö¶ REGOLA 4: Il sistema di rilevamento collisioni √® attivo */
            /* Impedisce attivazioni multiple quando l'interruttore globale √® spento */
            
            player.position.x - player.width <=
              checkpoint.position.x - checkpoint.width + player.width * 0.9,
            /* ‚¨ÖÔ∏è REGOLA 5: Controllo di allineamento orizzontale complesso */
            /* Assicura che il giocatore sia posizionato correttamente rispetto al checkpoint */
            
            index === 0 || checkpoints[index - 1].claimed === true,
            /* üî¢ REGOLA 6: Controllo ordine checkpoint */
            /* O questo √® il primo checkpoint O quello precedente √® stato reclamato */
            /* Forza la raccolta sequenziale dei checkpoint */
          ];
      
          if (checkpointDetectionRules.every((rule) => rule)) {
            /* ‚úÖ TUTTE LE REGOLE VERE: Checkpoint raggiunto */
            
            checkpoint.claim();
            /* üèÅ RECLAMA CHECKPOINT: Segna come raggiunto */
            /* Questo nasconde il checkpoint e lo marca come claimed */
      
            if (index === checkpoints.length - 1) {
              /* üèÜ CHECKPOINT FINALE: Ultimo nell'array */
              /* Lunghezza - 1 √® l'indice dell'ultimo elemento */
              
              isCheckpointCollisionDetectionActive = false;
              /* üö´ DISABILITA COLLISIONI: Il gioco effettivamente finisce */
              /* Impedisce ulteriori attivazioni di checkpoint */
              
              showCheckpointScreen("You reached the final checkpoint!");
              /* üéâ MESSAGGIO DI VITTORIA: Traguardo finale */
              /* Mostra un messaggio di congratulazioni con testo personalizzato */
              
              movePlayer("ArrowRight", 0, false);
              /* üõë FERMA GIOCATORE: Previene il movimento dopo la vittoria */
              /* Reimposta lo stato del movimento per far fermare il giocatore */
            } else if (player.position.x >= checkpoint.position.x && player.position.x <= checkpoint.position.x + 40) {
              /* ‚úÖ CHECKPOINT REGOLARE: Non l'ultimo */
              /* Controllo posizione aggiuntivo assicura il corretto timing di attivazione */
              
              showCheckpointScreen("You reached a checkpoint!");
              /* üéâ MESSAGGIO DI PROGRESSO: Traguardo intermedio */
            }
          };
        });
      }
      
      /* üéÆ ===== TRACCIAMENTO STATO TASTIERA ===== */
      
      const keys = {
        rightKey: {
          pressed: false
        },
        leftKey: {
          pressed: false
        }
      };
      /* üéÆ OGGETTO STATO TASTIERA: Tiene traccia dei tasti premuti */
      /* Oggetti nidificati: keys ‚Üí rightKey ‚Üí pressed */
      /* Uso di flag booleani invece di controllare lo stato dei tasti ad ogni frame */
      /* Questo permette un movimento fluido e coerente */
      
      const movePlayer = (key, xVelocity, isPressed) => {
        /* üèÉ‚Äç‚ôÇÔ∏è FUNZIONE MOVIMENTO GIOCATORE: Elabora le azioni dei tasti */
        /* key = quale tasto √® stato premuto */
        /* xVelocity = quanto velocemente muoversi */
        /* isPressed = tasto premuto o rilasciato? */
        
        if (!isCheckpointCollisionDetectionActive) {
          /* üö´ CONTROLLO FINE GIOCO: Blocca il movimento se il gioco √® finito */
          
          player.velocity.x = 0;
          player.velocity.y = 0;
          /* üõë CONGELA GIOCATORE: Ferma ogni movimento */
          
          return;
          /* üö™ ESCI DALLA FUNZIONE: Salta il codice rimanente */
        }
      
        switch (key) {
          /* üîÄ SWITCH TASTI: Azione diversa per ogni tasto */
          /* Modo efficiente per gestire pi√π opzioni di tasto */
          
          case "ArrowLeft":
            /* ‚¨ÖÔ∏è FRECCIA SINISTRA: Muove il giocatore a sinistra */
            
            keys.leftKey.pressed = isPressed;
            /* üîÑ AGGIORNA STATO TASTO: Tiene traccia se il tasto √® premuto */
            
            if (xVelocity === 0) {
              player.velocity.x = xVelocity;
              /* üõë VELOCIT√Ä ZERO: Per evento keyup */
              /* Quando si rilascia il tasto, ferma immediatamente il movimento */
            }
            player.velocity.x -= xVelocity;
            /* ‚¨ÖÔ∏è APPLICA VELOCIT√Ä: Muove a sinistra */
            /* Sottrae dalla velocit√† x per muoversi a sinistra */
            break;
            
          case "ArrowUp":
          case " ":
          case "Spacebar":
            /* ‚¨ÜÔ∏è SU/SPAZIO: Azione di salto */
            /* Pi√π casi gestiscono diversi tasti di salto */
            /* Sia la freccia su che la barra spaziatrice attivano il salto */
            
            player.velocity.y -= 8;
            /* ‚¨ÜÔ∏è VELOCIT√Ä DI SALTO: Si muove verso l'alto */
            /* Velocit√† y negativa significa movimento verso l'alto */
            /* Valore 8 crea un'altezza di salto soddisfacente */
            break;
            
          case "ArrowRight":
            /* ‚û°Ô∏è FRECCIA DESTRA: Muove il giocatore a destra */
            
            keys.rightKey.pressed = isPressed;
            /* üîÑ AGGIORNA STATO TASTO: Tiene traccia se il tasto √® premuto */
            
            if (xVelocity === 0) {
              player.velocity.x = xVelocity;
              /* üõë VELOCIT√Ä ZERO: Per evento keyup */
            }
            player.velocity.x += xVelocity;
            /* ‚û°Ô∏è APPLICA VELOCIT√Ä: Muove a destra */
            /* Aggiunge alla velocit√† x per muoversi a destra */
        }
      }
      
      /* üéÆ ===== FUNZIONI GESTIONE GIOCO ===== */
      
      const startGame = () => {
        /* üèÅ AVVIO GIOCO: Inizializza il gameplay */
        
        canvas.style.display = "block";
        /* üñºÔ∏è MOSTRA CANVAS: Rende il gioco visibile */
        /* Cambia il display da "none" a "block" */
        
        startScreen.style.display = "none";
        /* üôà NASCONDI SCHERMATA INIZIALE: Rimuove il menu */
        /* Una volta che il gioco inizia, non abbiamo pi√π bisogno del menu */
        
        animate();
        /* üé¨ AVVIA ANIMAZIONE: Inizia il game loop */
        /* Questo lancia il motore di gioco principale */
      }
      
      const showCheckpointScreen = (msg) => {
        /* üèÜ NOTIFICA CHECKPOINT: Mostra messaggio di traguardo */
        /* msg = testo personalizzato per diversi checkpoint */
        
        checkpointScreen.style.display = "block";
        /* üìù MOSTRA MESSAGGIO: Rende la notifica visibile */
        
        checkpointMessage.textContent = msg;
        /* üìù IMPOSTA TESTO: Aggiorna il contenuto del messaggio */
        /* Usa il parametro per personalizzare il messaggio */
        
        if (isCheckpointCollisionDetectionActive) {
          /* ‚è±Ô∏è VISUALIZZAZIONE TEMPORANEA: Solo se il gioco √® ancora attivo */
          
          setTimeout(() => (checkpointScreen.style.display = "none"), 2000);
          /* ‚è±Ô∏è RIMOZIONE TEMPORIZZATA: Nascondi dopo 2 secondi */
          /* setTimeout esegue la funzione dopo un ritardo in millisecondi */
          /* Arrow function con parentesi attorno ad una singola istruzione */
        }
      };
      
      /* üñ±Ô∏è ===== EVENT LISTENER: Gestione Input Utente ===== */
      
      startBtn.addEventListener("click", startGame);
      /* üé¨ LISTENER PULSANTE AVVIO: Inizia il gioco al click */
      /* Collega il pulsante HTML alla funzione JavaScript */
      
      window.addEventListener("keydown", ({ key }) => {
        /* üéÆ LISTENER PRESSIONE TASTI: Rileva quando i tasti vengono premuti */
        /* { key } usa la destrutturazione per estrarre la propriet√† key dall'evento */
        /* Molto pi√π pulito che scrivere (event) e poi event.key */
        
        movePlayer(key, 8, true);
        /* üèÉ‚Äç‚ôÇÔ∏è GESTISCI PRESSIONE TASTO: Muovi a velocit√† 8, tasto √® premuto */
        /* true = tasto √® premuto (evento keydown) */
      });
      
      window.addEventListener("keyup", ({ key }) => {
        /* üéÆ LISTENER RILASCIO TASTI: Rileva quando i tasti vengono rilasciati */
        /* Controparte a keydown - necessario per controlli fluidi */
        
        movePlayer(key, 0, false);
        /* üõë GESTISCI RILASCIO TASTO: Ferma movimento, tasto √® rilasciato */
        /* 0 = velocit√† zero (ferma movimento) */
        /* false = tasto √® rilasciato (evento keyup) */
      });
    </script>
  </body>
</html>

<!-- üéØ ===== RIASSUNTO DEL GIOCO PLATFORMER ===== -->
<!-- 
üéÆ ARCHITETTURA DEL GIOCO:
‚îÇ
‚îú‚îÄ‚îÄ üñ•Ô∏è STRUTTURA HTML
‚îÇ   ‚îú‚îÄ‚îÄ üìã Schermata iniziale con istruzioni
‚îÇ   ‚îú‚îÄ‚îÄ üèÜ Popup di notifica checkpoint
‚îÇ   ‚îî‚îÄ‚îÄ üñºÔ∏è Superficie di gioco Canvas
‚îÇ
‚îú‚îÄ‚îÄ üé® STILE CSS
‚îÇ   ‚îú‚îÄ‚îÄ üéÆ Componenti dell'interfaccia di gioco
‚îÇ   ‚îú‚îÄ‚îÄ üîò Stile pulsanti interattivi
‚îÇ   ‚îî‚îÄ‚îÄ üì± Design responsive per tutti gli schermi
‚îÇ
‚îî‚îÄ‚îÄ üß† MOTORE DI GIOCO JAVASCRIPT
    ‚îú‚îÄ‚îÄ üì¶ Programmazione Orientata agli Oggetti (Classi)
    ‚îÇ   ‚îú‚îÄ‚îÄ üßç Player con fisica e collisioni
    ‚îÇ   ‚îú‚îÄ‚îÄ üß± Piattaforme per la navigazione
    ‚îÇ   ‚îî‚îÄ‚îÄ üö© Checkpoint per gli obiettivi
    ‚îÇ
    ‚îú‚îÄ‚îÄ üéÆ Meccaniche di Gioco
    ‚îÇ   ‚îú‚îÄ‚îÄ ‚¨áÔ∏è Fisica di gravit√† e salto
    ‚îÇ   ‚îú‚îÄ‚îÄ üì∑ Sistema di scorrimento camera
    ‚îÇ   ‚îú‚îÄ‚îÄ üí• Rilevamento collisioni
    ‚îÇ   ‚îî‚îÄ‚îÄ üèÜ Sistema di checkpoint progressivo
    ‚îÇ
    ‚îî‚îÄ‚îÄ üîÑ Implementazione Tecnica
        ‚îú‚îÄ‚îÄ üé¨ Loop RequestAnimationFrame
        ‚îú‚îÄ‚îÄ üìè Dimensionamento proporzionale per responsivit√†
        ‚îú‚îÄ‚îÄ üéÆ Controlli da tastiera basati su eventi
        ‚îî‚îÄ‚îÄ üéØ Gestione dello stato per il progresso del gioco

Questo progetto dimostra i principi fondamentali dello sviluppo di giochi attraverso OOP!
Dalla simulazione fisica al rilevamento delle collisioni, √® un motore di mini-gioco completo!
-->
```
</TabItem>

</Tabs>

### Le Tre Rivelazioni

Sono 3 i concetti che mi hanno colpito di questo progetto: **API**, **requestAnimationFrame** e **Infinity**.

#### API: Sulle Spalle di Giganti

Trovo incredibile come un semplice richiamo ad una API dia a noi utilizzatori finali la sensazione di facilit√† del comando, ma dietro le quinte ci sono svariate linee di codice che la compongono.<br />
Riconosco ora il grande lavoro dei backend: che siano gli ingegneri software dei vari browser, che siano i developer che contribuiscono con l'opensource. Riconosco di stare letteralmente **sulle spalle di giganti**.<br />
Ogni volta che scrivo `requestAnimationFrame()` o `canvas.getContext('2d')`, sto usando il risultato di anni di ottimizzazioni, discussioni tecniche e iterazioni.

#### requestAnimationFrame: Efficienza Intelligente

Prendiamo ad esempio l'API `requestAnimationFrame()`. Grazie a questa semplice chiamata, il browser conosce esattamente quando sta per ridisegnare lo schermo (refresh cycle).<br />
**Passa dai 60 agli 0 fps in base a se c'√® attivit√† o meno**, con conseguente risparmio di energia e memoria allocata. Quando il pulsante tab non √® attivo, il browser semplicemente smette di chiamare la funzione. Zero cicli sprecati.<br />
√à intelligente perch√© invece di un loop infinito che gira sempre (anche quando non serve), il browser sincronizza il codice con il suo ciclo di rendering nativo.

#### Infinity: Il Pattern "Disattiva, Non Distruggere"

I checkpoint in questo gioco sono settati su `Infinity` quando vengono ottenuti. Ma perch√© non distruggere l'oggetto? Perch√© non eliminarlo del tutto dall'array?

**Con `claim()` abbiamo 4 livelli di difesa:**

```javascript
claim() {
  this.width = 0;           // 1. Geometria impossibile
  this.height = 0;          // 2. Zero dimensioni
  this.position.y = Infinity; // 3. Fuori dal mondo
  this.claimed = true;      // 4. Gi√† usato
}
```

Emerge chiaramente che non c'√® alcuna intenzione di eliminarli dall'array. Mi sono chiesto il perch√©: eliminandoli si libererebbe anche memoria preziosa, ho pensato. Ebbene, √® vero ma il prezzo da pagare sarebbe molto alto.

Ogni livello protegge da un diverso tipo di accesso. Infatti impostare **width e height a zero** protegge con la matematica: quando il codice esegue la collision detection, calcola se due rettangoli si sovrappongono, ma con dimensioni nulle la sovrapposizione diventa impossibile. Anche se il codice viene eseguito, i calcoli geometrici falliscono automaticamente.

Impostare **position.y a Infinity** protegge con lo spazio. Qualsiasi posizione del player (100, 500, persino 9999) sar√† sempre minore di `Infinity`. Il checkpoint √® letteralmente caduto fuori dal mondo del gioco, e qualsiasi confronto di posizione verticale fallisce.

Il **claimed = true** protegge con la logica ed √® il controllo pi√π efficiente. √à una guard clause, ovvero un controllo che esce subito dalla funzione, che dice al codice "questo checkpoint √® gi√† stato usato, non perdere tempo a controllare collisioni". Previene calcoli inutili permettendo un'uscita rapida dal controllo. In poche parole se per un bug futuro uno dei controlli fallisce, gli altri ti salvano.<br />

**La memoria risparmiata non vale i problemi creati:**

Eliminare con checkpoints.splice(index, 1) creerebbe pi√π problemi di quanti ne risolva. A 60fps, gli indici dell'array cambiano mentre stai iterando, causando possibili bug visivi. Ogni eliminazione inoltre richiede riallocazione di memoria e attiva il garbage collector (il sistema che pulisce automaticamente la memoria), senza contare che modificare l'array mentre altri lo leggono causa race condition (situazioni dove pi√π parti del codice accedono alla stessa risorsa contemporaneamente creando bug imprevedibili).<br />
Con `claim()` non c'√® allocazione, nessuna garbage collection, zero pause. Risulta pertanto decisamente migliore "spegnere/riaccendere" oggetti esistenti.

### Cosa Ho Imparato

**OOP Intermedia:**
- **Inheritance:** Estensione di classi base per creare varianti di oggetti
- **Composition:** Combinazione di oggetti pi√π semplici per creare comportamenti complessi
- **Encapsulation:** Nascondere dettagli implementativi dietro interfacce pulite
- **Object Pooling:** Riutilizzo di oggetti invece di crearli/distruggerli continuamente

**Game Development Patterns:**
- **Game Loop:** Ciclo principale update ‚Üí render sincronizzato con `requestAnimationFrame()`
- **Delta Time:** Gestione frame-rate indipendente per movimento fluido
- **State Management:** Gestione stati del gioco (menu, playing, paused, game over)
- **Collision Detection:** AABB (Axis-Aligned Bounding Box) per rilevare collisioni

**Canvas API:**
- `getContext('2d')` per ottenere il contesto di disegno
- `clearRect()` per pulire il canvas ad ogni frame
- `fillRect()` e `strokeRect()` per disegnare forme
- `drawImage()` per sprite e texture

**Physics Simulation:**
- Gravit√† come accelerazione costante verso il basso
- Velocit√† e accelerazione come vettori 2D
- Friction per rallentamento naturale
- Jump mechanics con impulso verticale

**Performance Optimization:**
- `requestAnimationFrame()` per sincronizzazione con refresh rate
- Riduzione chiamate al DOM
- Spatial partitioning per collision detection efficiente
- Flag booleani per early exit (guard clauses)

**Event Handling:**
- `keydown` e `keyup` per input tastiera
- Gestione input multipli simultanei (salto + movimento)
- Prevenzione comportamenti di default del browser

**Defensive Programming:**
- Ridondanza intenzionale per robustezza
- Guard clauses per prevenire calcoli inutili
- Boundary checking per evitare out-of-bounds
- Fallback values per situazioni edge case


<br />
Pronto ad iniziare il prossimo progetto!

***

**Prossimo progetto**: Ripassare il Pensiero Algoritmico costruendo un Dice Game
