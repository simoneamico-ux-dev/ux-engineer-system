---
sidebar_position: 3
title: DOM, Eventi e Asincronia
description: Manipolazione DOM, Eventi, Fetch API e LocalStorage.
---

# Parte III: DOM, Eventi e Network

JavaScript prende vita quando interagisce con il Browser. Qui impariamo a manipolare l'HTML (DOM), ascoltare le azioni dell'utente (Eventi) e comunicare con server esterni (Asincronia/Fetch).

---

## DOM e Interattivit√†

### 21. Caricamento Script

Se il DOM √® la "casa" (la struttura HTML) che il browser costruisce, il tuo file JavaScript √® l'"**impianto elettrico**" e gli "elettrodomestici" (l'interattivit√†). La domanda fondamentale √®: *quando* fai entrare l'elettricista?

#### Posizionamento Tag `<script>`

Pensa al browser come a un **operaio üë∑‚Äç‚ôÇÔ∏è che legge le istruzioni (il tuo file HTML) dall'alto verso il basso, una riga alla volta, e costruisce la casa**.

**Il Problema: `<script>` in `<head>` (Il Modo "Vecchio" Sbagliato)**

Se metti l'elettricista (`<script>`) nell'`<head>` (le fondamenta), succede un disastro:

1.  L'operaio legge `<html>`, legge `<head>`.
2.  Trova `<script src="app.js">`.
3.  **L'operaio si ferma.** Smette *immediatamente* di costruire la casa. Questo si chiama **render-blocking**.
4.  Va a cercare il furgone dell'elettricista (scarica il file `app.js`).
5.  Aspetta che l'elettricista faccia tutto il suo lavoro (esegue il file `app.js`).
6.  *Solo allora*, l'operaio torna a leggere le istruzioni e a costruire il `<body>` (i muri, le stanze, i mobili).

**Perch√© √® un disastro?**
Se nel tuo `app.js` c'√® scritto `document.getElementById("bottone")`, lo script viene eseguito al punto 5, ma il "bottone" (che √® nel `<body>`) non esiste ancora\! Verr√† costruito solo al punto 6. Il tuo script cercher√† un bottone in una casa senza muri. Risultato: `null` e un crash dell'applicazione.

**La Soluzione "Classica": `<script>` alla Fine del `<body>`**

Per decenni, la soluzione √® stata mettere l'elettricista come *ultima* cosa da fare:

```html
    ...
    <button id="bottone">Cliccami</button>
  </body>
  <script src="app.js"></script> </html>
```

  * **Come funziona:** L'operaio costruisce *tutta* la casa (`<head>`, `<body>`, `bottone`, tutto). Solo quando ha finito, come ultimissima istruzione, fa entrare l'elettricista.
  * **Vantaggio:** L'elettricista entra e *vede* tutta la casa gi√† costruita. `document.getElementById("bottone")` funziona al 100%.
  * **Svantaggio:** Se l'impianto elettrico √® enorme (un file JS da 5MB), l'utente vedr√† una casa *costruita ma spenta* (non interattiva) per secondi, finch√© il furgone dell'elettricista non finisce di scaricare.

-----

#### Attributo `defer` (Best Practice)

`defer` √® la soluzione moderna e intelligente. √à un'istruzione speciale che dai all'operaio.

Pensa a `defer` come a dire all'operaio: "Vedi quel furgone dell'elettricista? Inizia pure a fargli scaricare tutti i cavi *mentre tu continui a costruire i muri* (download non-blocking). Potr√† entrare a collegare i fili *solo quando avrai finito la struttura*, ma non preoccuparti di aspettare che abbia finito di lucidare le prese" (esegue dopo il parsing, prima di `DOMContentLoaded`).

Si usa cos√¨, nell'`<head>`:

```html
<head>
  ...
  <script src="app.js" defer></script>
</head>
```

  * **Come funziona:**
    1.  Il browser vede `<script defer>` nell'`<head>`.
    2.  **Inizia a scaricare `app.js` in sottofondo.**
    3.  **NON SI FERMA\!** Continua a costruire il `<body>` (non √® render-blocking).
    4.  Quando ha finito di *leggere* tutto l'HTML, esegue lo script `app.js` (che era gi√† pronto).
    5.  *Infine*, dichiara la casa pronta (evento `DOMContentLoaded`).

√à il meglio di entrambi i mondi: il download inizia presto, non blocca la costruzione della casa, e l'esecuzione √® garantita *dopo* che tutti gli elementi esistono.

**E `async`?**
`async` √® un altro attributo, ma √® un "elettricista indisciplinato". Scarica in parallelo, ma poi *interrompe* l'operaio ed esegue il codice *appena ha finito di scaricare*, anche se la casa √® a met√†. √à utile per script che non dipendono dal DOM (es. Google Analytics), ma `defer` √® quasi sempre la scelta migliore e pi√π sicura per i tuoi script principali.

-----

#### `window.onload` vs `DOMContentLoaded`

Questi sono **eventi**, sono i "permessi di lavoro" che dicono al tuo codice: "OK, ora puoi partire".

  * **`DOMContentLoaded` (Il Permesso dell'Architetto)**
    Questo evento scatta non appena l'operaio ha finito di *leggere le istruzioni* (HTML) e ha *costruito la struttura* (il DOM).

    *Analogia:* √à l'architetto che dice: "I muri portanti e il tetto sono su. La casa √® strutturalmente pronta."
    *Cosa *non* aspetta:* Non aspetta che i mobili siano consegnati (immagini), che le tende siano appese (CSS), o che gli inquilini arrivino (iframe).
    *Perch√© √® il migliore:* √à **veloce**. Il tuo JavaScript pu√≤ rendere la pagina interattiva *molto prima* che tutte le pesanti immagini finiscano di caricare.

    ```javascript
    // Si usa cos√¨:
    window.addEventListener('DOMContentLoaded', () => {
        // Il DOM √® pronto!
        const bottone = document.getElementById("bottone");
        bottone.addEventListener("click", () => alert("Ciao!"));
    });
    ```

    (Se usi `defer`, il tuo script viene eseguito *proprio prima* di questo evento, quindi spesso non hai nemmeno bisogno di aspettarlo\!)

  * **`window.onload` (Il Permesso del Proprietario di Casa)**
    Questo evento √® il "vecchio modo". √à molto pi√π lento e paziente. Scatta solo quando *letteralmente tutto* √® stato caricato.

    *Analogia:* √à il proprietario di casa che dice: "Ok, la casa √® finita, i mobili sono dentro, le tende sono appese, le luci funzionano e il giardino √® piantato. *Ora* potete entrare."
    *Il Problema:* Se hai una galleria di 50 immagini pesanti, il tuo JavaScript (e la tua app) rimarr√† "congelato" e non interattivo finch√© l'ultima immagine non √® stata scaricata. √à pessimo per l'esperienza utente (UX).

    ```javascript
    // Vecchio stile (da evitare se non per motivi specifici)
    window.onload = () => {
        // Tutto (incluse le immagini) √® caricato.
    };
    ```

**Regola Pratica:** Usa sempre `<script defer>` nell'`<head>`. Se per qualche motivo non puoi, metti il tuo codice dentro un listener `DOMContentLoaded`. Evita `window.onload` a meno che tu non debba *davvero* aspettare il caricamento delle immagini.




<br />
<br />
<br />
<br />









### 22. DOM Manipulation - Il Ponte con il Browser

Se il tuo file HTML √® il **progetto di una casa**, il **DOM (Document Object Model)** √® la **casa reale costruita dal browser**. √à una struttura *viva* e interattiva fatta di oggetti.

Il tuo JavaScript, quindi, non legge il file HTML. Il tuo JavaScript √® l'**arredatore d'interni, l'elettricista e la squadra di demolizione** che entrano nella casa *gi√† costruita* (il DOM) per spostare mobili, dipingere pareti e installare interruttori.

Manipolare il DOM √® l'atto di usare JavaScript per modificare questa casa.

#### Selezione di Elementi

Prima di poter dipingere un muro, devi *trovarlo*. La selezione √® come dare un indirizzo preciso alla tua squadra di lavoro.

  * **`getElementById(id)` (Il Pi√π Veloce)**
    Questo √® come avere il **codice fiscale** di un elemento. √à il modo pi√π veloce e diretto per trovare un elemento *unico*.

    ```javascript
    // HTML: <div id="header-principale">...</div>
    // Nota: non serve il '#' nel nome!
    const header = document.getElementById("header-principale");
    ```

  * **`querySelector(selettore)` (Il GPS Moderno)**
    Questo √® lo strumento pi√π flessibile e moderno. √à come un GPS: puoi dargli qualsiasi tipo di indirizzo (un selettore CSS) e lui trover√† il **primo** elemento che corrisponde.

    ```javascript
    // Trova per ID
    const header = document.querySelector("#header-principale");
    // Trova per Classe (il primo)
    const primoBottone = document.querySelector(".btn-primary");
    // Trova per Tag e Attributo
    const inputEmail = document.querySelector('input[type="email"]');
    ```

  * **`querySelectorAll(selettore)` (Il Censimento)**
    Simile al GPS, ma fa il censimento: crea una **lista** (una `NodeList`) di *tutti* gli elementi che corrispondono al selettore.

    ```javascript
    const tuttiIBottoni = document.querySelectorAll(".btn");
    // Ora puoi ciclarli:
    tuttiIBottoni.forEach(bottone => {
        bottone.style.color = "red";
    });
    ```

  * **`getElementsByClassName(classe)` (Il Vecchio Metodo "Live")**
    Questo metodo, come `getElementsByTagName`, √® il "vecchio modo". √à ancora utile, ma ha una stranezza importante: restituisce una `HTMLCollection`.

      * **La Stranezza (`HTMLCollection` Live):** Pensa a una `HTMLCollection` come a un **feed di una videocamera di sicurezza**. √à *live*. Se un nuovo elemento con quella classe viene aggiunto alla pagina *dopo* che hai eseguito il comando, apparir√† magicamente nella tua variabile\!
      * Una `NodeList` (da `querySelectorAll`) √® invece una **fotografia**. √à *statica*. Non si aggiorna se la pagina cambia.
      * **Svantaggio:** `HTMLCollection` non √® un vero array. Manca di metodi moderni come `.forEach()`.

  * **Convertire `NodeList` / `HTMLCollection` in Array**
    Per usare la potenza dei metodi array (`.map`, `.filter`, ecc.) su una `NodeList` o `HTMLCollection`, devi prima "trasformarla" in un vero array.
    *Analogo:* √à come prendere i dati grezzi dal feed della videocamera e stamparli su fogli di carta che puoi manipolare.

    ```javascript
    // Metodo Moderno (Spread Operator '...')
    const arrayDiElementi = [...document.getElementsByClassName("mia-classe")];

    // Metodo Formale
    const arrayDiElementi2 = Array.from(document.querySelectorAll(".btn"));

    // Ora puoi usare .map()!
    arrayDiElementi.map(el => el.textContent);
    ```

-----

#### Propriet√† vs Metodi (Distinzione)

Questa √® una distinzione filosofica fondamentale. Come distingui un *sostantivo* da un *verbo*?

  * **Propriet√† (I Sostantivi: "Cosa √®")**
    Sono i **dati** di un elemento. Sono valori che *leggi* o *assegni* usando il simbolo `=`. Non hanno le parentesi `()`.
    *Analogo:* `altezza`, `colore`, `peso`, `testo scritto`.

    ```javascript
    // Assegnare un valore a una propriet√†
    elemento.textContent = "Nuovo testo";
    input.value = "Valore predefinito";
    elemento.id = "nuovo-id";
    ```

  * **Metodi (I Verbi: "Cosa fa")**
    Sono le **azioni** che un elemento pu√≤ compiere. Li *chiami* usando le parentesi `()`.
    *Analogo:* `clicca!`, `aggiungiFiglio!`, `rimuoviti!`.

    ```javascript
    // Chiamare un metodo
    elemento.addEventListener("click", miaFunzione);
    elemento.remove();
    container.appendChild(nuovoElemento);
    ```

**L'Errore Ricorrente:** Confondere i due √® l'errore pi√π comune.

```javascript
// SBAGLIATO ‚ùå
elemento.textContent("Testo"); // Errore: textContent non √® una funzione!

// CORRETTO ‚úÖ
elemento.textContent = "Testo"; // √à una propriet√†, si assegna!

// SBAGLIATO ‚ùå
elemento.addEventListener = "click"; // Errore: addEventListener √® un metodo, va chiamato!

// CORRETTO ‚úÖ
elemento.addEventListener("click", () => {}); // Si chiama con ()!
```

-----

#### Attributi HTML vs Propriet√† DOM

Questo √® sottile. Qual √® la differenza tra il progetto e la casa reale?

  * **Attributo HTML (Il Progetto  blueprints):**
    √à quello che scrivi *letteralmente* nel tuo file `.html`. √à la *dichiarazione* iniziale.
    `<input type="text" value="Valore Iniziale">`

  * **Propriet√† DOM (La Realt√† fisica):**
    √à la propriet√† *viva* sull'oggetto JavaScript che il browser crea.
    `const input = document.querySelector("input");`
    `input.value; // "Valore Iniziale"`

Per la maggior parte del tempo, **le propriet√† e gli attributi sono "riflessi"**: se cambi uno, cambia anche l'altro.
`input.id = "test"` -\> L'HTML ora √® `<input id="test">`

**La Differenza Cruciale (con `value`):**
Cosa succede se l'utente *digita* nell'input?

1.  L'utente scrive "Ciao".
2.  La *propriet√†* `input.value` (la realt√†) diventa `"Ciao"`.
3.  L'*attributo* HTML (il progetto) **rimane `"Valore Iniziale"`**\!

L'attributo rappresenta il valore *di default* (quello che carichi), la propriet√† rappresenta il valore *attuale*.
**Regola Pratica:** Lavora sempre con le **propriet√†** (es. `input.value`, `input.id`, `input.className`). √à pi√π veloce e diretto. Usa `elemento.setAttribute()` solo per attributi personalizzati (come `data-*`) o quando vuoi modificare il "valore di default" del progetto.

-----

#### Creazione e Aggiunta Elementi

Non sei limitato a modificare ci√≤ che esiste. Puoi costruire stanze nuove\!

  * **`document.createElement(tag)` (La Fabbrica)**
    Questo comando crea un nuovo elemento *in memoria* (nel "magazzino"), non ancora sulla pagina.

    ```javascript
    const nuovoParagrafo = document.createElement("p");
    nuovoParagrafo.textContent = "Sono nuovo!";
    ```

    In questo momento, `nuovoParagrafo` esiste, ma l'utente non lo vede. √à un muro costruito in fabbrica, in attesa di essere installato.

  * **`container.appendChild(elemento)` (L'Installazione)**
    Questo √® l'atto di prendere l'elemento creato e "installarlo" nella casa. Lo aggiunge come **ultimo figlio** dell'elemento `container`.

    ```javascript
    // Trova la "stanza" dove vuoi installarlo
    const container = document.querySelector("#main-content");

    // Installa il muro
    container.appendChild(nuovoParagrafo);
    // ORA l'utente lo vede!
    ```

-----

#### Modifica del Contenuto

Ci sono diversi modi per cambiare cosa c'√® scritto in un elemento, ognuno con i suoi pro e contro.

  * **`textContent` (La Scelta Sicura ‚úÖ)**

      * **Cosa fa:** Imposta o legge solo il *testo puro* all'interno di un elemento. Ignora qualsiasi HTML.
      * **Analogo:** √à come scrivere su un muro con un pennarello. Se provi a scrivere `<strong>Ciao</strong>`, vedrai letteralmente il testo "\<strong\>Ciao\</strong\>" sul muro.
      * **Perch√© usarlo:** √à **veloce** e **sicuro al 100%** contro attacchi XSS (Cross-Site Scripting). Se un utente scrive codice malevolo (`<script>...`) nel suo nome, `textContent` lo tratter√† come testo innocuo.

    

    ```javascript
    elemento.textContent = "Ciao mondo!";
    ```

  * **`innerHTML` (La Scelta Potente e Pericolosa ‚ö†Ô∏è)**

      * **Cosa fa:** Imposta o legge l'*HTML completo* all'interno di un elemento.
      * **Analogo:** √à come una penna magica di *Harry Potter*. Se scrivi `<strong>Ciao</strong>`, crea *veramente* del testo in grassetto.
      * **Il Pericolo:** Se scrivi `<script>...` (magari proveniente da un input utente), la penna magica lo *eseguir√†*. Questo √® un enorme buco di sicurezza.
      * **Regola:** Usa `innerHTML` **SOLO** se 1) sei tu a scrivere l'HTML, o 2) la fonte √® 100% sicura. Non usarlo *mai* per mostrare dati inseriti da un utente.

  * **`innerText` (La Scelta Confusa ‚ùì)**

      * **Cosa fa:** √à il "cugino strano". Prova a leggere il testo *cos√¨ come lo vede l'utente*. Ignora elementi nascosti da CSS (`display: none`) e interpreta gli spazi e gli "a capo".
      * **Perch√© evitarlo:** √à molto pi√π lento di `textContent` (deve calcolare il layout CSS) e ha comportamenti imprevedibili. Il 99% delle volte, vuoi `textContent`.

  * **`insertAdjacentHTML(posizione, testoHTML)` (Il Chirurgo)**
    √à come `innerHTML`, ma pi√π preciso. Invece di rimpiazzare tutto, ti permette di "iniettare" HTML in 4 punti precisi rispetto all'elemento:

    1.  `'beforebegin'`: Prima dell'elemento.
    2.  `'afterbegin'`: Dentro l'elemento, prima di tutto il resto.
    3.  `'beforeend'`: Dentro l'elemento, dopo tutto il resto (come `appendChild`).
    4.  `'afterend'`: Dopo l'elemento.

-----

#### Modifica degli Stili

Come per il contenuto, hai due modi: quello diretto (e sporco) e quello pulito (e preferito).

  * **`style.property` (camelCase) (Il Modo Diretto/Sporco)**
    Ti permette di impostare stili *inline* (quelli nell'attributo `style="..."`).
    *Analogo:* Prendere un secchio di vernice e buttarlo sul muro con le mani. Funziona, ma √® un casino da pulire e sovrascrive tutto.

    ```javascript
    const elemento = document.querySelector("#avviso");

    // NOTA: 'background-color' (CSS) diventa 'backgroundColor' (JS)
    elemento.style.backgroundColor = "red";
    elemento.style.fontSize = "20px";
    elemento.style.display = "block"; // Per mostrare
    elemento.style.display = "none";  // Per nascondere
    ```

    **Svantaggio:** Crea stili inline, che hanno una "specificit√†" altissima e sono difficili da sovrascrivere con i tuoi file CSS. Mescola la logica (JS) con la presentazione (CSS).

  * **`classList` (La Best Practice ‚úÖ)**
    Questo √® il modo professionale.
    *Analogo:* Invece di verniciare il muro, attacchi un'etichetta al muro che dice "Muro-Importante". Poi, in un foglio di stile (CSS) separato, definisci `.Muro-Importante { background-color: red; }`.
    Questo separa le responsabilit√†: **JavaScript gestisce lo *stato*** (l'etichetta), **CSS gestisce l'*aspetto***.

    ```javascript
    // CSS:
    // .is-hidden { display: none; }
    // .is-active { color: blue; }

    // JS:
    elemento.classList.add("is-active");      // Aggiunge la classe
    elemento.classList.remove("is-hidden");   // Rimuove la classe
    elemento.classList.toggle("evidenziato"); // Aggiunge se non c'√®, rimuove se c'√®
    elemento.classList.contains("is-active"); // true
    ```

    √à pi√π pulito, pi√π facile da manutenere e non incasina la specificit√† CSS.

-----

#### Modifica Attributi/Propriet√†

  * **Propriet√† `disabled` (true/false)**
    Questa √® una propriet√† booleana fondamentale per i form. √à l'interruttore On/Off per un input.

    ```javascript
    const mioBottone = document.querySelector("#submit-btn");

    // Per disabilitare (l'utente non pu√≤ cliccare)
    mioBottone.disabled = true; // Appare grigio, non cliccabile

    // Per riabilitare
    mioBottone.disabled = false;
    ```

    Quando un input √® `disabled`, il suo valore **non viene inviato** con il form.

  * **`disabled` vs `readonly`**
    Questa √® una distinzione chiave per la UX:

      * **`disabled`:** L'elemento √® **spento**. L'utente non pu√≤ cliccarci, non pu√≤ farci focus (con Tab), e il suo valore non viene inviato. √à un muro.
      * **`readonly`:** L'elemento √® **bloccato in sola lettura**. L'utente pu√≤ vederlo, pu√≤ farci focus (e copiarne il testo), ma non pu√≤ modificarlo. Il suo valore **viene inviato** con il form.

    *Analogo:* `disabled` √® una porta sbarrata. `readonly` √® una porta di vetro chiusa a chiave (puoi guardare dentro, ma non toccare).

-----

#### Navigazione DOM

  * **Selettore CSS: Child Combinator (`>`)**
    Questo √® uno strumento di *selezione* potente.

      * **`div p` (Selettore Discendente - lo Spazio):**
        *Analogo:* "Trova tutti i `p` che sono *discendenti* di un `div`". Questo include figli, nipoti, pronipoti... chiunque viva dentro il `div`.
      * **`div > p` (Selettore Figlio - il `>`):**
        *Analogo:* "Trova tutti i `p` che sono *figli diretti* (immediati) di un `div`". Questo ignora i nipoti. √à molto pi√π specifico.

    *Perch√© usarlo?* Previene che il tuo stile o script "trapeli" in componenti annidati pi√π profondamente. Ti d√† un controllo chirurgico sulla selezione.




<br />
<br />
<br />
<br />









### 23. Eventi - Ascoltare e Reagire

Gli eventi sono il sistema nervoso della tua applicazione. Ogni click, movimento, pressione di tasto √® un segnale che puoi intercettare per far scattare una logica. Senza eventi, il DOM √® solo una scultura statica. Con gli eventi, diventa un robot interattivo.

#### `onclick` vs `addEventListener` - Due Filosofie

Esistono due modi per "collegare un filo" a un sensore (come un bottone).

  * **`onclick` (Il Modo Vecchio / La Linea Telefonica Singola)**
    Questo √® un attributo (o propriet√†) dell'elemento. √à semplice e diretto.

    ```javascript
    const bottone = document.querySelector("#mio-bottone");

    bottone.onclick = function() {
        console.log("Cliccato!");
    };
    ```

    *Il Problema:* √à come una **linea telefonica singola**. Puoi collegare *solo una* funzione a `onclick`. Se provi a collegarne un'altra, la seconda *sovrascrive* la prima.

  * **`addEventListener` (Il Modo Moderno / Il Centralino)**
    Questo √® un *metodo*. √à come un **centralino telefonico**: puoi "aggiungere" (`add`) pi√π "ascoltatori" (`Listener`) allo stesso evento (`click`).

    ```javascript
    // Aggiungi il primo ascoltatore
    bottone.addEventListener("click", function() {
        console.log("Primo gestore: salvo i dati.");
    });

    // Aggiungi un secondo ascoltatore
    bottone.addEventListener("click", function() {
        console.log("Secondo gestore: invio analytics.");
    });
    ```

    Entrambi vengono eseguiti\! √à pi√π pulito, pi√π flessibile e ti permette di *rimuovere* (`removeEventListener`) un gestore specifico senza toccare gli altri.
    **Regola:** Usa `addEventListener` sempre. √à la best practice professionale.

-----

#### Riferimento (`fn`) vs Esecuzione (`fn()`)

Questo √® l'errore concettuale pi√π comune e *critico* da capire.

*Analogia:* Pensa di dover dare un'istruzione a un assistente.

  * **Riferimento (`miaFunzione`):**
    `bottone.addEventListener("click", miaFunzione);`
    Questo √® come dare all'assistente un **manuale di istruzioni** (la funzione `miaFunzione`) e dirgli: "Quando il telefono squilla (l'evento `click`), *allora* leggi ed esegui le istruzioni in questo manuale." Stai passando la *ricetta*, non la *torta*.

  * **Esecuzione (`miaFunzione()`):**
    `bottone.addEventListener("click", miaFunzione());` // SBAGLIATO ‚ùå
    Questo √® come **cucinare la torta *subito***, dare la torta (il *risultato* della funzione, che spesso √® `undefined`) all'assistente e dirgli: "Quando il telefono squilla, dai al cliente questa torta".
    JavaScript *esegue* `miaFunzione()` *immediatamente* (una sola volta, al caricamento della pagina) e assegna il suo risultato (`undefined`) al listener. Il click non far√† mai nulla.

**Regola:** Quando assegni un gestore di eventi, devi passare il **nome della funzione (il riferimento)**, non il risultato della sua esecuzione.

-----

#### L'Oggetto `event`

Quando un evento si scatena (l'utente clicca), il browser non si limita a eseguire la tua funzione. La esegue passandole automaticamente un **oggetto speciale** come primo argomento. Pensa a questo oggetto (`e` o `event`) come al **report dettagliato dell'incidente**.

```javascript
bottone.addEventListener("click", function(event) { // Eccolo!
    console.log(event); // Ispezionalo! √à pieno di informazioni
    
    // Informazioni utili:
    console.log(event.type); // "click"
    console.log(event.timeStamp); // Quando √® successo
    console.log(event.ctrlKey); // Ha premuto Ctrl mentre cliccava?
    console.log(event.clientX, event.clientY); // Dove ha cliccato
});
```

#### `e.target`

Questa √® la propriet√† **pi√π importante** dell'oggetto `event`.
*Analogia:* Se l'oggetto `event` √® il report dell'allarme antincendio, `e.target` √® **il sensore specifico che √® scattato**.
√à un riferimento diretto all'elemento HTML che ha *originato* l'evento.

```javascript
// 'e.target' √® il bottone esatto che √® stato cliccato
container.addEventListener("click", function(e) {
    console.log(e.target); // Mostra l'elemento HTML cliccato
});
```

#### `e.preventDefault()`

Questo √® il tuo **freno di emergenza** per fermare il comportamento *predefinito* del browser.
Certi elementi HTML hanno un "lavoro" predefinito:

  * Cliccare su un link (`<a>`) ti fa cambiare pagina.
  * Premere "Invio" su un form (`<form>`) fa ricaricare la pagina.

`e.preventDefault()` dice al browser: "Grazie, ma **non farlo**. Lascia gestire a me (JavaScript)."

```javascript
const mioForm = document.querySelector("#mio-form");

mioForm.addEventListener("submit", function(e) {
    // 1. FERMA IL REFRESH DELLA PAGINA!
    e.preventDefault(); 
    
    // 2. Ora posso prendere i dati con JS senza che la pagina sparisca
    const nome = document.querySelector("#nome").value;
    console.log(`Ciao, ${nome}!`);
});
```

-----

#### Event Delegation - L'Ascoltatore Intelligente

Questo √® un pattern fondamentale per la performance.

  * **Il Problema:** Immagina di avere una lista (un `<ul>`) con 1000 elementi (`<li>`). Devi aggiungere un listener a *ognuno* di essi? Sarebbe un incubo di performance (1000 fili collegati) e non funzionerebbe per i nuovi `<li>` aggiunti dopo.
  * **La Soluzione:** Sfrutta il "Bubbling" (gli eventi "risalgono" come bolle). Metti *un solo* ascoltatore sul **genitore** (`<ul>`).
  * **Analogia:** Invece di mettere una guardia del corpo su ogni persona in una stanza (`<li>`), metti **un solo buttafuori all'unica porta d'uscita (`<ul>`)**.



```javascript
const lista = document.querySelector("#lista-spesa");

// Un solo listener sul genitore!
lista.addEventListener("click", function(e) {
    
    // 'e.target' √® il sensore che ha scatenato (l'<li> cliccato)
    
    // Chiediamo al "buttafuori":
    // "L'elemento cliccato (e.target) √® un LI?"
    if (e.target.tagName === "LI") {
        console.log("Hai cliccato su:", e.target.textContent);
        e.target.classList.toggle("comprato");
    }
});
```

**Vantaggi:**

1.  **Performance:** Un solo listener invece di 1000.
2.  **Dinamicit√†:** Funziona *automaticamente* anche per i nuovi `<li>` che aggiungi in futuro\!

-----

#### Il Problema di Contesto: `this` e `addEventListener`

Questo √® un problema avanzato che colpisce quando usi le Classi (OOP).
`this` √® una parola chiave "camaleontica", il suo significato cambia in base a *chi* sta chiamando la funzione.

  * **Il Problema:**
    Quando `addEventListener` esegue la tua funzione (es. `this.clearCart`), la esegue *lui* (il listener del bottone). Di conseguenza, all'interno della funzione, `this` **non sar√† pi√π il tuo carrello**, ma diventer√† **il bottone stesso**\!



```javascript
class Carrello {
    constructor() {
        this.items = ["mela"];
        const btn = document.querySelector("#svuota");
        
        // SBAGLIATO ‚ùå
        btn.addEventListener("click", this.svuotaCarrello);
    }
    
    svuotaCarrello() {
        console.log(this); // 'this' qui sar√† il <button>, non il Carrello!
        // this.items.length = 0; // CRASH! Il bottone non ha 'items'.
    }
}
```

#### Soluzione: `.bind(this)`

`.bind()` √® come creare un "clone" della tua funzione con il `this` **permanentemente bloccato**.
*Analogia:* √à come dare al tuo assistente (il listener) un manuale di istruzioni (la funzione) con una **targhetta con il tuo nome (`this`) incollata sopra con la supercolla**. Non importa chi legger√† quel manuale, sapr√† sempre che "io" si riferisce a *te* (l'istanza del `Carrello`).

```javascript
// ...dentro il constructor...
// CORRETTO ‚úÖ
btn.addEventListener("click", this.svuotaCarrello.bind(this));
```

`this.svuotaCarrello.bind(this)` crea una *nuova* funzione che, quando chiamata, avr√† `this` impostato correttamente sul `Carrello`.

#### Soluzione: Arrow Function Wrapper

Questo √® il modo pi√π moderno e spesso preferito.
Le **Arrow Function (`=>`)** non hanno un loro `this`\! "Ereditano" il `this` del luogo in cui sono state *scritte*.

*Analogia:* √à come se tu (il `constructor`) dicessi al tuo assistente: "Quando il telefono suona, non chiamare tu *direttamente* il magazzino. Chiama *me*, e poi *io* chiamer√≤ il magazzino."

```javascript
// ...dentro il constructor...
// CORRETTO (e moderno) ‚úÖ
btn.addEventListener("click", () => {
    // Questa √® una arrow function
    // Il 'this' qui dentro √® lo stesso 'this' del constructor
    // (cio√® l'istanza del Carrello)
    this.svuotaCarrello(); 
});
```

-----

#### Eventi Speciali

  * **`keydown` vs `keypress` (Deprecato) vs `keyup`**
    *Analogia: La Macchina da Scrivere*

      * **`keydown` (Il Tasto Scende):** Il momento in cui il tuo dito *preme fisicamente* il tasto verso il basso. Rileva **TUTTI** i tasti (Frecce, Shift, Ctrl, 'a'). **Usa questo** per i giochi e i controlli.
      * **`keyup` (Il Tasto Risale):** Il momento in cui *rilasci* il tasto.
      * **`keypress` (Il Carattere Appare):** Il momento in cui la pressione produce un *carattere* sulla carta. Ignora Frecce, Shift, Ctrl. **√à DEPRECATO** (obsoleto), non usarlo.

  * **`change` vs `input` (UX Feedback)**
    Questa √® una distinzione *cruciale* per la User Experience (UX).

      * **`change` (Quando hai "finito"):** Si attiva solo quando l'utente *conferma* la modifica (di solito cliccando *fuori* dall'input box o premendo Invio).
          * *Uso:* Validazione finale, quando l'utente ha finito di scrivere.
      * **`input` (In Tempo Reale):** Si attiva *ad ogni singolo tasto premuto*. Se l'utente scrive "Ciao", l'evento si attiva 4 volte.
          * *Uso:* Barre di ricerca istantanee, contatori di caratteri, filtri live.

  * **`submit`**
    Questo evento si attiva solo sull'elemento `<form>`, quando l'utente prova a inviarlo (premendo Invio o cliccando un `<button type="submit">`). √à qui che devi usare `e.preventDefault()`.

  * **`DOMContentLoaded`**
    (Vedi Sezione 9) L'evento che scatta quando l'HTML √® stato costruito, ma prima che le immagini siano caricate. √à il "via" standard per il tuo codice.

-----

#### Interazioni del Browser

  * **`confirm()` (Dialogo Bloccante)**
    Questo *non* √® un evento, ma una funzione che *crea* un evento di interazione.
    `confirm("Sei sicuro?")` mostra una finestra di dialogo nativa (e bruttina) che **blocca l'esecuzione** di *tutto* il JavaScript finch√© l'utente non fa una scelta.

    ```javascript
    console.log("Prima della conferma");

    const utenteHaConfermato = confirm("Vuoi davvero eliminare tutto?");
    // Il codice si ferma qui e aspetta...

    if (utenteHaConfermato) { // 'confirm' restituisce true (OK) o false (Annulla)
        console.log("Eliminazione in corso...");
    } else {
        console.log("Annullato.");
    }
    ```

    *Attenzione:* Blocca l'intera interfaccia. Le app moderne evitano `confirm` e usano modali personalizzati (come `<dialog>`) per un'esperienza migliore.




<br />
<br />
<br />
<br />









### 24. Dialog e Modali

Per decenni, per mostrare un "pop-up" (un *modale*), gli sviluppatori hanno dovuto combattere con `div` posizionati in modo assoluto, `z-index`, div semi-trasparenti per lo sfondo (`backdrop`) e complicate logiche JavaScript per "intrappolare" il focus della tastiera. Era un incubo di accessibilit√† e manutenzione.

L'elemento `<dialog>` √® la **soluzione nativa e moderna** del browser a questo problema. √à come se il browser ti fornisse un **palco portatile** pre-costruito.

#### `<dialog>` (L'Elemento Palcoscenico)

Pensa all'elemento `<dialog>` come a un palco che tieni nel backstage (nascosto) del tuo teatro (la pagina web).

```html
<dialog id="mio-dialogo">
  <h2>Titolo del Modale</h2>
  <p>Questo √® un messaggio importante.</p>
  <button id="chiudi-btn">Chiudi</button>
  <form method="dialog">
      <button value="confermato">Conferma</button>
      <button value="annullato">Annulla</button>
  </form>
</dialog>

<button id="apri-btn">Apri Modale</button>
```

Di base, questo elemento non fa nulla ed √® invisibile. Per farlo "salire sul palco", hai due metodi JavaScript, ed √® qui che la magia accade.

#### `showModal()` (Modale) vs `show()` (Non-Modale)

Questa √® la distinzione fondamentale. Stai portando l'attore sul palco, ma come?

  * **`showModal()` (Il Faro da Palcoscenico üî¶)**
    Questo √® il metodo che vorrai usare il 99% delle volte. √à il "vero" modale.

    *Analogo:* √à come **accendere un faro (spotlight) sull'attore** (`<dialog>`) e **abbassare completamente le luci su tutto il resto della pagina** (il *backdrop*).

    ```javascript
    const dialog = document.querySelector("#mio-dialogo");
    const apriBtn = document.querySelector("#apri-btn");

    apriBtn.addEventListener("click", () => {
        dialog.showModal();
    });
    ```

    **Cosa fa `showModal()` automaticamente per te:**

    1.  **Crea un Backdrop:** Aggiunge uno sfondo semi-trasparente (`::backdrop`) che copre il resto della pagina.
    2.  **Blocca l'Interazione:** L'utente *non pu√≤* cliccare o interagire con nient'altro sulla pagina (link, bottoni, ecc.) finch√© il modale non √® chiuso.
    3.  **Intrappola il Focus (Focus Trap):** Se l'utente preme `Tab`, il focus della tastiera rimane *intrappolato* all'interno del modale, ciclando solo tra i suoi elementi interattivi. √à un requisito fondamentale per l'accessibilit√† (a11y).
    4.  **Si chiude con `Esc`:** L'utente pu√≤ chiudere il modale semplicemente premendo il tasto `Esc`.

  * **`show()` (Il Pannello Informativo üì∞)**
    Questo metodo √® per un "non-modale" o "dialogo".

    *Analogo:* √à come un **pannello informativo** o un *sottotitolo* che appare in un angolo dello schermo (come una chat o un avviso di cookie). Puoi ancora interagire con il resto della pagina mentre √® visibile.

    ```javascript
    // Meno comune
    dialog.show();
    ```

    **Cosa *NON* fa `show()`:**

    1.  Nessun backdrop.
    2.  Nessun blocco dell'interazione.
    3.  Nessun focus trap.
    4.  Il tasto `Esc` *non* lo chiude.

**Regola:** Usa `showModal()` per qualsiasi cosa che richieda l'attenzione *esclusiva* dell'utente (conferme, form, avvisi). Usa `show()` per notifiche non invadenti (raro).

-----

#### `close()` (Uscita di Scena)

Questo √® il metodo per chiudere programmaticamente il dialogo.

*Analogo:* √à l'attore che fa l'inchino e **esce di scena**.

```javascript
const dialog = document.querySelector("#mio-dialogo");
const chiudiBtn = document.querySelector("#chiudi-btn");

// Modo 1: Chiudere con JavaScript
chiudiBtn.addEventListener("click", () => {
    dialog.close(); // Chiude il dialogo
});

// Modo 2: Il trucco del Form (pi√π pulito!)
// Qualsiasi <button> dentro un <form method="dialog">
// chiuder√† automaticamente il dialogo quando cliccato.
// NON serve JavaScript!
```

**Il Superpotere: Il `returnValue`**
Quando chiudi un dialogo, puoi opzionalmente passare un "messaggio di chiusura" (un `returnValue`).

*Analogo:* √à come se l'attore, uscendo di scena, ti consegnasse un **bigliettino** con sopra scritto cosa ha deciso ("confermato" o "annullato").

```html
<form method="dialog">
    <button value="confermato">Conferma</button>
    <button value="annullato">Annulla</button>
</form>
```

```javascript
// JS per "ascoltare" il bigliettino
const dialog = document.querySelector("#mio-dialogo");

// Ascolta l'evento 'close'
dialog.addEventListener("close", () => {
    // Leggi il bigliettino!
    console.log("Il dialogo si √® chiuso. Valore restituito:", dialog.returnValue);
    
    if (dialog.returnValue === "confermato") {
        console.log("L'utente ha confermato!");
        //...esegui la logica di conferma...
    } else {
        console.log("L'utente ha annullato.");
    }
});
```

Se l'utente preme `Esc`, il `returnValue` sar√† una stringa vuota `""` (o il valore di un eventuale bottone `cancel`).

L'elemento `<dialog>` elimina da solo il 90% del lavoro sporco e dei bug che affliggevano i modali "fatti a mano", gestendo focus, backdrop e chiusura in modo nativo e accessibile.

<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />












## Asincronia e Comunicazione Server

### 25. Il Concetto - Sincrono vs Asincrono

**Cosa fa**: Definisce *come* il codice viene eseguito nel tempo.

**Il problema**: JavaScript √® "single-threaded" (ha una sola mano). Se gli fai fare un calcolo lungo in modo **sincrono**, blocchi tutto il sito finch√© non finisce.

**Analogia**: Il Tostapane üçû

* **Sincrono (Blocking)**: Metti il pane, e resti *immobile* a fissare il tostapane per 2 minuti finch√© non scatta. Non puoi fare altro. (Il sito si blocca).
* **Asincrono (Non-blocking)**: Metti il pane, premi la leva, e intanto vai a prendere il latte e il caff√®. Quando il tostapane fa *TLIN!* (callback/promise), torni a prendere il pane. (Il sito rimane fluido).



<br />
<br />
<br />
<br />









### 26. `fetch()` - L'ordine al ristorante

**Cosa fa**: Chiede dati a un server esterno (es. meteo, utenti, prodotti).

**Il segreto**: `fetch` √® un processo a **due fasi**. Non ricevi subito i dati, ricevi una promessa di riceverli!

```javascript
fetch('https://api.esempio.com/pizza')
  .then(res => res.json())       // 1. Apri la scatola (Parsing)
  .then(data => console.log(data)) // 2. Mangia il contenuto (Uso dati)
  .catch(err => console.error(err)); // Gestione errori

```

**Analogia**: Il doppio ordine al fast food üçî

1. **Primo step (La Rete)**: Ordini e ti danno un **cercapersone**. Quando vibra, ti danno il vassoio con una **scatola chiusa** (`res`). Non vedi ancora il panino, sai solo che la scatola √® arrivata (o se la cucina √® esplosa `404/500`).
2. **Secondo step (Il Parsing)**: Devi aprire la scatola e scartare il panino. Richiede tempo! Questo √® il `res.json()`. Quando hai finito, hai finalmente il cibo vero (`data`).



<br />
<br />
<br />
<br />









### 27. `async` / `await` - Il cambio automatico

**Cosa fa**: √à il modo moderno di gestire le attese. Fa sembrare il codice asincrono (complesso) come se fosse codice sincrono (lineare e semplice).

```javascript
// Prima: Cambio Manuale (.then .then) üò´
fetch(url).then(res => res.json()).then(data => ...);

// Dopo: Cambio Automatico (async/await) üòé
async function prendiDati() {
    // "await" mette in pausa la funzione finch√© la promessa non si risolve
    const res = await fetch(url);      // Aspetta la scatola
    const data = await res.json();     // Aspetta di aprirla
    console.log(data);                 // Fatto!
}

```

**Analogia**:

* `.then()` √® come guidare col **cambio manuale**: devi gestire ogni marcia, frizione e passaggio di dati. Potente, ma faticoso.
* `await` √® il **cambio automatico**: tu premi l'acceleratore e il motore gestisce le pause e i cambi di stato per te.


<br />
<br />
<br />
<br />









### 28. `try...catch` - Il Trapezista

**Cosa fa**: √à la rete di sicurezza universale. Cattura **qualsiasi** errore, sia che venga dalla rete (asincrono), sia che sia un tuo errore di battitura (sincrono).

```javascript
async function operazione() {
    try {
        // Il trapezista salta...
        const res = await fetch(url);
        const data = await res.json();
        
        // Anche se sbagli tu qui, il catch lo prende!
        const nome = data.user.toUpperCase(); 
    } catch (err) {
        // ...la rete lo prende se cade!
        console.error("Errore tecnico:", err); // Per te
        alert("Impossibile caricare i dati");  // Per l'utente
    }
}

```

**Analogia**:

* `try { ... }`: √à il trapezista che tenta il triplo salto mortale.
* `catch { ... }`: √à la rete sotto. Se il trapezista scivola (fetch fallisce) O se ha un crampo (bug nel codice), cade sicuro nella rete invece di schiantarsi al suolo (crashare l'app).

**Regola d'oro**: Gestisci due livelli di errori!

1. **Console (Sviluppatore)**: La spia del motore üîß (`console.error` con i dettagli tecnici).
2. **UI (Utente)**: La spia sul cruscotto üí° (Messaggio gentile: "C'√® stato un problema, riprova").


<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />










## Persistenza dei Dati e Storage

### 29. localStorage - La Memoria a Lungo Termine

Finora, tutte le nostre variabili (`let`, `const`) hanno vissuto nella **RAM** del browser. Sono come appunti scritti su una lavagna bianca: veloci, utili, ma appena l'utente *aggiorna* o *chiude* la pagina (`F5`), la lavagna viene pulita. Tutto svanisce.

Il **`localStorage`** √® una tecnologia completamente diversa. √à la **memoria a lungo termine** del tuo sito web.

*Analogo:* Non √® una lavagna bianca, √® un **cassetto della scrivania** (o una cassaforte) incorporato nel browser dell'utente. I dati che metti qui dentro (impostazioni, punteggi, un carrello della spesa) **sopravvivono** ai refresh, alle chiusure del browser e persino allo spegnimento del computer. Quando l'utente torna sul tuo sito dopo una settimana, i dati sono ancora l√¨ ad aspettarlo.

#### Il Problema Fondamentale: Il Muro delle Stringhe

C'√® una regola d'oro, un "per√≤" grande come una casa, che non puoi mai dimenticare: **il `localStorage` pu√≤ memorizzare solo ed esclusivamente stringhe di testo.**

Pensa al `localStorage` come a un **vecchio fax**. Un fax non pu√≤ spedire un *pacco* (un oggetto), un *mazzo di carte* (un array), o un *interruttore* (un booleano). Pu√≤ spedire solo un *foglio di carta piatto* (una stringa).

Questo √® l'errore che fanno tutti all'inizio:

```javascript
// Questo √® quello che vorresti fare
const utente = {
    nome: "Alice",
    livello: 12,
    isPremium: true
};

// ERRORE COMUNE: Salvare direttamente ‚ùå
localStorage.setItem('utente', utente);

// Cosa hai salvato davvero?
const salvato = localStorage.getItem('utente');
console.log(salvato); // Output: "[object Object]"
```

Hai perso *tutto*\! Il nome, il livello, tutto √® stato schiacciato in quella stringa inutile, `"[object Object]"`. √à come aver provato a mandare via fax un pacco: dall'altra parte √® arrivato solo un foglio nero e illeggibile.

-----

#### JSON - Il Traduttore Universale dei Dati

Come risolviamo il problema del fax? Non spediamo il pacco, ma spediamo un **documento che *descrive* il contenuto del pacco**, pezzo per pezzo.

**JSON (JavaScript Object Notation)** √® il linguaggio universale per *descrivere* dati complessi (oggetti, array) in un formato di testo piatto (una stringa).

*Analogo:* JSON √® il **manuale di istruzioni IKEA**. Prende un mobile complesso (il tuo oggetto) e lo "appiattisce" in un manuale (la stringa). Chiunque riceva il manuale pu√≤ "ricostruire" un mobile identico.

Ci sono due comandi principali che devi conoscere:

#### `JSON.stringify()` (Lo Smontatore/Appiattitore)

`JSON.stringify()` (letteralmente "string-if√†", *trasforma in stringa*) √® il processo di "smontaggio". Prende il tuo oggetto o array JavaScript vivo e lo converte in una stringa di testo JSON che lo descrive perfettamente.

*Analogo:* √à la macchina che **smonta i mobili IKEA** e li impacchetta nella scatola piatta.

```javascript
const impostazioni = {
    tema: 'dark',
    notifiche: true,
    volume: 80,
    suoni: {
        click: true,
        notifica: false
    }
};

// La magia dello "smontaggio"
const stringaJSON = JSON.stringify(impostazioni);

console.log(stringaJSON);
// Output (una singola, lunga stringa di testo):
// '{"tema":"dark","notifiche":true,"volume":80,"suoni":{"click":true,"notifica":false}}'

// ORA puoi salvarlo! √à solo testo!
localStorage.setItem('settings', stringaJSON);
```

#### `JSON.parse()` (Il Rimontatore/Ricostruttore)

`JSON.parse()` √® l'operazione inversa. Prende una stringa di testo JSON (il "manuale") e la "analizza" (*parse*), ricostruendo l'oggetto o l'array JavaScript originale.

*Analogo:* √à l'atto di **seguire le istruzioni IKEA** per rimontare il mobile.

```javascript
// Recupera la stringa dal localStorage (il "manuale")
const stringaSalvata = localStorage.getItem('settings');
console.log(typeof stringaSalvata); // "string" - √® ancora solo testo!

// La magia del "rimontaggio"
const impostazioniRicostruite = JSON.parse(stringaSalvata);
console.log(typeof impostazioniRicostruite); // "object" - √® tornato un oggetto!

// Ora puoi usarlo come un normale oggetto JavaScript
if (impostazioniRicostruite.tema === 'dark') {
    document.body.classList.add('dark-mode');
}
console.log(impostazioniRicostruite.volume); // 80
```

-----

#### Il Ciclo di Vita Completo dei Dati

Questo √® il flusso che userai sempre:

```javascript
// FASE 1: CREAZIONE - Hai i tuoi dati JavaScript (un array)
const todoList = [
    { id: 1, testo: "Imparare localStorage" },
    { id: 2, testo: "Conquistare il mondo" }
];

// FASE 2: SERIALIZZAZIONE (Smontaggio) - Trasformi in stringa
const todoListStringa = JSON.stringify(todoList);

// FASE 3: SALVATAGGIO (setItem) - Metti la stringa nel "cassetto"
localStorage.setItem('todos', todoListStringa);

// ... L'utente chiude il browser, spegne il PC, va a dormire ...
// ... Il giorno dopo riapre il tuo sito ...

// FASE 4: RECUPERO (getItem) - Leggi dal "cassetto"
const todoListRecuperata = localStorage.getItem('todos');
// √à ancora una stringa! '[{"id":1,...}, ...]'

// FASE 5: DESERIALIZZAZIONE (Rimontaggio) - Ritrasformi in oggetto
const todoListRicostruita = JSON.parse(todoListRecuperata);

// FASE 6: USO - Lavori con i dati come sempre
console.log(todoListRicostruita[0].testo); // "Imparare localStorage"
```

-----

#### Gestire il Primo Avvio - Il Pattern Robusto

Cosa succede quando un utente visita il tuo sito *per la prima volta*?
Il "cassetto" √® vuoto. `localStorage.getItem('todos')` restituir√† `null`.

Se provi a fare `JSON.parse(null)`, il risultato √® `null` (non un errore). Ma se ci provi a fare `.push()`... CRASH.

Devi *sempre* fornire un valore di **default** (un "Piano B").

  * **Il Pattern con `||` (OR) - Il Pi√π Comune**
    Questo √® il modo pi√π rapido e conciso, che sfrutta i valori "falsy".

    ```javascript
    // Prova a parsare i dati salvati.
    // Se `getItem` restituisce `null`, `JSON.parse(null)` restituisce `null`.
    // `null` √® "falsy", quindi l'operatore OR (||) sceglie il "Piano B": un array vuoto.
    const tasks = JSON.parse(localStorage.getItem("data")) || [];
    ```

  * **Il Pattern `try-catch` - Il Pi√π Sicuro**
    Cosa succede se i dati nel `localStorage` sono *corrotti*? (es. una stringa JSON scritta male: `"{nome: 'mario'}"`). In questo caso, `JSON.parse()` **lancer√† un errore** e far√† crashare la tua app.
    Il `try-catch` √® la rete di sicurezza che previene questo.

    ```javascript
    function caricaDatiSicuri(key, valoreDefault) {
        try {
            const item = localStorage.getItem(key);
            // Se 'item' √® null, il ternario restituisce il default.
            // Se 'item' c'√®, prova a parsarlo.
            return item ? JSON.parse(item) : valoreDefault;
        } catch (error) {
            // Se il parse fallisce (dati corrotti),
            // stampa l'errore e restituisci il default.
            console.error(`Errore nel parsing di ${key} dal localStorage:`, error);
            return valoreDefault;
        }
    }

    // Uso:
    const tasks = caricaDatiSicuri('data', []);
    ```

-----

#### Ispezionare il localStorage nei DevTools

Non devi lavorare alla cieca\! Il browser ti d√† una **finestra segreta** per guardare dentro il cassetto del `localStorage`.

*Analogo:* √à come avere una **visione a raggi X** sulla scrivania dell'utente.

**Come Accedere (in Chrome/Edge/Firefox):**

1.  **Apri i DevTools**: `F12` (o click destro \> Ispeziona)
2.  **Trova la sezione Storage**:
      * **Chrome/Edge**: Tab "**Application**" ‚Üí Storage ‚Üí Local Storage
      * **Firefox**: Tab "**Storage**" ‚Üí Local Storage
3.  Clicca sul tuo dominio (es. `http://127.0.0.1:5500`)

Vedrai una tabella semplicissima:
| Key | Value |
|---|---|
| `settings` | `{"tema":"dark","notifiche":true,...}` |
| `todos` | `[{"id":1,"testo":"..."},...]` |

Da qui puoi **verificare**, **modificare** al volo i valori (doppio click), **eliminare** singole chiavi (`Canc`) o **svuotare tutto** (icona cestino). √à lo strumento n.1 per il debug della persistenza.

-----

#### I Limiti del localStorage - Le Regole del Gioco

Il `localStorage` √® fantastico, ma non √® un database infinito. Ha regole e limiti precisi:

1.  **Solo Stringhe:** (L'abbiamo gi√† detto, ma √® *cos√¨* importante).
2.  **Spazio Limitato (circa 5-10 MB):**
    *Analogo:* √à un cassetto, non un magazzino. √à perfetto per impostazioni, un carrello, il nome utente. √à *pessimo* per salvare foto, file audio, o migliaia di record.
3.  **Sincrono (Bloccante):**
    Quando chiami `localStorage.setItem('roba', '...')`, il tuo JavaScript **si ferma** e aspetta che l'operazione sia scritta sul disco. Se salvi 1KB, √® istantaneo. Se provi a salvare una stringa da 4MB, la tua pagina si *congeler√†* (freezer√†) per una frazione di secondo. Usalo per dati piccoli e veloci.
4.  **Sicurezza Inesistente (√à testo in chiaro\!):**
    *Analogo:* √à un **post-it** appiccicato sullo schermo, non una cassaforte.
    Chiunque abbia accesso fisico al browser dell'utente (o tramite un attacco XSS) pu√≤ aprire i DevTools e leggere *tutto* quello che c'√® dentro.
    **NON SALVARE MAI:**
      * Password
      * Token API (se non strettamente necessario)
      * Numeri di carte di credito
      * Qualsiasi dato sensibile.

-----

#### Best Practices e Pattern Avanzati

  * **Versionamento:** Cosa succede se la `v2` della tua app cambia la struttura dei dati (es. da `utente: "Mario"` a `utente: { nome: "Mario" }`)? Devi gestire la migrazione.
    ```javascript
    const APP_VERSION = "v2";
    const versioneSalvata = localStorage.getItem("appVersion");

    if (versioneSalvata !== APP_VERSION) {
        // Logica di migrazione... (es. carica i vecchi dati,
        // trasformali, salvali nel new formato)
        localStorage.setItem("appVersion", APP_VERSION);
    }
    ```
  * **Expiration (TTL - Time To Live):** `localStorage` **non ha una data di scadenza**. I dati restano l√¨ per sempre. Se vuoi che scadano (es. un login), devi costruirtelo da solo:
    ```javascript
    function setConScadenza(key, value, ttl_ms) {
        const item = {
            value: value,
            expiry: Date.now() + ttl_ms // Salva il timestamp di scadenza
        };
        localStorage.setItem(key, JSON.stringify(item));
    }
    // ...e una funzione get() che controlla il timestamp...
    ```
  * **Namespace (Prefissi):** Se pi√π script (o app diverse sullo stesso dominio) usano `localStorage`, potrebbero sovrascriversi a vicenda (es. entrambi usano la chiave `user`).
    *Analogo:* √à come etichettare le tue scatole del trasloco con "App. 12B" per non confonderle con quelle dell'"App. 10A".
    ```javascript
    const PREFISSO_APP = "miaApp_";
    localStorage.setItem(PREFISSO_APP + 'user', '...');
    localStorage.setItem(PREFISSO_APP + 'settings', '...');
    ```

-----

#### I Comandamenti del localStorage üìú

1.  **Salverai Solo Stringhe** (Ricorda `JSON.stringify()`).
2.  **Parserai con Cautela** (Ricorda `JSON.parse()`).
3.  **Non Ti Fiderai Mai** (Gestisci il `null` del primo avvio con `|| []`).
4.  **Proteggerai dai Crash** (Usa `try-catch` per i dati corrotti).
5.  **Non Salverai Dati Sensibili** (√à un post-it, non una cassaforte).
6.  **Rispetterai i Limiti** (Mantieni i dati piccoli, sotto i 5MB).
7.  **Eviterai di Bloccare** (Non salvare dati enormi in modo sincrono).
8.  **Ispezionerai nei DevTools** (Non lavorare alla cieca).
9.  **Userai un Prefisso (Namespace)** (Evita conflitti con altre app).
10. **Gestirai le Versioni** (Prepara il tuo codice a migrare i dati futuri).
