<!DOCTYPE html>
<!-- ğŸ¯ DICHIARAZIONE HTML5: "Benvenuti in Excel fatto in casa!" -->
<!-- Ãˆ come aprire le porte di un ufficio contabile digitale! ğŸ“Š -->

<html lang="en">
<!-- ğŸŒ CONTENITORE PRINCIPALE: Il nostro foglio di calcolo web -->
<!-- lang="en" = inglese, la lingua universale dei numeri! ğŸ’° -->

  <head>
    <!-- ğŸ§  IL CERVELLO MATEMATICO: Dove prepariamo le formule -->
    <!-- Ãˆ come il retro di una calcolatrice dove stanno i circuiti! -->
    
    <meta charset="utf-8" />
    <!-- ğŸ“ CARATTERI UNIVERSALI: UTF-8 per numeri e simboli matematici âˆ‘âˆâˆ« -->
    
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- ğŸ“± DESIGN RESPONSIVE: "Il foglio di calcolo si adatta a ogni schermo!" -->
    <!-- Ãˆ come avere un quaderno che cambia dimensione magicamente -->
    
    <title>Functional Programming Spreadsheet</title>
    <!-- ğŸ“‘ TITOLO: Un foglio di calcolo che usa programmazione funzionale! -->
    
    <style>
      /* ğŸ¨ ===== GLI STILI DEL NOSTRO EXCEL ===== */
      
      #container {
        display: grid;
        /* ğŸ¯ CSS GRID: Il layout perfetto per un foglio di calcolo! */
        
        grid-template-columns: 50px repeat(10, 200px);
        /* ğŸ“ COLONNE: Prima colonna 50px (per i numeri), poi 10 colonne da 200px */
        /* repeat(10, 200px) = ripeti "200px" per 10 volte */
        /* Ãˆ come dire: etichette strette, celle larghe per i dati */
        
        grid-template-rows: repeat(11, 30px);
        /* ğŸ“ RIGHE: 11 righe da 30px ciascuna */
        /* Prima riga per le lettere A-J, poi 10 righe per i dati */
      }
      
      .label {
        background-color: lightgray;
        /* ğŸ”˜ SFONDO GRIGIO: Per distinguere le etichette */
        
        text-align: center;
        /* âš–ï¸ TESTO CENTRATO: Lettere e numeri al centro */
        
        vertical-align: middle;
        /* ğŸ“ ALLINEAMENTO VERTICALE: Al centro verticalmente */
        
        line-height: 30px;
        /* ğŸ“ ALTEZZA LINEA: Trucco per centrare verticalmente! */
        /* line-height = altezza della riga = centra perfettamente */
      }
    </style>
  </head>
  
  <body>
    <!-- ğŸ“Š ===== IL FOGLIO DI CALCOLO PRENDE VITA! ===== -->
    
    <div id="container">
      <!-- ğŸ“¦ CONTENITORE GRIGLIA: Qui si costruirÃ  tutto dinamicamente -->
      <div></div>
      <!-- ğŸ“ DIV VUOTO: Per l'angolo in alto a sinistra (sopra i numeri di riga) -->
    </div>
    
    <script>
      /* ğŸ§® ===== IL MOTORE MATEMATICO DEL FOGLIO DI CALCOLO ===== */
      
      const infixToFunction = {
        "+": (x, y) => x + y,
        "-": (x, y) => x - y,
        "*": (x, y) => x * y,
        "/": (x, y) => x / y,
      }
      /* ğŸ”¢ DIZIONARIO OPERATORI: Mappa simboli a funzioni matematiche */
      /* Ãˆ come avere un manuale che dice: */
      /* "+" significa "somma questi due numeri" */
      /* "-" significa "sottrai il secondo dal primo" */
      /* Arrow function (x, y) => x + y Ã¨ come dire "prendi x e y, restituisci la somma" */
      
      const infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));
      /* ğŸ¯ VALUTATORE DI ESPRESSIONI: Trova pattern matematici e li calcola! */
      /* str.replace(regex, callback) = cerca il pattern e sostituiscilo */
      /* _match = l'intero match (underscore indica che non lo usiamo) */
      /* arg1, operator, arg2 = i pezzi catturati dal regex (es: "5", "+", "3") */
      /* parseFloat() = converti stringa in numero decimale */
      /* Ãˆ come un robot che trova "5+3" e lo sostituisce con "8" */
      
      const highPrecedence = str => {
        const regex = /([\d.]+)([*\/])([\d.]+)/;
        /* ğŸ“ REGEX PER MOLTIPLICAZIONE/DIVISIONE: */
        /* ([\d.]+) = uno o piÃ¹ numeri/punti decimali (primo numero) */
        /* ([*\/]) = * oppure / (operatore) */
        /* ([\d.]+) = secondo numero */
        /* Trova pattern come "5*3" o "10/2" */
        
        const str2 = infixEval(str, regex);
        /* ğŸ”„ VALUTA: Applica moltiplicazioni e divisioni */
        
        return str === str2 ? str : highPrecedence(str2);
        /* ğŸ” RICORSIONE: Se non Ã¨ cambiato nulla, finito! Altrimenti, continua */
        /* Ãˆ come dire: "continua a fare * e / finchÃ© ce ne sono" */
        /* Ricorsione = la funzione chiama se stessa */
      }
      
      /* ğŸ§® ===== FUNZIONI MATEMATICHE DI BASE ===== */
      
      const isEven = num => num % 2 === 0;
      /* ğŸ”¢ Ãˆ PARI?: num % 2 = resto della divisione per 2 */
      /* Se il resto Ã¨ 0, il numero Ã¨ pari! */
      /* 4 % 2 = 0 (pari), 5 % 2 = 1 (dispari) */
      
      const sum = nums => nums.reduce((acc, el) => acc + el, 0);
      /* â• SOMMA: reduce() accumula tutti i valori */
      /* acc = accumulatore (parte da 0) */
      /* el = elemento corrente */
      /* Ãˆ come avere una calcolatrice che preme + per ogni numero */
      
      const average = nums => sum(nums) / nums.length;
      /* ğŸ“Š MEDIA: Somma tutti e dividi per quanti sono */
      /* Ãˆ la classica media aritmetica che usiamo a scuola! */
      
      const median = nums => {
        const sorted = nums.slice().sort((a, b) => a - b);
        /* ğŸ”„ COPIA E ORDINA: slice() crea una copia, sort() ordina */
        /* (a, b) => a - b ordina in modo crescente */
        /* Non modifichiamo l'array originale! */
        
        const length = sorted.length;
        const middle = length / 2 - 1;
        /* ğŸ“ TROVA IL CENTRO: -1 perchÃ© gli array partono da 0 */
        
        return isEven(length)
          ? average([sorted[middle], sorted[middle + 1]])
          : sorted[Math.ceil(middle)];
        /* ğŸ¯ MEDIANA: */
        /* Se pari: media dei due centrali */
        /* Se dispari: quello al centro */
        /* Math.ceil() = arrotonda per eccesso */
      }
      
      /* ğŸ“š ===== DIZIONARIO DELLE FUNZIONI DEL FOGLIO DI CALCOLO ===== */
      
      const spreadsheetFunctions = {
        "" : (nums) => nums,
        /* ğŸ”„ FUNZIONE VUOTA: Restituisce i numeri cosÃ¬ come sono */
        
        sum,
        /* â• SOMMA: Usa la funzione definita sopra */
        /* Shorthand per sum: sum (invece di sum: sum) */
        
        average,
        /* ğŸ“Š MEDIA: Media aritmetica */
        
        median,
        /* ğŸ“ˆ MEDIANA: Valore centrale */
        
        even: nums => nums.filter(isEven),
        /* ğŸ”¢ SOLO PARI: filter() tiene solo quelli che passano il test */
        
        someeven: nums => nums.some(isEven),
        /* â“ ALMENO UN PARI?: some() = true se almeno uno Ã¨ pari */
        
        everyeven: nums => nums.every(isEven),
        /* âœ… TUTTI PARI?: every() = true solo se TUTTI sono pari */
        
        firsttwo: nums => nums.slice(0, 2),
        /* âœŒï¸ PRIMI DUE: slice(0, 2) = dall'indice 0 al 2 (escluso) */
        
        lasttwo: nums => nums.slice(-2),
        /* ğŸ”š ULTIMI DUE: slice(-2) = gli ultimi 2 elementi */
        /* Indici negativi partono dalla fine! */
        
        has2: nums => nums.includes(2),
        /* ğŸ” CONTIENE 2?: includes() cerca un valore specifico */
        
        increment: nums => nums.map(num => num + 1),
        /* â•1ï¸âƒ£ INCREMENTA: map() trasforma ogni elemento */
        /* Aggiunge 1 a ogni numero */
        
        random: ([x, y]) => Math.floor(Math.random() * y + x),
        /* ğŸ² NUMERO CASUALE: Tra x e y */
        /* [x, y] = destructuring, prende i primi due elementi */
        /* Math.random() = numero tra 0 e 1 */
        /* Math.floor() = arrotonda per difetto */
        
        range: nums => range(...nums),
        /* ğŸ”¢ SEQUENZA: Crea un range di numeri */
        /* ...nums = spread operator, "spacchetta" l'array */
        
        nodupes: nums => [...new Set(nums).values()]
        /* ğŸš« NO DUPLICATI: Set rimuove automaticamente i duplicati! */
        /* [...] = spread per tornare ad array */
        /* Ãˆ come passare i numeri in un setaccio che tiene solo uno di ogni tipo */
      }
      
      /* ğŸ¯ ===== APPLICATORE DI FUNZIONI ===== */
      
      const applyFunction = str => {
        const noHigh = highPrecedence(str);
        /* ğŸ¥‡ PRIMA LE PRIORITÃ€: Risolvi * e / prima di + e - */
        
        const infix = /([\d.]+)([+-])([\d.]+)/;
        /* ğŸ“ REGEX ADDIZIONE/SOTTRAZIONE: Pattern per + e - */
        
        const str2 = infixEval(noHigh, infix);
        /* ğŸ”„ VALUTA: Ora risolvi + e - */
        
        const functionCall = /([a-z0-9]*)\(([0-9., ]*)\)(?!.*\()/i;
        /* ğŸ” REGEX CHIAMATA FUNZIONE: */
        /* ([a-z0-9]*) = nome funzione (lettere/numeri) */
        /* \( = parentesi aperta letterale */
        /* ([0-9., ]*) = argomenti (numeri, virgole, spazi) */
        /* \) = parentesi chiusa */
        /* (?!.*\() = negative lookahead: non deve avere altre ( dopo */
        /* i alla fine = case insensitive */
        /* Trova l'ultima funzione annidata da valutare */
        
        const toNumberList = args => args.split(",").map(parseFloat);
        /* ğŸ”¢ CONVERTI IN NUMERI: "1,2,3" diventa [1, 2, 3] */
        /* split(",") = dividi sulla virgola */
        /* map(parseFloat) = converti ogni pezzo in numero */
        
        const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));
        /* ğŸ¯ APPLICA FUNZIONE: */
        /* toLowerCase() = sum, SUM, Sum sono tutti uguali */
        /* Cerca la funzione nel dizionario e la esegue */
        
        return str2.replace(functionCall, (match, fn, args) => 
          spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match
        );
        /* ğŸ”„ SOSTITUISCI: Se la funzione esiste, calcola; altrimenti lascia com'Ã¨ */
        /* hasOwnProperty() = controlla se la proprietÃ  esiste */
        /* ? : = operatore ternario (if inline) */
      }
      
      /* ğŸ”¢ ===== GENERATORI DI RANGE ===== */
      
      const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);
      /* ğŸ”¢ CREA SEQUENZA NUMERICA: Da start a end (inclusi) */
      /* Array(n) = crea array di n elementi */
      /* fill(start) = riempi tutto con start */
      /* map((el, i) => el + i) = trasforma ogni elemento in start + posizione */
      /* range(5, 8) = [5, 6, 7, 8] */
      /* Ãˆ come contare sulle dita da start a end! */
      
      const charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));
      /* ğŸ”¤ CREA SEQUENZA DI LETTERE: Da start a end */
      /* charCodeAt(0) = codice ASCII della prima lettera */
      /* String.fromCharCode() = da codice ASCII a lettera */
      /* charRange("A", "D") = ["A", "B", "C", "D"] */
      /* Ãˆ come recitare l'alfabeto da una lettera all'altra! */
      
      /* ğŸ§® ===== IL CUORE: VALUTATORE DI FORMULE ===== */
      
      const evalFormula = (x, cells) => {
        const idToText = id => cells.find(cell => cell.id === id).value;
        /* ğŸ” TROVA VALORE CELLA: Cerca la cella con quell'ID e prendi il valore */
        /* find() = trova il primo elemento che soddisfa la condizione */
        
        const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;
        /* ğŸ“ REGEX PER RANGE: A1:B3 */
        /* ([A-J]) = prima lettera (A-J) */
        /* ([1-9][0-9]?) = numero 1-99 (? = opzionale) */
        /* : = due punti letterali */
        /* Stessa cosa per la seconda cella */
        /* gi = global (tutti i match) + case insensitive */
        
        const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));
        /* ğŸ”¢ NUMERI DA STRINGA: "1" e "3" diventano [1, 2, 3] */
        
        const elemValue = num => character => idToText(character + num);
        /* ğŸ¯ VALORE ELEMENTO: Funzione curry! */
        /* Prima prendi il numero, poi la lettera, poi trova il valore */
        /* elemValue(1)("A") = valore della cella A1 */
        /* Currying = funzione che restituisce funzione */
        
        const addCharacters = character1 => character2 => num => 
          charRange(character1, character2).map(elemValue(num));
        /* ğŸ”¤ AGGIUNGI CARATTERI: Triple curry! */
        /* addCharacters("A")("C")(1) = valori di A1, B1, C1 */
        /* Ãˆ come una catena di montaggio di funzioni */
        
        const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => 
          rangeFromString(num1, num2).map(addCharacters(char1)(char2))
        );
        /* ğŸ”„ ESPANDI RANGE: A1:B2 diventa A1,B1,A2,B2 */
        /* Trasforma i range in liste di celle */
        
        const cellRegex = /[A-J][1-9][0-9]?/gi;
        /* ğŸ“ REGEX SINGOLA CELLA: A1, B2, ecc. */
        
        const cellExpanded = rangeExpanded.replace(cellRegex, match => 
          idToText(match.toUpperCase())
        );
        /* ğŸ”„ SOSTITUISCI CELLE: A1 diventa il suo valore */
        
        const functionExpanded = applyFunction(cellExpanded);
        /* ğŸ¯ APPLICA FUNZIONI: Calcola sum(), average(), ecc. */
        
        return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);
        /* ğŸ” RICORSIONE: Se non Ã¨ cambiato nulla, finito! */
        /* Altrimenti, continua a valutare */
        /* Ãˆ come sbucciare una cipolla, strato dopo strato */
      }
      
      /* ğŸš€ ===== INIZIALIZZAZIONE AL CARICAMENTO ===== */
      
      window.onload = () => {
        /* ğŸ¬ QUANDO LA PAGINA Ãˆ PRONTA: Costruisci il foglio di calcolo */
        
        const container = document.getElementById("container");
        /* ğŸ“¦ PRENDI IL CONTENITORE: Dove costruiremo tutto */
        
        const createLabel = (name) => {
          const label = document.createElement("div");
          /* ğŸ·ï¸ CREA ETICHETTA: Un div per ogni lettera/numero */
          
          label.className = "label";
          /* ğŸ¨ AGGIUNGI CLASSE: Per lo stile CSS */
          
          label.textContent = name;
          /* ğŸ“ INSERISCI TESTO: La lettera o il numero */
          
          container.appendChild(label);
          /* ğŸ“ ATTACCA AL CONTENITORE: Aggiungi al DOM */
        }
        
        const letters = charRange("A", "J");
        /* ğŸ”¤ GENERA LETTERE: ["A", "B", ..., "J"] */
        
        letters.forEach(createLabel);
        /* ğŸ”„ CREA ETICHETTE COLONNE: Una per ogni lettera */
        
        range(1, 99).forEach(number => {
          /* ğŸ”¢ PER OGNI RIGA (1-99): */
          
          createLabel(number);
          /* ğŸ·ï¸ CREA ETICHETTA RIGA: Il numero sulla sinistra */
          
          letters.forEach(letter => {
            /* ğŸ”¤ PER OGNI COLONNA: */
            
            const input = document.createElement("input");
            /* ğŸ“ CREA CELLA INPUT: Dove l'utente scrive */
            
            input.type = "text";
            /* ğŸ“ TIPO TESTO: PuÃ² contenere numeri o formule */
            
            input.id = letter + number;
            /* ğŸ†” ID UNIVOCO: "A1", "B2", ecc. */
            
            input.ariaLabel = letter + number;
            /* â™¿ ACCESSIBILITÃ€: Screen reader legge "A1" */
            
            input.onchange = update;
            /* ğŸ”„ EVENTO CHANGE: Quando l'utente finisce di scrivere */
            
            container.appendChild(input);
            /* ğŸ“ AGGIUNGI AL DOM: La cella Ã¨ pronta! */
          })
        })
      }
      
      /* ğŸ”„ ===== AGGIORNAMENTO CELLE ===== */
      
      const update = event => {
        const element = event.target;
        /* ğŸ¯ ELEMENTO CAMBIATO: La cella che l'utente ha modificato */
        
        const value = element.value.replace(/\s/g, "");
        /* ğŸ§¹ PULISCI: Rimuovi tutti gli spazi */
        /* /\s/g = regex per spazi, g = tutti */
        
        if (!value.includes(element.id) && value.startsWith('=')) {
          /* ğŸ” CONTROLLO FORMULA: */
          /* !value.includes(element.id) = non riferisce a se stessa (no circolare!) */
          /* value.startsWith('=') = Ã¨ una formula */
          
          element.value = evalFormula(value.slice(1), Array.from(document.getElementById("container").children));
          /* ğŸ§® CALCOLA: */
          /* value.slice(1) = rimuovi il = iniziale */
          /* Array.from() = converti HTMLCollection in array */
          /* .children = tutti i figli del container (etichette e input) */
          /* Il risultato sostituisce la formula nella cella! */
        }
      }
      
      /* ğŸ¯ ===== COME FUNZIONA IL NOSTRO EXCEL ===== */
      /* 1. L'utente scrive "=sum(A1:A3)" in una cella */
      /* 2. update() intercetta il cambiamento */
      /* 3. evalFormula() espande A1:A3 in A1,A2,A3 */
      /* 4. Sostituisce ogni cella col suo valore */
      /* 5. applyFunction() trova sum() e la calcola */
      /* 6. Il risultato appare nella cella! */
      /* Ãˆ magia della programmazione funzionale! ğŸ©âœ¨ */
    </script>
  </body>
</html>
