---
sidebar_position: 19
sidebar_label: 'fCC News Authors Page'
title: 'fCC News Authors Page'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# fCC News Authors Page

<img
  src={require('./assets/fcc-news-authors-page-1.webp').default}
  alt="Screenshot of the freeCodeCamp News Authors main page displaying the initial 8 author cards"
  loading="lazy"
  decoding="async"
  width="2878"
  height="1916"
  style={{ width: '100%', height: 'auto', borderRadius: '10px' }}
/>

<img
  src={require('./assets/fcc-news-authors-page-2.webp').default}
  alt="Final page screenshot showing all authors fully loaded"
  loading="lazy"
  decoding="async"
  width="2878"
  height="1916"
  style={{ width: '100%', height: 'auto', borderRadius: '10px' }}
/>

### The Project

News Authors Page developed with vanilla JavaScript, fetch API, and asynchronous data management. An application that demonstrates progressive loading, pagination, and robust error handling to optimize performance and user experience.

### Source Code

<Tabs>
<TabItem value="html" label="index.html" default>

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>freeCodeCamp News Author Page</title>
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <h1 class="title">freeCodeCamp News Author Page</h1>
    <main>
      <div id="author-container"></div>
      <button class="btn" id="load-more-btn">Load More Authors</button>
    </main>
    <script src="./script.js"></script>
  </body>
</html>

```
</TabItem>

<TabItem value="css" label="styles.css">

```css
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

:root {
--main-bg-color: #1b1b32;
--light-grey: #f5f6f7;
--dark-purple: #5a01a7;
--golden-yellow: #feac32;
}

body {
background-color: var(--main-bg-color);
text-align: center;
}

.title {
color: var(--light-grey);
margin: 20px 0;
}

#author-container {
display: flex;
flex-wrap: wrap;
justify-content: center;
}

.user-card {
border-radius: 15px;
width: 300px;
height: 350px;
background-color: var(--light-grey);
margin: 20px;
}

.user-img {
width: 150px;
height: 150px;
object-fit: cover;
}

.purple-divider {
background-color: var(--dark-purple);
width: 100%;
height: 15px;
}

.author-name {
margin: 10px;
}

.bio {
margin: 20px;
}

.error-msg {
color: var(--light-grey);
}

.btn {
cursor: pointer;
width: 200px;
margin: 10px;
color: var(--main-bg-color);
font-size: 14px;
background-color: var(--golden-yellow);
background-image: linear-gradient(#fecc4c, #ffac33);
border-color: var(--golden-yellow);
border-width: 3px;
}
```
</TabItem>

<TabItem value="js" label="script.js">

```js
const authorContainer = document.getElementById('author-container');
const loadMoreBtn = document.getElementById('load-more-btn');

let startingIndex = 0;
let endingIndex = 8;
let authorDataArr = [];

fetch('https://cdn.freecodecamp.org/curriculum/news-author-page/authors.json')
.then((res) => res.json())
.then((data) => {
    authorDataArr = data;
    displayAuthors(authorDataArr.slice(startingIndex, endingIndex));  
})
.catch((err) => {
    authorContainer.innerHTML = '<p class="error-msg">There was an error loading the authors</p>';
});

const fetchMoreAuthors = () => {
startingIndex += 8;
endingIndex += 8;

displayAuthors(authorDataArr.slice(startingIndex, endingIndex));
if (authorDataArr.length <= endingIndex) {
    loadMoreBtn.disabled = true;
    loadMoreBtn.style.cursor = "not-allowed";
    loadMoreBtn.textContent = 'No more data to load';
}
};

const displayAuthors = (authors) => {
authors.forEach(({ author, image, url, bio }, index) => {
    authorContainer.innerHTML += `
    <div id="${index}" class="user-card">
    <h2 class="author-name">${author}</h2>
    <img class="user-img" src="${image}" alt="${author} avatar">
    <div class="purple-divider"></div>
    <p class="bio">${bio.length > 50 ? bio.slice(0, 50) + '...' : bio}</p>
    <a class="author-link" href="${url}" target="_blank">${author} author page</a>
    </div>
`;
});
};

loadMoreBtn.addEventListener('click', fetchMoreAuthors);
```

</TabItem> 

<TabItem value="commented" label="explained">

```html
<!DOCTYPE html>
<!-- üéØ HTML5 DECLARATION: "Welcome to our modern web document" -->
<!-- This tells browsers we're using the latest HTML standard, like announcing "we're modern and compatible!" üöÄ -->

<html lang="en">
<!-- üåç MAIN CONTAINER: All our content lives here -->
<!-- lang="en" = English, ensuring screen readers and search engines know our language -->

  <head>
    <!-- üß† THE COMMAND CENTER: Where we prepare and configure our page -->
    <!-- Just like the cockpit of an airplane, this is where all the technical setup happens! -->
    
    <meta charset="UTF-8" />
    <!-- üìù CHARACTER ENCODING: UTF-8 supports all international characters -->
    <!-- This is like telling the browser "we speak ALL languages" - emojis, special symbols, everything! -->
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- üîß IE COMPATIBILITY: Ensures Internet Explorer uses its latest rendering engine -->
    <!-- Like telling an old car "use your newest parts please!" - helps with legacy browser support -->
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- üì± RESPONSIVE DESIGN: Makes our page look good on all devices -->
    <!-- This magic line is why websites work on phones, tablets, AND computers! -->
        
    <title>freeCodeCamp News Author Page</title>
    <!-- üì∞ PAGE TITLE: Appears in browser tab and search results -->
    <!-- Your website's name tag that users see in their browser tab -->
    
    <style>
      /* üé® ===== CSS STYLES: The Visual Design Rules ===== */
      
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        /* üßπ CSS RESET: Cleans up browser default styles */
        /* This is like clearing the canvas before painting - ensures consistency across browsers */
        /* box-sizing: border-box makes width/height include padding and border - much more intuitive! */
      }
      
      :root {
        --main-bg-color: #1b1b32;
        --light-grey: #f5f6f7;
        --dark-purple: #5a01a7;
        --golden-yellow: #feac32;
        /* üé® COLOR VARIABLES: Central place to manage our color palette */
        /* These are like paint buckets we can reuse throughout our design */
        /* Using variables makes site-wide color changes super easy - one change affects everything! */
      }
      
      body {
        background-color: var(--main-bg-color);
        /* üåÉ BACKGROUND COLOR: Dark blue from our color variables */
        /* This deep blue is part of freeCodeCamp's brand identity */
        
        text-align: center;
        /* ‚öñÔ∏è CENTER ALIGNMENT: Centers all text and block elements with text-align property */
        /* Makes everything centered by default for a balanced, clean layout */
      }
      
      .title {
        color: var(--light-grey);
        /* ‚ö™ TITLE COLOR: Light grey for readability against dark background */
        /* High contrast ensures our title is easy to read */
        
        margin: 20px 0;
        /* üìè VERTICAL MARGIN: 20px above and below the title */
        /* Creates breathing room around our main title */
      }
      
      #author-container {
        display: flex;
        /* üì¶ FLEXBOX: Modern layout system for arranging items */
        /* Like magic shelves that automatically organize our author cards! */
        
        flex-wrap: wrap;
        /* üîÑ FLEX WRAP: Allows items to wrap to next row when they run out of space */
        /* This makes cards form multiple rows instead of squishing to fit one row */
        
        justify-content: center;
        /* ‚öñÔ∏è CENTER CONTENT: Centers flex items horizontally */
        /* Makes all our author cards neatly centered on the page */
      }
      
      .user-card {
        border-radius: 15px;
        /* üîÑ ROUNDED CORNERS: 15px radius softens the card edges */
        /* Creates friendly, modern-looking cards rather than sharp boxes */
        
        width: 300px;
        height: 350px;
        /* üìè CARD DIMENSIONS: Fixed size cards for consistency */
        /* Each author card is exactly the same size for visual harmony */
        
        background-color: var(--light-grey);
        /* ‚ö™ CARD BACKGROUND: Light grey from our variables */
        /* Light background makes the card content easy to read */
        
        margin: 20px;
        /* üìè CARD SPACING: 20px space around each card */
        /* Creates breathing room between cards so they don't touch */
      }
      
      .user-img {
        width: 150px;
        height: 150px;
        /* üìè IMAGE SIZE: Square dimensions for consistent layout */
        /* 150√ó150px creates a perfect square for author photos */
        
        object-fit: cover;
        /* üñºÔ∏è IMAGE FITTING: Covers the container while maintaining aspect ratio */
        /* This magical property ensures photos look good regardless of their dimensions */
        /* Prevents stretching and maintains focus on the person's face */
      }
      
      .purple-divider {
        background-color: var(--dark-purple);
        /* üü£ DIVIDER COLOR: Dark purple accent from our variables */
        /* Adds a pop of color that visually separates parts of the card */
        
        width: 100%;
        height: 15px;
        /* üìè DIVIDER DIMENSIONS: Full width, 15px tall separator */
        /* Creates a distinct horizontal line across the entire card */
      }
      
      .author-name {
        margin: 10px;
        /* üìè NAME SPACING: 10px margin around author names */
        /* Prevents the name from touching other elements */
      }
      
      .bio {
        margin: 20px;
        /* üìè BIO SPACING: 20px margin gives the bio text room to breathe */
        /* Text needs more space than other elements for readability */
      }
      
      .error-msg {
        color: var(--light-grey);
        /* ‚ö™ ERROR TEXT COLOR: Light color for visibility on dark background */
        /* Ensures error messages are clearly visible to users */
      }
      
      .btn {
        cursor: pointer;
        /* üëÜ HAND CURSOR: Changes mouse cursor to a hand when hovering */
        /* Visual indicator that the button is clickable */
        
        width: 200px;
        margin: 10px;
        /* üìè BUTTON DIMENSIONS: 200px wide with 10px margin */
        /* Creates a prominent, easy-to-click button */
        
        color: var(--main-bg-color);
        /* üî† BUTTON TEXT COLOR: Dark blue for contrast with yellow background */
        /* Makes the button text easy to read */
        
        font-size: 14px;
        /* üìù BUTTON FONT SIZE: 14px for clear readability */
        /* Not too big, not too small - just right for a button */
        
        background-color: var(--golden-yellow);
        /* üü° BUTTON BACKGROUND: Yellow from our variables */
        /* Creates a vibrant, attention-grabbing button */
        
        background-image: linear-gradient(#fecc4c, #ffac33);
        /* üåÖ GRADIENT EFFECT: Light to dark yellow creates a 3D effect */
        /* Gradient makes the button look more tactile and clickable */
        
        border-color: var(--golden-yellow);
        border-width: 3px;
        /* üî≤ BORDER STYLE: Thick yellow border matches the background */
        /* Creates a cohesive, polished button appearance */
      }
    </style>
  </head>
  <body>
    <!-- üìÑ ===== THE BODY: Where Content Lives ===== -->
    
    <h1 class="title">freeCodeCamp News Author Page</h1>
    <!-- üì∞ MAIN TITLE: Page heading that establishes context -->
    <!-- Tells users exactly what this page is about -->

    <main>
      <!-- üìë MAIN CONTENT: Primary content wrapper -->
      <!-- Semantically identifies the main content area of our page -->
            
      <div id="author-container"></div>
      <!-- üì¶ AUTHOR CONTAINER: Initially empty div that will hold author cards -->
      <!-- JavaScript will fill this container with author cards dynamically -->
            
      <button class="btn" id="load-more-btn">Load More Authors</button>
      <!-- üîò LOAD BUTTON: Triggers loading of additional authors -->
      <!-- When clicked, this button requests more author data to be displayed -->
    </main>

    <script>
      /* üß† ===== JAVASCRIPT: The Interactive Logic ===== */
      
      // üîç DOM SELECTIONS: Getting references to important page elements
      const authorContainer = document.getElementById('author-container');
      const loadMoreBtn = document.getElementById('load-more-btn');
      /* These constants store references to HTML elements so we can manipulate them.
         It's like establishing a direct phone line to specific parts of our page. */
      
      // üìä PAGINATION SETUP: Defining what portion of data to show
      let startingIndex = 0;
      let endingIndex = 8;
      /* These variables act like bookmarks in a dataset:
         - startingIndex is where we begin (initially 0 - the first item)
         - endingIndex is where we end (initially 8 - showing first 8 authors)
         This pagination system allows us to load data in manageable chunks.
         
         POTENTIAL ENHANCEMENT: We could adapt these values based on:
         - Connection speed (navigator.connection.effectiveType)
         - Data saving preferences (navigator.connection.saveData)
         - Screen size (window.innerWidth) for better mobile experience
         This would make the app more responsive to user conditions. */
      
      // üóÑÔ∏è DATA CACHE: Place to store all fetched authors
      let authorDataArr = [];
      /* This empty array will serve as our "memory" for author data.
         Once we fetch data from the server, we'll store it here
         so we don't need to keep requesting it from the server. */
      
      // üîÑ DATA FETCHING: Request author data from the server
      fetch('https://cdn.freecodecamp.org/curriculum/news-author-page/authors.json')
        /* fetch() is like sending a messenger to get information:
           1. We tell it where to go (the URL)
           2. It goes to that web address
           3. It comes back with a response
           This starts an asynchronous process - the code continues running while the fetch happens. */
        
        // üì¶ RESPONSE HANDLING: Processing the initial server response
        .then((res) => res.json())
        /* This first .then() receives the raw response from the server.
           The .json() method unpacks the JSON data, but is itself asynchronous.
           This is why we need a second .then() below - we're waiting twice:
           1. First for the response to arrive
           2. Then for the JSON data to be extracted from it */
        
        // üìã DATA PROCESSING: What to do with the unpacked data
        .then((data) => {
          // 1. Save complete data to our cache array
          authorDataArr = data;
          /* Now we have all the author data stored in memory.
             This is efficient because we only need to fetch it once. */
             
          // 2. Display only the first chunk of authors (0-8)
          displayAuthors(authorDataArr.slice(startingIndex, endingIndex));
          /* The slice() method carves out a portion of the array from
             startingIndex up to (but not including) endingIndex.
             We then pass just this chunk to our display function. */
        })
        
        // ‚ö†Ô∏è ERROR HANDLING: Managing problems that might occur
        .catch((err) => {
          /* This .catch() block acts as a safety net, catching any errors in our fetch chain:
             - Network errors (if the server is down or there's no internet)
             - Parsing errors (if the response isn't valid JSON)
             - Any other errors that might occur in our .then() blocks */
          
          /* ERROR DISPLAY STRATEGY:
             1. Developer errors: We could log technical details to console (removed here)
             2. User-friendly errors: Show a simple message in the interface
             
             We use innerHTML = '...' (not +=) because we want to replace any 
             partial content with just the error message. */
         authorContainer.innerHTML = '<p class="error-msg">There was an error loading the authors</p>';
         /* This provides clear feedback to the user when something goes wrong,
            without exposing technical details they don't need to see. */
        });
      
      // üîÑ LOAD MORE FUNCTION: Gets the next batch of authors
      const fetchMoreAuthors = () => {
        // Update our "bookmarks" to get the next chunk of data
        startingIndex += 8;
        endingIndex += 8;
        /* We move both indices forward by 8, so:
           - First click: 0-8 ‚Üí 8-16
           - Second click: 8-16 ‚Üí 16-24
           And so on, each time showing the next 8 authors. */
      
        // Display the new chunk of authors
        displayAuthors(authorDataArr.slice(startingIndex, endingIndex));
        /* Since we've moved our indices, slice() now gives us the next batch. */
        
        // Check if we've reached the end of available data
        if (authorDataArr.length <= endingIndex) {
          /* If our ending index is now at or beyond the array's length,
             it means we've shown all available authors. */
          
          // Disable the load more button
          loadMoreBtn.disabled = true;
          loadMoreBtn.style.cursor = "not-allowed";
          loadMoreBtn.textContent = 'No more data to load';
          /* These three changes create clear user feedback:
             1. Making the button non-clickable (disabled)
             2. Changing the cursor to indicate it's not usable
             3. Updating the text to explain why it's disabled
             This prevents confusion about why clicking doesn't do anything. */
        }
      };
      
      // üèóÔ∏è DISPLAY FUNCTION: Builds HTML for author cards
      const displayAuthors = (authors) => {
        // Loop through each author in the provided array
        
        // Using destructuring to unpack each author object
        authors.forEach(({ author, image, url, bio }, index) => {
          /* The destructuring syntax { author, image, url, bio } extracts these specific
             properties from each author object, making our code cleaner.
             Without destructuring, we'd need to write author.name, author.image, etc.
             
             The index parameter tracks the position in the array, which we use as a unique ID. */
          
          // Add a new card to the container for this author
          authorContainer.innerHTML += `
          <div id="${index}" class="user-card">
            <h2 class="author-name">${author}</h2>
            <img class="user-img" src="${image}" alt="${author} avatar">
            <div class="purple-divider"></div>
                        <p class="bio">${bio.length > 50 ? bio.slice(0, 50) + '...' : bio}</p>
            <a class="author-link" href="${url}" target="_blank">${author} author page</a>
          </div>
        `;
          /* We use += to add this HTML to the existing content, not replace it.
             This is important because we're in a loop adding multiple cards.
             
             The template literal (`...`) lets us easily insert variables into our HTML.
             
             For the bio text, we use a ternary operator (condition ? ifTrue : ifFalse) to:
             - Check if the bio is longer than 50 characters
             - If it is, slice it to 50 chars and add "..." 
             - If not, show the full bio
             This keeps our cards neat even with long author descriptions. */
        });
      };
      
      // üîÑ EVENT BINDING: Connect button click to our function
      loadMoreBtn.addEventListener('click', fetchMoreAuthors);
      /* This sets up an event listener that calls fetchMoreAuthors
         whenever the Load More button is clicked.
         It's like connecting a wire from the button to our function. */
    </script>
  </body>
</html>

<!-- üéØ ===== PAGE ARCHITECTURE SUMMARY ===== -->
<!-- 
üìÑ PAGE STRUCTURE:
‚îÇ
‚îú‚îÄ‚îÄ üß† HEAD
‚îÇ   ‚îú‚îÄ‚îÄ üìù Meta tags (character set, compatibility, viewport)
‚îÇ   ‚îî‚îÄ‚îÄ üé® CSS styles (card layouts, colors, responsive design)
‚îÇ
‚îú‚îÄ‚îÄ üìÑ BODY
‚îÇ   ‚îú‚îÄ‚îÄ üì∞ Page title (freeCodeCamp News Author Page) 
‚îÇ   ‚îî‚îÄ‚îÄ üì¶ Main content
‚îÇ       ‚îú‚îÄ‚îÄ üì¶ Author container (dynamically filled)
‚îÇ       ‚îî‚îÄ‚îÄ üîò Load more button
‚îÇ
‚îî‚îÄ‚îÄ üß† JAVASCRIPT
    ‚îú‚îÄ‚îÄ üîç DOM element selection
    ‚îú‚îÄ‚îÄ üìä Pagination variables (startingIndex, endingIndex)
    ‚îú‚îÄ‚îÄ üîÑ Data fetching with fetch API
    ‚îú‚îÄ‚îÄ ‚ö†Ô∏è Error handling
    ‚îú‚îÄ‚îÄ üèóÔ∏è Functions for displaying authors
    ‚îî‚îÄ‚îÄ üîÑ Event listener for loading more

üîÑ DATA FLOW:
1. Page loads and requests author data from server
2. First 8 authors display in cards
3. User clicks "Load More" to see next 8 authors
4. Process repeats until all authors are shown
5. Button disables when no more authors remain

üé® STYLING APPROACH:
- CSS variables for consistent colors
- Flexbox for responsive card layout
- Fixed-size cards with consistent spacing
- Visual hierarchy through spacing and typography

üß† JAVASCRIPT TECHNIQUES:
- Fetch API for asynchronous data loading
- Array manipulation with slice()
- Template literals for HTML generation
- Destructuring for cleaner code
- Event listeners for user interaction

A clean, responsive author gallery with pagination! üìö‚ú®
-->
```
</TabItem>

</Tabs>

### The Favorite Project

It was one of my favorite freeCodeCamp projects! It made me think deeply about how to optimize content loading for users with different needs.

### The Insight: Adaptive Loading

An insight came to me that I attribute to the Google UX course, where it was explained how pay-as-you-go rates work in emerging countries like India, and how desktop users are much more likely to have a fast connection being more likely to be connected to a home network (ADSL, Fiber optic).<br />

**The tutorial problem:**<br />
The freeCodeCamp tutorial always loads 8 authors at a time, a fixed compromise that doesn't consider users' different conditions. I asked myself: why impose this friction (click to load) on those with a very fast connection? At the same time, why risk wasting precious data on those with pay-as-you-go rates?<br />

**The discovery:**<br />
There's an approach called **Adaptive Loading** that solves exactly this problem. Using `navigator.connection.effectiveType` (which returns "4g", "3g", "2g", "slow-2g") and `navigator.connection.saveData` (a boolean indicating if the user has activated data saving), you can dynamically load 5, 8, or 20 elements based on the actual connection.<br />

Furthermore, by differentiating between desktop and mobile (`window.innerWidth`), you can further optimize: desktop with home WiFi can load everything, mobile on data network loads progressively.

### The Night Reflection: Lazy Loading

Last night (literally) I woke up thinking that the best solution, simple and that truly adapts to everyone, is to eliminate the button entirely and load the page content bit by bit (Lazy Loading with Infinite Scroll).<br />

I believe it's the optimal solution because those with fast internet won't notice the progressive loading, everything will appear fluid, those with slow internet will see a loading message after a brief delay, without the friction of manual clicking, using Intersection Observer, the next 8 authors are automatically loaded when the user reaches the bottom of the list, guaranteeing zero friction.<br />
This is the most elegant solution because it's passive; in fact, it adapts to the user without the user having to do (or know) anything.

### What I Learned

**Fetch API and Promise Chain:**
- `.fetch()` returns a Promise that resolves with a Response object
- `.then(res => res.json())` is the necessary "double .then()": first you unpack the Response, then you parse the JSON
- `.catch()` catches ALL errors in the chain (network, parsing, logic)

**UX-Oriented Error Handling:**
- Errors for the developer: `console.error()` for technical debugging
- Errors for the user: `innerHTML` with understandable message
- Important distinction: the user shouldn't see technical errors

**Pagination with Array Slicing:**
- `startingIndex` and `endingIndex` as a "sliding window" on the complete array
- `.slice(start, end)` to extract "pieces" of data without modifying the original
- Progressive increment (`+= 8`) to show the next batch

**Smart Caching:**
- `authorDataArr = data` saves ALL data after the first fetch
- Subsequent fetches not necessary, only slicing of the local array
- Drastically reduces network calls

**innerHTML: `=` vs `+=`:**
- `=` (assignment) completely replaces content: ideal for errors or reset
- `+=` (concatenation) adds to existing content: ideal for card loops
- Understanding when to use each is fundamental for correct UX

**Advanced Destructuring:**
- `({ author, image, url, bio })` unpacks objects into single variables
- Cleaner and more readable than repeated `obj.author`, `obj.image`
- Modern ES6 pattern that makes code more elegant

**Button UX Disabling:**
- `disabled = true` to block clicks
- `style.cursor = "not-allowed"` for visual feedback
- `textContent` updated to clearly communicate the state

**Adaptive Loading (Discovery):**
- `navigator.connection` API to detect actual connection type
- `navigator.connection.saveData` to respect user preferences
- Conditional logic to dynamically adapt `endingIndex`

**Infinite Scroll Pattern:**
- Intersection Observer to detect when user reaches the bottom
- Automatic loading without click friction
- Loading message after timeout for slow connections

**Performance-Oriented Responsive Design:**
- Desktop (large screen + WiFi) ‚Üí loads more elements
- Mobile (small screen + data) ‚Üí loads progressively
- Implicit respect for user's hardware and network conditions

---

**Next Project**: Learn Asynchronous Programming by Building an fCC Forum Leaderboard
