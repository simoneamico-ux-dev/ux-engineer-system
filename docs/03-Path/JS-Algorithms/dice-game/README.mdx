---
sidebar_position: 3
sidebar_label: 'Dice Game'
title: 'Dice Game'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Dice Game

<img width="100%" alt="Dice game main interface showing game rules and 5 dice" src="https://github.com/user-attachments/assets/bcd9d61b-26eb-430e-aa25-0343060dcba2" />
<img width="100%" alt="Game interface showing a small straight pattern with score of 30 points" src="https://github.com/user-attachments/assets/1b41c462-c3d7-4a61-85bb-994a4d2a0217" />
<img width="100%" alt="Score history panel showing total score of 30 from one small straight worth 30 points" src="https://github.com/user-attachments/assets/82cf4a0c-8b3d-4588-8a12-6acc9319de0c" />
<img width="100%" alt="Game over screen displaying final score" src="https://github.com/user-attachments/assets/496e8e87-4a19-4d0c-b21f-57070f7174c2" />

### The Project

Dice Game developed with vanilla JavaScript, focused on algorithmic logic, state management, and DOM manipulation. A project that requires putting together multiple concepts previously learned in a context with minimal structured guidance.

### Source Code

<Tabs>
<TabItem value="html" label="index.html" default>

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Advanced Dice Game</title>
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <header>
    <h1>Advanced Dice Game</h1>
    <button class="btn" id="rules-btn" type="button">Show rules</button>
    <div class="rules-container">
      <h2>Rules</h2>
      <ul>
        <li>There are total of six rounds</li>
        <li>You can only roll the dice three times per round</li>
        <li>To start the game, roll the dice</li>
        <li>
          Then, choose from one of the selected scores or roll the dice again
        </li>
        <li>
          If you choose a selected score, then you will move to the next round
        </li>
        <li>
          If you decline to choose a selected score, then you can roll the
          dice again two more times
        </li>
      </ul>
      <h2 class="points">Points</h2>
      <ul>
        <li>Three of a kind: Sum of all five dice</li>
        <li>Four of a kind: Sum of all five dice</li>
        <li>Full house: Three of a kind and a pair - 25 points</li>
        <li>
          Small straight: Four of the dice have consecutive values - 30 points
        </li>
        <li>
          Large straight: All five dice have consecutive values - 40 points
        </li>
      </ul>
    </div>
  </header>

  <main>
    <form id="game">
      <div id="dice">
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
      </div>

      <p class="rounds-text">
        <strong>Rolls:</strong> <span id="current-round-rolls">0</span> |
        <strong>Round:</strong> <span id="current-round">1</span>
      </p>

      <div id="score-options">
        <div>
          <input type="radio" name="score-options" id="three-of-a-kind" value="three-of-a-kind" disabled />
          <label for="three-of-a-kind">Three of a kind<span></span></label>
        </div>
        <div>
          <input type="radio" name="score-options" id="four-of-a-kind" value="four-of-a-kind" disabled />
          <label for="four-of-a-kind">Four of a kind<span></span></label>
        </div>
        <div>
          <input type="radio" name="score-options" id="full-house" value="full-house" disabled />
          <label for="full-house">Full house<span></span></label>
        </div>
        <div>
          <input type="radio" name="score-options" id="small-straight" value="small-straight" disabled />
          <label for="small-straight">Small straight<span></span></label>
        </div>
        <div>
          <input type="radio" name="score-options" id="large-straight" value="large-straight" disabled />
          <label for="large-straight">Large straight<span></span></label>
        </div>

        <div>
          <input type="radio" name="score-options" id="none" value="none" disabled />
          <label for="none">None of the above<span></span></label>
        </div>
      </div>

      <button class="btn" id="keep-score-btn" type="button">
        Keep the above selected score
      </button>
      <button class="btn" id="roll-dice-btn" type="button">
        Roll the dice
      </button>
    </form>

    <div id="scores">
      <h3>Score history (Total score: <span id="total-score">0</span>)</h3>
      <ol id="score-history"></ol>
    </div>
  </main>
  <script src="./script.js"></script>
</body>

</html>
```
</TabItem>

<TabItem value="css" label="styles.css">

```css
*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  --dark-grey: #1b1b32;
  --light-grey: #f5f6f7;
  --black: #000;
  --white: #fff;
  --grey: #3b3b4f;
  --golden-yellow: #fecc4c;
  --yellow: #ffcc4c;
  --gold: #feac32;
  --orange: #ffac33;
  --dark-orange: #f89808;
}

body {
  background-color: var(--dark-grey);
}

header {
  color: var(--light-grey);
  text-align: center;
}

h1 {
  font-size: 2.5rem;
  margin: 25px 0;
}

.rules-container {
  display: none;
  background-color: var(--light-grey);
  color: var(--black);
  width: 50%;
  margin: 20px auto;
  height: 300px;
  border-radius: 10px;
  overflow-y: scroll;
}

.rules-container ul {
  list-style-type: none;
}

.points {
  margin-top: 15px;
}

main {
  background-color: var(--light-grey);
  padding: 20px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
  gap: 1rem;
  margin: auto;
  justify-items: center;
  width: 50%;
  border-radius: 10px;
}

#dice {
  display: flex;
  justify-content: space-around;
  margin-bottom: 15px;
}

.die {
  width: 40px;
  height: 40px;
  text-align: center;
  margin-right: 15px;
  border: 4px solid var(--black);
  padding: 10px;
}

.rounds-text {
  text-align: center;
}

input[type="radio"]:disabled + label {
  color: var(--grey);
}

#score-history {
  margin-top: 15px;
  text-align: center;
  list-style-position: inside;
}

.btn {
  cursor: pointer;
  width: 200px;
  margin: 10px 0 10px 0.5rem;
  color: var(--black);
  background-color: var(--gold);
  background-image: linear-gradient(var(--golden-yellow), var(--orange));
  border-color: var(--gold);
  border-width: 3px;
}

.btn:hover:enabled {
  background-image: linear-gradient(var(--yellow), var(--dark-orange));
}

@media (max-width: 992px) {
  main {
    width: 100%;
  }
}

@media (max-width: 500px) {
  .btn {
    width: 120px;
  }
}
```
</TabItem>

<TabItem value="js" label="script.js">

```js
const listOfAllDice = document.querySelectorAll(".die");
const scoreInputs = document.querySelectorAll("#score-options input");
const scoreSpans = document.querySelectorAll("#score-options span");
const roundElement = document.getElementById("current-round");
const rollsElement = document.getElementById("current-round-rolls");
const totalScoreElement = document.getElementById("total-score");
const scoreHistory = document.getElementById("score-history");
const rollDiceBtn = document.getElementById("roll-dice-btn");
const keepScoreBtn = document.getElementById("keep-score-btn");
const rulesContainer = document.querySelector(".rules-container");
const rulesBtn = document.getElementById("rules-btn");

let diceValuesArr = [];
let isModalShowing = false;
let score = 0;
let round = 1;
let rolls = 0;

const rollDice = () => {
  diceValuesArr = [];

  for (let i = 0; i < 5; i++) {
    const randomDice = Math.floor(Math.random() * 6) + 1;
    diceValuesArr.push(randomDice);
  };

  listOfAllDice.forEach((dice, index) => {
    dice.textContent = diceValuesArr[index];
  });
};

const updateStats = () => {
  rollsElement.textContent = rolls;
  roundElement.textContent = round;
};

const updateRadioOption = (index, score) => {
  scoreInputs[index].disabled = false;
  scoreInputs[index].value = score;
  scoreSpans[index].textContent = `, score = ${score}`;
};

const updateScore = (selectedValue, achieved) => {
  score += parseInt(selectedValue);
  totalScoreElement.textContent = score;

  scoreHistory.innerHTML += `<li>${achieved} : ${selectedValue}</li>`;
};


const getHighestDuplicates = (arr) => {
  const counts = {};

  for (const num of arr) {
    if (counts[num]) {
      counts[num]++;
    } else {
      counts[num] = 1;
    }
  }

  let highestCount = 0;

  for (const num of arr) {
    const count = counts[num];
    if (count >= 3 && count > highestCount) {
      highestCount = count;
    }
    if (count >= 4 && count > highestCount) {
      highestCount = count;
    }
  }

  const sumOfAllDice = arr.reduce((a, b) => a + b, 0);

  if (highestCount >= 4) {
    updateRadioOption(1, sumOfAllDice);
  }

  if (highestCount >= 3) {
    updateRadioOption(0, sumOfAllDice);
  }

};

const detectFullHouse = (arr) => {
  const counts = {};

  for (const num of arr) {
    counts[num] = counts[num] ? counts[num] + 1 : 1;
  }

  const hasThreeOfAKind = Object.values(counts).includes(3);
  const hasPair = Object.values(counts).includes(2);

  if (hasThreeOfAKind && hasPair) {
    updateRadioOption(2, 25);
  }

};

const checkForStraights = (arr) => {
  const sortedNumbersArr = arr.sort((a, b) => a - b);
  const uniqueNumbersArr = [...new Set(sortedNumbersArr)];
  const uniqueNumbersStr = uniqueNumbersArr.join("");

  const smallStraightsArr = ["1234", "2345", "3456"];
  const largeStraightsArr = ["12345", "23456"];

  if (smallStraightsArr.some(straight => uniqueNumbersStr.includes(straight))) {
    updateRadioOption(3, 30);
  }

  if (largeStraightsArr.includes(uniqueNumbersStr)) {
    updateRadioOption(4, 40);
  }

};

const resetRadioOptions = () => {
  scoreInputs.forEach((input) => {
    input.disabled = true;
    input.checked = false;
  });

  scoreSpans.forEach((span) => {
    span.textContent = "";
  });
};

const resetGame = () => {
  diceValuesArr = [0, 0, 0, 0, 0];
  score = 0;
  round = 1;
  rolls = 0;

  listOfAllDice.forEach((dice, index) => {
    dice.textContent = diceValuesArr[index];
  });

  totalScoreElement.textContent = score;
  scoreHistory.innerHTML = "";

  rollsElement.textContent = rolls;
  roundElement.textContent = round;

  resetRadioOptions();
};

rollDiceBtn.addEventListener("click", () => {
  if (rolls === 3) {
    alert("You have made three rolls this round. Please select a score.");
  } else {
    rolls++;
    resetRadioOptions();
    rollDice();
    updateStats();
    getHighestDuplicates(diceValuesArr);
    detectFullHouse(diceValuesArr);
    checkForStraights(diceValuesArr);
    updateRadioOption(5, 0);
  }
});

rulesBtn.addEventListener("click", () => {
  isModalShowing = !isModalShowing;

  if (isModalShowing) {
    rulesBtn.textContent = "Hide rules";
    rulesContainer.style.display = "block";
  } else {
    rulesBtn.textContent = "Show rules";
    rulesContainer.style.display = "none";
  }
});

keepScoreBtn.addEventListener("click", () => {
  let selectedValue;
  let achieved;

  for (const radioButton of scoreInputs) {
    if (radioButton.checked) {
      selectedValue = radioButton.value;
      achieved = radioButton.id;
      break;
    }
  }

  if (selectedValue) {
    rolls = 0;
    round++;
    updateStats();
    resetRadioOptions();
    updateScore(selectedValue, achieved);
    if (round > 6) {
      setTimeout(() => {
        alert(`Game Over! Your total score is ${score}`);
        resetGame();
      }, 500);
    }
  } else {
    alert("Please select an option or roll the dice");
  }
});
```

</TabItem> 

<TabItem value="commented" label="explained">

```html
<!DOCTYPE html>
<!-- üéØ HTML5 DECLARATION: "Welcome to the dice game universe!" -->
<!-- It's like announcing the rules of play before a board game night! üé≤ -->

<html lang="en">
<!-- üåç MAIN CONTAINER: Our interactive dice game application -->
<!-- lang="en" = English, making our game internationally accessible -->

<head>
  <!-- üß† THE COMMAND CENTER: Where we set up the game environment -->
  <!-- Just like preparing a table before playing a board game - laying out the rules and pieces! -->
  
  <meta charset="utf-8" />
  <!-- üìù CHARACTER ENCODING: UTF-8 ensures symbols like dice (‚öÄ ‚öÅ ‚öÇ ‚öÉ ‚öÑ ‚öÖ) display correctly -->
  <!-- Without proper encoding, special characters could appear broken -->
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- üì± RESPONSIVE DESIGN: "Play this game on any device!" -->
  <!-- Just like how board games can be played on tables of any size -->
  
  <title>Advanced Dice Game</title>
  <!-- üìë GAME TITLE: Appears in the browser tab -->
  <!-- Simple and descriptive - tells players exactly what they're getting! -->
  
  <style>
    /* üé® ===== CSS STYLES: The Game's Visual Design ===== */
    
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      /* üì¶ BOX-SIZING: Includes padding and border in element sizes */
      /* Prevents layout issues - like making sure game pieces fit in their spaces! */
      
      margin: 0;
      padding: 0;
      /* üßπ RESET: Clears default browser spacing */
      /* Like clearing a table before setting up a board game */
    }
    
    :root {
      /* üé® COLOR PALETTE: Game theme colors defined as variables */
      /* Like choosing a specific color theme for your game pieces */
      
      --dark-grey: #1b1b32;
      /* ‚ö´ DARK BACKGROUND: Deep blue-grey for the game table */
      
      --light-grey: #f5f6f7;
      /* ‚ö™ LIGHT GREY: For game areas and cards */
      
      --black: #000;
      /* ‚ö´ TRUE BLACK: For text and borders */
      
      --white: #fff;
      /* ‚ö™ TRUE WHITE: For contrast elements */
      
      --grey: #3b3b4f;
      /* üîò MEDIUM GREY: For disabled elements */
      
      --golden-yellow: #fecc4c;
      /* üü° GOLDEN YELLOW: Bright accent color */
      
      --yellow: #ffcc4c;
      /* üíõ YELLOW: Slightly different for gradients */
      
      --gold: #feac32;
      /* ü•á GOLD: Primary button color */
      
      --orange: #ffac33;
      /* üü† ORANGE: For button gradients */
      
      --dark-orange: #f89808;
      /* üî∂ DARK ORANGE: For button hover effects */
    }
    
    body {
      background-color: var(--dark-grey);
      /* üéÆ GAME BACKGROUND: Dark theme like a casino table */
      /* Creates an immersive gaming environment */
    }
    
    header {
      color: var(--light-grey);
      /* ‚ö™ HEADER TEXT: Light text on dark background */
      /* High contrast makes the title and rules easy to read */
      
      text-align: center;
      /* ‚öñÔ∏è CENTERED TEXT: Title and rules aligned in the middle */
      /* Like having the game title centered on the box cover */
    }
    
    h1 {
      font-size: 2.5rem;
      /* üìè LARGE TITLE: 2.5 times the base font size */
      /* Makes the game title stand out, like on a box cover */
      
      margin: 25px 0;
      /* üå¨Ô∏è VERTICAL SPACING: Room above and below the title */
      /* Creates breathing space between elements */
    }
    
    .rules-container {
      display: none;
      /* üôà INITIALLY HIDDEN: Rules start hidden */
      /* Like keeping the rulebook closed until needed */
      
      background-color: var(--light-grey);
      /* üìÑ LIGHT BACKGROUND: Rules on light paper for readability */
      
      color: var(--black);
      /* üñãÔ∏è BLACK TEXT: Maximum contrast for easy reading */
      
      width: 50%;
      /* üìè CONTAINER WIDTH: Takes half the available width */
      /* Keeps rules readable without overwhelming the screen */
      
      margin: 20px auto;
      /* ‚öñÔ∏è CENTERED: Equal margins on left and right */
      /* Positions the rules box in the middle of the screen */
      
      height: 300px;
      /* üìè FIXED HEIGHT: Scroll for additional content */
      /* Like a compact rulebook with multiple pages */
      
      border-radius: 10px;
      /* üîÑ ROUNDED CORNERS: Softer visual appearance */
      /* Makes the rules card look like a game card */
      
      overflow-y: scroll;
      /* üìú VERTICAL SCROLL: For rules that don't fit */
      /* Allows all content to be accessible without taking up too much space */
    }
    
    .rules-container ul {
      list-style-type: none;
      /* üö´ NO BULLETS: Clean list appearance */
      /* Makes rules look more like a professional rulebook */
    }
    
    .points {
      margin-top: 15px;
      /* ‚¨ÜÔ∏è TOP SPACING: Gap before the points section */
      /* Visually separates sections of the rules */
    }
    
    main {
      background-color: var(--light-grey);
      /* üìÑ LIGHT BACKGROUND: Game area stands out against dark background */
      /* Like the felt on a game table */
      
      padding: 20px;
      /* üå¨Ô∏è INNER SPACING: Room around all content */
      /* Prevents elements from touching the edges */
      
      display: grid;
      /* üì¶ GRID LAYOUT: Organizes game elements in columns */
      /* Like organizing different areas on a board game */
      
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      /* üìè RESPONSIVE GRID: Columns adapt to available space */
      /* Columns must be at least 500px wide, then share available space */
      /* On smaller screens, they stack vertically */
      
      gap: 1rem;
      /* üìè GRID GAP: Space between grid items */
      /* Separates the game sections clearly */
      
      margin: auto;
      /* ‚öñÔ∏è CENTERED: Horizontally centered on the page */
      
      justify-items: center;
      /* ‚öñÔ∏è CENTERED ITEMS: Grid items centered in their cells */
      
      width: 50%;
      /* üìè CONTAINER WIDTH: Takes half the available width */
      /* Keeps the game area from being too wide on large screens */
      
      border-radius: 10px;
      /* üîÑ ROUNDED CORNERS: Softer visual appearance */
      /* Makes the game board look like a card or game mat */
    }
    
    #dice {
      display: flex;
      /* üì¶ FLEX LAYOUT: Arranges dice in a row */
      /* Like lining up dice after a roll */
      
      justify-content: space-around;
      /* ‚öñÔ∏è SPREAD EVENLY: Space distributed between dice */
      /* Gives each die room to breathe */
      
      margin-bottom: 15px;
      /* ‚¨áÔ∏è BOTTOM SPACE: Gap after the dice */
      /* Separates dice from the options below */
    }
    
    .die {
      width: 40px;
      /* üìè DIE WIDTH: Square dimensions */
      
      height: 40px;
      /* üìè DIE HEIGHT: Square dimensions */
      
      text-align: center;
      /* ‚öñÔ∏è CENTERED TEXT: Die value centered */
      /* Like real dice having centered pips */
      
      margin-right: 15px;
      /* ‚û°Ô∏è RIGHT SPACE: Gap between dice */
      /* Prevents dice from touching each other */
      
      border: 4px solid var(--black);
      /* üî≤ THICK BORDER: Bold outline for each die */
      /* Makes dice stand out like physical game pieces */
      
      padding: 10px;
      /* üå¨Ô∏è INNER SPACING: Room around the die value */
      /* Ensures the number doesn't touch the borders */
    }
    
    .rounds-text {
      text-align: center;
      /* ‚öñÔ∏è CENTERED TEXT: Rounds counter centered */
      /* Emphasizes this important game information */
    }
    
    input[type="radio"]:disabled + label {
      color: var(--grey);
      /* üîò DISABLED COLOR: Grey text for unavailable options */
      /* Visual feedback that these options can't be selected */
    }
    
    #score-history {
      margin-top: 15px;
      /* ‚¨ÜÔ∏è TOP SPACE: Gap before score history */
      /* Separates history from other elements */
      
      text-align: center;
      /* ‚öñÔ∏è CENTERED TEXT: History centered on page */
      
      list-style-position: inside;
      /* üìå BULLET POSITION: Bullets inside the container */
      /* Keeps list aligned properly even when centered */
    }
    
    .btn {
      cursor: pointer;
      /* üëÜ HAND CURSOR: Shows buttons are clickable */
      /* Interactive feedback for users */
      
      width: 200px;
      /* üìè BUTTON WIDTH: Fixed width for consistency */
      
      margin: 10px 0 10px 0.5rem;
      /* üå¨Ô∏è BUTTON MARGINS: Space around all buttons */
      /* Prevents buttons from touching each other */
      
      color: var(--black);
      /* ‚ö´ TEXT COLOR: Dark text for contrast */
      
      background-color: var(--gold);
      /* üü° BASE COLOR: Fallback if gradient fails */
      
      background-image: linear-gradient(var(--golden-yellow), var(--orange));
      /* üåÖ GRADIENT FILL: From yellow to orange */
      /* Creates a 3D button effect */
      
      border-color: var(--gold);
      /* üî≤ BORDER COLOR: Matches the button theme */
      
      border-width: 3px;
      /* üìè BORDER THICKNESS: Substantial border */
      /* Makes buttons look more tactile and clickable */
    }
    
    .btn:hover:enabled {
      background-image: linear-gradient(var(--yellow), var(--dark-orange));
      /* üîÜ HOVER STATE: Brighter gradient when mouse hovers */
      /* Only applies when button is enabled (:enabled) */
      /* Visual feedback for interactive elements */
    }
    
    @media (max-width: 992px) {
      /* üì± MEDIUM SCREENS: Tablets and smaller laptops */
      
      main {
        width: 100%;
        /* üìè FULL WIDTH: Game area expands to full width */
        /* Makes better use of available space on smaller screens */
      }
    }
    
    @media (max-width: 500px) {
      /* üì± SMALL SCREENS: Mobile phones */
      
      .btn {
        width: 120px;
        /* üìè NARROWER BUTTONS: Fit better on small screens */
        /* Ensures buttons don't overflow on tiny devices */
      }
    }
  </style>
</head>

<body>
  <!-- üé≤ ===== THE BODY: Where Our Dice Game Lives! ===== -->
  
  <header>
    <!-- üìú GAME HEADER: Title and rules section -->
    
    <h1>Advanced Dice Game</h1>
    <!-- üéÆ GAME TITLE: Bold, clear announcement of what we're playing -->
    
    <button class="btn" id="rules-btn" type="button">Show rules</button>
    <!-- üìú RULES TOGGLE: Button to show/hide game rules -->
    <!-- Keeps the interface clean until rules are needed -->
    
    <div class="rules-container">
      <!-- üìú RULES SECTION: Initially hidden, shows when requested -->
      
      <h2>Rules</h2>
      <!-- üìù SECTION TITLE: Clearly labels this as the rules -->
      
      <ul>
        <!-- üìã RULES LIST: Structured game instructions -->
        
        <li>There are total of six rounds</li>
        <!-- üî¢ GAME LENGTH: Sets clear expectations for game duration -->
        
        <li>You can only roll the dice three times per round</li>
        <!-- üé≤ ROLL LIMIT: Critical rule limiting player actions -->
        
        <li>To start the game, roll the dice</li>
        <!-- üé¨ STARTING ACTION: First step for the player -->
        
        <li>
          Then, choose from one of the selected scores or roll the dice again
        </li>
        <!-- üîÑ PLAYER CHOICE: Explains decision point after rolling -->
        
        <li>
          If you choose a selected score, then you will move to the next round
        </li>
        <!-- ‚û°Ô∏è ROUND ADVANCEMENT: How to progress in the game -->
        
        <li>
          If you decline to choose a selected score, then you can roll the
          dice again two more times
        </li>
        <!-- üîÑ REROLL OPTION: Alternative to score selection -->
      </ul>
      
      <h2 class="points">Points</h2>
      <!-- üíØ SCORING SECTION: Explains how points are earned -->
      
      <ul>
        <!-- üìã SCORING LIST: Different ways to score points -->
        
        <li>Three of a kind: Sum of all five dice</li>
        <!-- üé≤ SCORING OPTION: Three matching dice scores the sum -->
        
        <li>Four of a kind: Sum of all five dice</li>
        <!-- üé≤ SCORING OPTION: Four matching dice scores the sum -->
        
        <li>Full house: Three of a kind and a pair - 25 points</li>
        <!-- üé≤ SCORING OPTION: Three matching + a pair scores fixed 25 -->
        
        <li>
          Small straight: Four of the dice have consecutive values - 30 points
        </li>
        <!-- üé≤ SCORING OPTION: Four consecutive dice scores fixed 30 -->
        
        <li>
          Large straight: All five dice have consecutive values - 40 points
        </li>
        <!-- üé≤ SCORING OPTION: Five consecutive dice scores fixed 40 -->
      </ul>
    </div>
  </header>

  <main>
    <!-- üéÆ MAIN GAME AREA: Where gameplay happens -->
    
    <form id="game">
      <!-- üìã GAME FORM: Container for interactive elements -->
      <!-- Forms provide structure for user inputs -->
      
      <div id="dice">
        <!-- üé≤ DICE CONTAINER: Holds the five dice -->
        
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
        <div class="die"></div>
        <!-- üé≤ INDIVIDUAL DICE: Five dice for the game -->
        <!-- Each will display a random number when rolled -->
      </div>

      <p class="rounds-text">
        <!-- üìä GAME STATUS: Shows current round and rolls -->
        
        <strong>Rolls:</strong> <span id="current-round-rolls">0</span> |
        <!-- üé≤ ROLL COUNTER: Tracks rolls within current round -->
        <!-- Limited to 3 per round as per the rules -->
        
        <strong>Round:</strong> <span id="current-round">1</span>
        <!-- üî¢ ROUND COUNTER: Tracks which of the six rounds we're on -->
      </p>

      <div id="score-options">
        <!-- üìä SCORING OPTIONS: Available combinations to select -->
        
        <div>
          <input type="radio" name="score-options" id="three-of-a-kind" value="three-of-a-kind" disabled />
          <label for="three-of-a-kind">Three of a kind<span></span></label>
          <!-- üé≤ SCORE OPTION: Three matching dice -->
          <!-- Initially disabled until this combination is rolled -->
          <!-- <span> will show the calculated score -->
        </div>
        
        <div>
          <input type="radio" name="score-options" id="four-of-a-kind" value="four-of-a-kind" disabled />
          <label for="four-of-a-kind">Four of a kind<span></span></label>
          <!-- üé≤ SCORE OPTION: Four matching dice -->
        </div>
        
        <div>
          <input type="radio" name="score-options" id="full-house" value="full-house" disabled />
          <label for="full-house">Full house<span></span></label>
          <!-- üé≤ SCORE OPTION: Three matching + pair -->
        </div>
        
        <div>
          <input type="radio" name="score-options" id="small-straight" value="small-straight" disabled />
          <label for="small-straight">Small straight<span></span></label>
          <!-- üé≤ SCORE OPTION: Four consecutive values -->
        </div>
        
        <div>
          <input type="radio" name="score-options" id="large-straight" value="large-straight" disabled />
          <label for="large-straight">Large straight<span></span></label>
          <!-- üé≤ SCORE OPTION: Five consecutive values -->
        </div>

        <div>
          <input type="radio" name="score-options" id="none" value="none" disabled />
          <label for="none">None of the above<span></span></label>
          <!-- üé≤ FALLBACK OPTION: When no scoring combination is achieved -->
          <!-- Allows player to move on with zero points -->
        </div>
      </div>

      <button class="btn" id="keep-score-btn" type="button">
        Keep the above selected score
      </button>
      <!-- ‚úÖ CONFIRM BUTTON: Locks in the selected score option -->
      <!-- Advances to next round after selection -->
      
      <button class="btn" id="roll-dice-btn" type="button">
        Roll the dice
      </button>
      <!-- üé≤ ROLL BUTTON: Generates new random dice values -->
      <!-- Limited to 3 uses per round -->
    </form>

    <div id="scores">
      <!-- üìä SCORE SECTION: Tracks game progress -->
      
      <h3>Score history (Total score: <span id="total-score">0</span>)</h3>
      <!-- üìä RUNNING TOTAL: Shows accumulated points -->
      
      <ol id="score-history"></ol>
      <!-- üìã SCORE LIST: Ordered list of all scoring selections -->
      <!-- Each round's score will be added here -->
    </div>
  </main>
  <script>
    /* üé≤ ===== JAVASCRIPT: The Brain of Our Dice Game! ===== */
    
    /* üîç ===== DOM ELEMENT SELECTION: Connecting to Our Interface ===== */
    
    const listOfAllDice = document.querySelectorAll(".die");
    /* üé≤ DICE ELEMENTS: All five dice on the screen */
    /* querySelectorAll gets MULTIPLE elements matching ".die" */
    /* Returns a NodeList (similar to an array) with all 5 dice */
    
    const scoreInputs = document.querySelectorAll("#score-options input");
    /* üìã SCORING RADIOS: All radio button inputs */
    /* #score-options input = finds all inputs inside the score-options div */
    /* Descendant selector pattern - finds any inputs at any level within that container */
    
    const scoreSpans = document.querySelectorAll("#score-options span");
    /* üìä SCORE DISPLAYS: The empty spans that will show point values */
    /* These will be filled with text like ", score = 25" when options become available */
    
    const roundElement = document.getElementById("current-round");
    /* üî¢ ROUND DISPLAY: Shows which round we're on (1-6) */
    /* getElementById gets a SINGLE element with the exact ID */
    
    const rollsElement = document.getElementById("current-round-rolls");
    /* üé≤ ROLLS DISPLAY: Shows how many rolls in the current round (0-3) */
    
    const totalScoreElement = document.getElementById("total-score");
    /* üìä TOTAL SCORE: Shows the accumulated score so far */
    
    const scoreHistory = document.getElementById("score-history");
    /* üìã SCORE HISTORY: The list that will show all scores earned */
    /* This starts empty and gets filled as the game progresses */
    
    const rollDiceBtn = document.getElementById("roll-dice-btn");
    /* üé≤ ROLL BUTTON: Reference to the "Roll the dice" button */
    
    const keepScoreBtn = document.getElementById("keep-score-btn");
    /* ‚úÖ KEEP BUTTON: Reference to the "Keep score" button */
    
    const rulesContainer = document.querySelector(".rules-container");
    /* üìú RULES BOX: The expandable rules section */
    
    const rulesBtn = document.getElementById("rules-btn");
    /* üìú RULES TOGGLE: Button to show/hide rules */
    
    /* üèÅ ===== GAME STATE VARIABLES: Tracking Game Progress ===== */
    
    let diceValuesArr = []; 
    /* üé≤ DICE VALUES: Array storing current dice numbers */
    /* Starts empty, will hold five numbers (1-6) after rolling */
    
    let isModalShowing = false; 
    /* üìú RULES VISIBILITY: Tracks if rules are shown/hidden */
    /* false = hidden (default), true = visible */
    
    let score = 0; 
    /* üìä TOTAL SCORE: Player's accumulated points */
    /* Increases when player keeps a score option */
    
    let round = 1; 
    /* üî¢ CURRENT ROUND: Which round we're on (1-6) */
    /* Game ends after round 6 */
    
    let rolls = 0; 
    /* üé≤ ROLL COUNT: Number of times dice rolled this round */
    /* Limited to 3 per round */
    
    /* üé≤ ===== DICE ROLLING FUNCTION: Generate Random Values ===== */
    
    const rollDice = () => {
      /* üé≤ DICE ROLLER: Creates random values for all five dice */
      
      diceValuesArr = [];
      /* üßπ CLEAR ARRAY: Reset the dice values */
      /* Ensures we don't keep adding to the previous values */
    
      for (let i = 0; i < 5; i++) {
        /* üîÑ LOOP 5 TIMES: Once for each die */
        
        const randomDice = Math.floor(Math.random() * 6) + 1;
        /* üé≤ RANDOM NUMBER: Generates 1-6 like a real die */
        /* Math.random() = 0 to less than 1 (e.g., 0.74382) */
        /* * 6 = 0 to less than 6 (e.g., 4.46292) */
        /* Math.floor() = rounds down to integer (e.g., 4) */
        /* + 1 = gives us 1-6 instead of 0-5 (e.g., 5) */
        
        diceValuesArr.push(randomDice);
        /* ‚ûï ADD TO ARRAY: Store each die value */
        /* After loop completes, array will have 5 values */
      };
    
      listOfAllDice.forEach((dice, index) => {
        /* üîÑ UPDATE DISPLAY: Set each die's visible number */
        /* forEach loops through all dice elements */
        /* index = 0,1,2,3,4 (position in the NodeList) */
        
        dice.textContent = diceValuesArr[index];
        /* üìù SET NUMBER: Updates the text inside each die */
        /* textContent is safer than innerHTML for simple text */
      });
    };
    
    /* üìä ===== STATS UPDATE FUNCTION: Refresh Display ===== */
    
    const updateStats = () => {
      /* üìä UPDATE DISPLAY: Refresh the round and roll counters */
      
      rollsElement.textContent = rolls;
      /* üé≤ UPDATE ROLLS: Show current roll count (0-3) */
      
      roundElement.textContent = round;
      /* üî¢ UPDATE ROUND: Show current round number (1-6) */
    };
    
    /* üîò ===== RADIO OPTION UPDATE FUNCTION: Enable Scoring Options ===== */
    
    const updateRadioOption = (index, score) => {
      /* üîò ENABLE OPTION: Activate a scoring option when available */
      /* index = which radio button to update (0-5) */
      /* score = the point value to assign (e.g., 25) */
      
      scoreInputs[index].disabled = false;
      /* ‚úÖ ENABLE INPUT: Make the radio button clickable */
      /* Changes from greyed-out to normal appearance */
      
      scoreInputs[index].value = score;
      /* üíØ SET VALUE: Store the point value in the input */
      /* This value will be used when keeping score */
      
      scoreSpans[index].textContent = `, score = ${score}`;
      /* üìù SHOW SCORE: Display the points next to the option */
      /* Uses template literal to create ", score = 25" */
    };
    
    /* üìä ===== SCORE UPDATE FUNCTION: Record Selected Score ===== */
    
    const updateScore = (selectedValue, achieved) => {
      /* üìä RECORD SCORE: Add the selected points to total */
      /* selectedValue = point value as string (e.g., "25") */
      /* achieved = which combination was earned (e.g., "full-house") */
      
      score += parseInt(selectedValue);
      /* ‚ûï ADD TO TOTAL: Convert string to number and add */
      /* parseInt() ensures proper addition (not string concatenation) */
      
      totalScoreElement.textContent = score;
      /* üìù UPDATE DISPLAY: Show new total score */
    
      scoreHistory.innerHTML += `<li>${achieved} : ${selectedValue}</li>`;
      /* ‚ûï ADD HISTORY ITEM: Record this score in the list */
      /* Template literal creates an HTML list item */
      /* Displays something like "full-house : 25" */
    };
    
    /* üîç ===== DUPLICATES DETECTION FUNCTION: Find Matching Dice ===== */
    
    const getHighestDuplicates = (arr) => {
      /* üîç FIND MATCHES: Detect three or four of a kind */
      /* arr = array of dice values to analyze */
      
      const counts = {};
      /* üìä COUNTER OBJECT: Tracks occurrences of each number */
      /* Will contain entries like { 3: 2, 5: 3 } meaning "two 3's, three 5's" */
    
      for (const num of arr) {
        /* üîÑ COUNT OCCURRENCES: Loop through each die value */
        
        if (counts[num]) {
          counts[num]++; 
          /* ‚ûï INCREMENT: This number was seen before */
        } else {
          counts[num] = 1; 
          /* üÜï NEW ENTRY: First time seeing this number */
        }
      }
    
      let highestCount = 0;
      /* üî¢ TRACK MAXIMUM: Highest number of matching dice */
      /* Starts at 0, will be updated to 3, 4, or 5 if matches found */
    
      for (const num of arr) {
        /* üîÑ FIND MAX: Loop through dice again */
        
        const count = counts[num];
        /* üî¢ GET COUNT: How many times this value appears */
        
        if (count >= 3 && count > highestCount) {
          highestCount = count;
          /* ‚¨ÜÔ∏è UPDATE MAX: New highest count found */
          /* Only if at least 3 matching dice (minimum for scoring) */
        }
        if (count >= 4 && count > highestCount) {
          highestCount = count;
          /* ‚¨ÜÔ∏è UPDATE MAX: Four matching dice */
          /* This condition seems redundant with the above, but keeps code clear */
        }
      }
    
      const sumOfAllDice = arr.reduce((a, b) => a + b, 0);
      /* ‚ûï CALCULATE SUM: Total of all dice values */
      /* reduce() is like rolling all dice into a single sum */
      /* (a, b) => a + b means "add each element to the accumulator" */
      /* 0 is the starting value for the accumulator */
    
      if (highestCount >= 4) {
        updateRadioOption(1, sumOfAllDice);
        /* ‚úÖ ENABLE FOUR KIND: If 4+ matching dice found */
        /* Uses index 1 (second option in the list) */
      }
    
      if (highestCount >= 3) {
        updateRadioOption(0, sumOfAllDice);
        /* ‚úÖ ENABLE THREE KIND: If 3+ matching dice found */
        /* Uses index 0 (first option in the list) */
        /* Note: If 4+ found, both options are enabled */
      }
    };
    
    /* üè† ===== FULL HOUSE DETECTION FUNCTION: Find 3 + 2 Pattern ===== */
    
    const detectFullHouse = (arr) => {
      /* üè† FIND FULL HOUSE: Detect three of a kind plus a pair */
      /* arr = array of dice values to analyze */
      
      const counts = {};
      /* üìä COUNTER OBJECT: Same counting technique as before */
    
      for (const num of arr) {
        /* üîÑ COUNT OCCURRENCES: Using ternary operator */
        
        counts[num] = counts[num] ? counts[num] + 1 : 1;
        /* ‚ûï COUNT: If exists, increment; otherwise initialize to 1 */
        /* Compact version of the if/else from previous function */
      }
    
      const hasThreeOfAKind = Object.values(counts).includes(3);
      /* üîç CHECK FOR THREE: Does any number appear exactly 3 times? */
      /* Object.values(counts) gets just the counts: [2,3] */
      /* .includes(3) checks if exactly 3 appears in that array */
      
      const hasPair = Object.values(counts).includes(2);
      /* üîç CHECK FOR PAIR: Does any number appear exactly 2 times? */
    
      if (hasThreeOfAKind && hasPair) {
        updateRadioOption(2, 25); 
        /* ‚úÖ ENABLE FULL HOUSE: If both conditions are true */
        /* Uses index 2 (third option) with fixed score of 25 */
      }
    };
    
    /* üìà ===== STRAIGHTS DETECTION FUNCTION: Find Sequential Dice ===== */
    
    const checkForStraights = (arr) => {
      /* üìà FIND STRAIGHTS: Detect consecutive dice values */
      /* arr = array of dice values to analyze */
      
      const sortedNumbersArr = arr.sort((a, b) => a - b);
      /* üìä SORT NUMBERS: Arrange dice in ascending order */
      /* (a, b) => a - b is a comparison function for numeric sort */
      /* Transforms [3,1,5,4,2] to [1,2,3,4,5] */
      
      const uniqueNumbersArr = [...new Set(sortedNumbersArr)];
      /* üîÑ REMOVE DUPLICATES: Keep only unique values */
      /* new Set() creates collection with no duplicates */
      /* [...Set] spreads it back into an array */
      /* Transforms [1,2,2,3,4] to [1,2,3,4] */
      
      const uniqueNumbersStr = uniqueNumbersArr.join("");
      /* üîó CREATE STRING: Join numbers without separators */
      /* Makes pattern matching much easier */
      /* Transforms [1,2,3,4] to "1234" */
    
      const smallStraightsArr = ["1234", "2345", "3456"]; 
      /* üìã SMALL STRAIGHT PATTERNS: Four consecutive numbers */
      
      const largeStraightsArr = ["12345", "23456"];      
      /* üìã LARGE STRAIGHT PATTERNS: Five consecutive numbers */
    
      if (smallStraightsArr.some(straight => uniqueNumbersStr.includes(straight))) {
        updateRadioOption(3, 30); 
        /* ‚úÖ ENABLE SMALL STRAIGHT: If pattern found */
        /* .some() checks if ANY pattern matches */
        /* .includes() checks if the string contains the pattern */
        /* Uses index 3 (fourth option) with fixed score of 30 */
      }
    
      if (largeStraightsArr.includes(uniqueNumbersStr)) {
        updateRadioOption(4, 40); 
        /* ‚úÖ ENABLE LARGE STRAIGHT: If exact pattern found */
        /* Here we need EXACT match, not just containing the pattern */
        /* Uses index 4 (fifth option) with fixed score of 40 */
      }
    };
    
    /* üßπ ===== RESET RADIO OPTIONS FUNCTION: Clear Selections ===== */
    
    const resetRadioOptions = () => {
      /* üßπ RESET OPTIONS: Clear and disable all scoring options */
      
      scoreInputs.forEach((input) => {
        /* üîÑ PROCESS EACH INPUT: Loop through all radio buttons */
        
        input.disabled = true;
        /* üîí DISABLE: Make option unclickable */
        /* Grey out the option until it becomes available */
        
        input.checked = false;
        /* üîò UNCHECK: Remove any previous selection */
      });
    
      scoreSpans.forEach((span) => {
        /* üîÑ PROCESS EACH SPAN: Loop through all score displays */
        
        span.textContent = "";
        /* üßπ CLEAR TEXT: Remove previous scores */
        /* Removes ", score = 25" text from previous roll */
      });
    };
    
    /* üîÑ ===== RESET GAME FUNCTION: Start Fresh ===== */
    
    const resetGame = () => {
      /* üîÑ RESET GAME: Return everything to initial state */
      /* Called after game completes (after 6 rounds) */
      
      diceValuesArr = [0, 0, 0, 0, 0];
      /* üßπ RESET DICE: Back to all zeros */
      /* These will display until first roll */
      
      score = 0;
      /* üßπ RESET SCORE: Back to zero points */
      
      round = 1;
      /* üßπ RESET ROUND: Back to first round */
      
      rolls = 0;
      /* üßπ RESET ROLLS: Back to zero rolls */
    
      listOfAllDice.forEach((dice, index) => {
        dice.textContent = diceValuesArr[index];
        /* üßπ RESET DICE DISPLAY: Show zeros on screen */
      });
    
      totalScoreElement.textContent = score;
      /* üßπ RESET SCORE DISPLAY: Show zero points */
      
      scoreHistory.innerHTML = "";
      /* üßπ CLEAR HISTORY: Remove all previous scores */
      /* innerHTML = "" replaces all content with nothing */
    
      rollsElement.textContent = rolls;
      roundElement.textContent = round;
      /* üßπ RESET COUNTERS: Update displays to initial values */
    
      resetRadioOptions();
      /* üßπ RESET OPTIONS: Reuse existing function */
      /* Follows DRY principle (Don't Repeat Yourself) */
    };
    
    /* üé≤ ===== ROLL DICE BUTTON EVENT: Main Game Action ===== */
    
    rollDiceBtn.addEventListener("click", () => {
      /* üé≤ ROLL BUTTON CLICK: Handle dice rolling action */
      
      if (rolls === 3) {
        /* üõë CHECK LIMIT: Has player already rolled 3 times? */
        
        alert("You have made three rolls this round. Please select a score.");
        /* ‚ö†Ô∏è ALERT USER: Show error message */
        /* Prevents exceeding the roll limit per round */
      } else {
        /* ‚úÖ PROCEED: Roll is allowed */
        
        rolls++; 
        /* ‚¨ÜÔ∏è INCREMENT ROLLS: Count this roll */
        
        resetRadioOptions(); 
        /* üßπ RESET OPTIONS: Clear previous options */
        
        rollDice(); 
        /* üé≤ ROLL DICE: Generate new random numbers */
        
        updateStats(); 
        /* üìä UPDATE DISPLAY: Show new roll count */
        
        getHighestDuplicates(diceValuesArr);
        detectFullHouse(diceValuesArr);
        checkForStraights(diceValuesArr);
        /* üîç DETECT COMBINATIONS: Check for all possible scoring options */
        
        updateRadioOption(5, 0);
        /* ‚úÖ ENABLE "NONE" OPTION: Always allow skipping */
        /* Index 5 = "None of the above" with 0 points */
        /* This option is always available after rolling */
      }
    });
    
    /* üìú ===== RULES BUTTON EVENT: Toggle Rules Display ===== */
    
    rulesBtn.addEventListener("click", () => {
      /* üìú RULES BUTTON CLICK: Show or hide the rules */
      
      isModalShowing = !isModalShowing;
      /* üîÑ TOGGLE STATE: Flip between true/false */
      /* ! (logical NOT) reverses the boolean value */
    
      if (isModalShowing) {
        /* ‚úÖ RULES SHOWING: Update UI for visible rules */
        
        rulesBtn.textContent = "Hide rules";
        /* üìù UPDATE BUTTON: Change text to reflect action */
        
        rulesContainer.style.display = "block";
        /* üìù SHOW RULES: Make rules container visible */
      } else {
        /* ‚ùå RULES HIDDEN: Update UI for hidden rules */
        
        rulesBtn.textContent = "Show rules";
        /* üìù UPDATE BUTTON: Change text to reflect action */
        
        rulesContainer.style.display = "none";
        /* üìù HIDE RULES: Make rules container invisible */
      }
    });
    
    /* üíæ ===== KEEP SCORE BUTTON EVENT: Save Selected Score ===== */
    
    keepScoreBtn.addEventListener("click", () => {
      /* üíæ KEEP SCORE CLICK: Record selected points and advance */
      
      let selectedValue; 
      /* üî¢ SELECTED POINTS: Will store chosen score value */
      
      let achieved;     
      /* üìã ACHIEVED COMBO: Will store the type of scoring */
    
      for (const radioButton of scoreInputs) {
        /* üîÑ CHECK SELECTIONS: Loop through all radio buttons */
        
        if (radioButton.checked) {
          /* ‚úÖ FOUND SELECTION: This radio is checked */
          
          selectedValue = radioButton.value; 
          /* üíæ STORE VALUE: Get the points value */
          
          achieved = radioButton.id;         
          /* üíæ STORE TYPE: Get the combination name */
          
          break; 
          /* üõë STOP SEARCHING: We found the selection */
          /* break exits the loop early for efficiency */
        }
      }
    
      if (selectedValue) {
        /* ‚úÖ VALID SELECTION: User has chosen an option */
        
        rolls = 0;  
        /* üßπ RESET ROLLS: Start fresh for new round */
        
        round++;   
        /* ‚¨ÜÔ∏è NEXT ROUND: Increment round counter */
        
        updateStats(); 
        /* üìä UPDATE DISPLAY: Show new round */
        
        resetRadioOptions(); 
        /* üßπ RESET OPTIONS: Clear for next round */
        
        updateScore(selectedValue, achieved); 
        /* üìä RECORD SCORE: Add to total and history */
        
        if (round > 6) {
          /* üèÅ GAME OVER CHECK: Have all 6 rounds been played? */
          
          setTimeout(() => {
            /* ‚è±Ô∏è SLIGHT DELAY: Wait 500ms before showing alert */
            /* This ensures UI updates are visible first */
            
            alert(`Game Over! Your total score is ${score}`);
            /* üèÜ FINAL SCORE: Show game over message */
            
            resetGame();
            /* üîÑ START OVER: Reset everything for a new game */
          }, 500);
        }
      } else {
        /* ‚ùå NO SELECTION: User hasn't chosen an option */
        
        alert("Please select an option or roll the dice");
        /* ‚ö†Ô∏è ALERT USER: Show error message */
        /* Reminds player they need to select an option or roll */
      }
    });
  </script>
</body>

</html>

<!-- üéØ ===== DICE GAME ARCHITECTURE SUMMARY ===== -->
<!-- 
üé≤ GAME STRUCTURE:
‚îÇ
‚îú‚îÄ‚îÄ üß† HEAD (setup)
‚îÇ   ‚îî‚îÄ‚îÄ üé® CSS with gaming theme:
‚îÇ       ‚îú‚îÄ‚îÄ üéÆ Dark background with gold accents
‚îÇ       ‚îú‚îÄ‚îÄ üì¶ Grid and flex layouts for game areas
‚îÇ       ‚îú‚îÄ‚îÄ üé≤ Visual styling for dice elements
‚îÇ       ‚îî‚îÄ‚îÄ üì± Responsive design for all devices
‚îÇ
‚îú‚îÄ‚îÄ üìÑ BODY (interface)
‚îÇ   ‚îú‚îÄ‚îÄ üìú Header with rules section
‚îÇ   ‚îî‚îÄ‚îÄ üéÆ Main game area
‚îÇ       ‚îú‚îÄ‚îÄ üé≤ Five dice elements
‚îÇ       ‚îú‚îÄ‚îÄ üìä Round and roll counters
‚îÇ       ‚îú‚îÄ‚îÄ üîò Scoring options (radio buttons)
‚îÇ       ‚îú‚îÄ‚îÄ üîò Game control buttons
‚îÇ       ‚îî‚îÄ‚îÄ üìã Score history section
‚îÇ
‚îî‚îÄ‚îÄ üßÆ JAVASCRIPT (game logic)
    ‚îú‚îÄ‚îÄ üé≤ Dice rolling mechanics
    ‚îú‚îÄ‚îÄ üîç Pattern detection algorithms
    ‚îÇ   ‚îú‚îÄ‚îÄ Three/four of a kind
    ‚îÇ   ‚îú‚îÄ‚îÄ Full house detection
    ‚îÇ   ‚îî‚îÄ‚îÄ Straight sequences
    ‚îú‚îÄ‚îÄ üìä Scoring system
    ‚îú‚îÄ‚îÄ üéÆ Game state management
    ‚îî‚îÄ‚îÄ üîÑ Round progression logic

üéÆ GAME MECHANICS:
‚îú‚îÄ‚îÄ 6 total rounds with 3 rolls per round
‚îú‚îÄ‚îÄ 5 scoring options with different point values
‚îú‚îÄ‚îÄ Strategic decisions between rerolling and keeping score
‚îî‚îÄ‚îÄ Game state tracking via DOM updates

üß† PROGRAMMING CONCEPTS:
‚îú‚îÄ‚îÄ üì¶ Array manipulation (sort, filter, reduce)
‚îú‚îÄ‚îÄ üîç Pattern detection with string comparison
‚îú‚îÄ‚îÄ üé≤ Randomization with Math.random()
‚îú‚îÄ‚îÄ üîÑ Event-driven architecture
‚îî‚îÄ‚îÄ üìä Object-oriented data tracking

A perfect example of combining HTML, CSS, and JavaScript to create an interactive dice game! üé≤‚ú®
-->
```
</TabItem>

</Tabs>

### The Most Difficult Project

It was by far the most difficult project I've completed. There were few steps but they were extremely complex. Now I understand why this is the freeCodeCamp course with the highest abandonment rate.<br />
I didn't like it due to the subject matter: it wasn't a game I knew and it didn't excite me to play it before starting the project to understand the logic, nor after implementing it. The fact is, I learned a lot. In projects like this one, that leave you with "blank canvas", just like in certification projects, the main difficulty lies in putting the pieces together and thus summarizing everything you've learned before.<br />
I missed not having a single complete guide but I was still able to find the information since it's like having two guides. I was waiting to finish the course to merge them but it's possible I'll do it sooner, because it's a step that has always helped me reorganize concepts in my mind.

### The Reflection: Learning Strategy

I'm undecided between doing the Google UX Course 6 or starting the certification project right away, but reading what I've written, the most logical thing that emerges is: merge the guide, do the Google UX course to break away from the full immersion with freeCodeCamp, then start the 4th certification project at full speed.<br />
Thinking about it, it would also be smart to see if the guide needs modifications. After all, I made most of these changes while using it for certification projects, where it became essential. When I have doubts, consulting the guide is my first step, the second is MDN Web Docs, even though lately less so, the third, as a last resort, is the code tutor.<br />
AI for deepening concepts is exceptional, although it's like playing heads or tails hoping what it says is correct. It's also excellent for suggesting alternatives, but it's a tool that makes you lazy quite a bit. A bike with training wheels that if you don't learn to remove them you keep for life.<br />
To mitigate the hallucination risk, for almost 2 months I've replaced Claude with Perplexity, always setting Claude or Gemini as the model, both with chain of thought active, switching between models based on the desired temperament. This way I ensure the performance of the best models accompanied by verifiable sources. Sometimes I check actively, even though I should do it more often, and I discover really interesting sites.

### The Three Critical Concepts

I've noted down some concepts based on comparisons between freeCodeCamp's approach and better alternatives. Nothing was wrong, after all who am I to say otherwise? But exploring the alternatives led me to think critically.

#### 1. style.display vs classList.toggle() - The SRP

FreeCodeCamp proposed:

```javascript
if (isModalShowing) {
  rulesBtn.textContent = "Hide rules";
  rulesContainer.style.display = "block";
} else {
  rulesBtn.textContent = "Show rules";
  rulesContainer.style.display = "none";
}
```

This solution directly modifies the inline styles of the HTML element. Following the Single Responsibility Principle it makes much more sense to separate CSS from JavaScript:

```css
.rules-container {
  display: none;
}

.rules-container.show {
  display: block;
}
```

And in JavaScript:

```javascript
rulesContainer.classList.toggle("show");
rulesBtn.textContent = isModalShowing ? "Hide rules" : "Show rules";
```

This way we don't have CSS pieces in JavaScript, but rather two distinct documents: JavaScript only deals with calling the style from CSS, not creating it.

#### 2. parseInt() vs Number() - Semantic Rigor

FreeCodeCamp's approach was `score += parseInt(selectedValue);`

I had inserted `score += Number(selectedValue);`

Both are correct, but **Number() seems to be more rigorous**. Here's why:

| Aspect | parseInt() | Number() |
|--------|-----------|----------|
| "15" | 15 ‚úÖ | 15 ‚úÖ |
| "15.7" | 15 (truncates decimals) | 15.7 (keeps decimals) |
| "15px" | 15 (ignores rest) | NaN (error) |
| "" | NaN | 0 |

Number() is more rigorous because it fails when it encounters invalid input, while parseInt() does "optimistic" conversions. Depending on the context, the rigor of Number() can be preferable for catching input errors.

#### 3. innerHTML += vs createElement() - Performance and DOM Integrity

This point emerged from the code tutor who rightly pointed out that:

```javascript
scoreHistory.innerHTML += `<li>${achieved} : ${selectedValue}</li>`;
```

It's short and readable, but the better solution, albeit more verbose, is:

```javascript
const historyItem = document.createElement("li");
historyItem.textContent = `${achieved} : ${selectedValue}`;
scoreHistory.appendChild(historyItem);
```

The reason why is really interesting: with `innerHTML +=`, having elements already present:

```html
<li>Three of a kind : 15</li>
<li>Four of a kind : 20</li>
<li>Full house : 25</li>
```

Adding the 4th element with `innerHTML +=`, the browser destroys the first 3 and recreates all 4 from scratch! With `appendChild()` a new element is simply added, leaving the others intact.<br />
This happens because in scoreHistory, with the other 3 elements present, the browser will read all existing HTML (referring only to scoreHistory in this case), convert it to a string, add the new one and destroy the other elements from the DOM, risking changes to their states from what they were before.<br />
`innerHTML` remains excellent when you want to create the content of an element from scratch (with assignment, not concatenation), but for iterative appends `createElement()` + `appendChild()` is decidedly superior.<br />

### What I Learned

**Pattern Matching Algorithms:**
- Detecting Three/Four of a Kind by counting occurrences of numbers
- Detecting Full House by verifying the presence of groups of 3 and 2
- Detecting Straight by converting arrays to strings for pattern matching
- Using `Set` to remove duplicates: `[...new Set(arr)]`

**Array Methods and Iteration:**
- `.forEach()` to iterate and modify DOM elements
- `.reduce()` to accumulate values (sum of dice)
- `.sort()` with numeric callback to sort arrays
- `.includes()` to search patterns in strings
- `.some()` to verify if at least one element satisfies a condition

**Object Manipulation:**
- Counting element occurrences by creating objects `{ number: count }`
- `Object.values()` to extract only values from an object
- Inline ternary operator: `counts[num] = counts[num] ? counts[num] + 1 : 1`

**Event Handling and Validation:**
- Guard clauses to check preconditions before executing code
- Input validation before processing user selections
- `addEventListener()` to handle interactions
- `setTimeout()` to delay execution (allows UI update before alert)

**Professional Code Patterns:**
- DRY (Don't Repeat Yourself): refactoring the `updateRadioOption(5, 0)` call to a single location
- Separation of concerns: specific functions for each type of detection
- Early exit: using `break` to exit loops when finding what you seek
- Semantic naming that explains the "what" not the "how"

**Critical Differences Between Methods:**
- `textContent` vs `innerHTML`: textContent is safer, innerHTML recreates DOM
- Assignment vs concatenation: `=` vs `+=` have different performance implications
- `style.display` vs `classList.toggle()`: CSS/JS separation vs inline styles

***

**Next Project**: Build a Cash Register (CERTIFICATION PROJECT!)
