---
sidebar_position: 4
sidebar_label: 'Platformer Game'
title: 'Platformer Game'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Platformer Game

<img alt="Main menu showing Code Warrior title with Start Game button" src="https://github.com/user-attachments/assets/e70fcae2-8c73-4f3f-96eb-9dca9beea1bf" />
<img alt="Platformer game started with player character on platforms" src="https://github.com/user-attachments/assets/e81626f0-009c-47ac-96e0-f70c91ac0870" />
<img alt="Player character near yellow intermediate checkpoint" src="https://github.com/user-attachments/assets/36b7107b-727a-4a0e-928c-a30ada65c4cd" />
<img alt="Victory screen showing congratulations for reaching final checkpoint" src="https://github.com/user-attachments/assets/3c2c7a83-18e5-4546-b936-2e381c7d1ec9" />

### The Project

Platformer game developed with intermediate object-oriented programming in JavaScript. An application that demonstrates fluid animations, physics engine, collision detection, and advanced state management to create a complete platform game.

### Source Code

<Tabs>
<TabItem value="html" label="index.html" default>

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Learn Intermediate OOP by Building a Platformer Game</title>
  </head>
  <body>
    <div class="start-screen">
      <h1 class="main-title">freeCodeCamp Code Warrior</h1>
      <p class="instructions">
        Help the main player navigate to the yellow checkpoints.
      </p>
      <p class="instructions">
        Use the keyboard arrows to move the player around.
      </p>
      <p class="instructions">You can also use the spacebar to jump.</p>
      <div class="btn-container">
        <button class="btn" id="start-btn">Start Game</button>
      </div>
    </div>
    <div class="checkpoint-screen">
      <h2>Congrats!</h2>
      <p>You reached the last checkpoint.</p>
    </div>
    <canvas id="canvas"></canvas>
    <script src="./script.js"></script>
  </body>
</html>
```
</TabItem>

<TabItem value="css" label="styles.css">

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --main-bg-color: #0a0a23;
  --section-bg-color: #ffffff;
  --golden-yellow: #feac32;
}

body {
  background-color: var(--main-bg-color);
}

.start-screen {
  background-color: var(--section-bg-color);
  width: 100%;
  position: absolute;
  top: 50%;
  left: 50%;
  margin-right: -50%;
  transform: translate(-50%, -50%);
  border-radius: 30px;
  padding: 20px;
  padding-bottom: 5px;
}

.main-title {
  text-align: center;
}

.instructions {
  text-align: center;
  font-size: 1.2rem;
  margin: 15px;
  line-height: 2rem;
}

.btn {
  cursor: pointer;
  width: 100px;
  margin: 10px;
  color: #0a0a23;
  font-size: 18px;
  background-color: var(--golden-yellow);
  background-image: linear-gradient(#fecc4c, #ffac33);
  border-color: var(--golden-yellow);
  border-width: 3px;
}

.btn:hover {
  background-image: linear-gradient(#ffcc4c, #f89808);
}

.btn-container {
  display: flex;
  align-items: center;
  justify-content: center;
}

.checkpoint-screen {
  position: absolute;
  left: 0;
  right: 0;
  margin-left: auto;
  margin-right: auto;
  width: 100%;
  text-align: center;
  background-color: var(--section-bg-color);
  border-radius: 20px;
  padding: 10px;
  display: none;
}

#canvas {
  display: none;
}

@media (min-width: 768px) {
  .start-screen {
    width: 60%;
    max-width: 700px;
  }

  .checkpoint-screen {
    max-width: 300px;
  }
}
```
</TabItem>

<TabItem value="js" label="script.js">

```js
const startBtn = document.getElementById("start-btn");
const canvas = document.getElementById("canvas");
const startScreen = document.querySelector(".start-screen");
const checkpointScreen = document.querySelector(".checkpoint-screen");
const checkpointMessage = document.querySelector(".checkpoint-screen > p");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;
const gravity = 0.5;
let isCheckpointCollisionDetectionActive = true;

const proportionalSize = (size) => {
  return innerHeight < 500 ? Math.ceil((size / 500) * innerHeight) : size;
}

class Player {
  constructor() {
    this.position = {
      x: proportionalSize(10),
      y: proportionalSize(400),
    };
    this.velocity = {
      x: 0,
      y: 0,
    };
    this.width = proportionalSize(40);
    this.height = proportionalSize(40);
  }
  draw() {
    ctx.fillStyle = "#99c9ff";
    ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
  }
  
  update() {
    this.draw();
    this.position.x += this.velocity.x;
    this.position.y += this.velocity.y;

    if (this.position.y + this.height + this.velocity.y <= canvas.height) {
      if (this.position.y < 0) {
        this.position.y = 0;
        this.velocity.y = gravity;
      }
      this.velocity.y += gravity;
    } else {
      this.velocity.y = 0;
    }

    if (this.position.x < this.width) {
      this.position.x = this.width;
    }

    if (this.position.x >= canvas.width - this.width * 2) {
      this.position.x = canvas.width - this.width * 2;
    }
  }
}

class Platform {
  constructor(x, y) {
    this.position = {
      x,
      y,
    };
    this.width = 200;
    this.height = proportionalSize(40);
  }
  draw() {
    ctx.fillStyle = "#acd157";
    ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
  }
}

class CheckPoint {
  constructor(x, y, z) {
    this.position = {
      x,
      y,
    };
    this.width = proportionalSize(40);
    this.height = proportionalSize(70);
    this.claimed = false;
  };

  draw() {
    ctx.fillStyle = "#f1be32";
    ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
  }
  claim() {
    this.width = 0;
    this.height = 0;
    this.position.y = Infinity;
    this.claimed = true;
  }
};

const player = new Player();

const platformPositions = [
  { x: 500, y: proportionalSize(450) },
  { x: 700, y: proportionalSize(400) },
  { x: 850, y: proportionalSize(350) },
  { x: 900, y: proportionalSize(350) },
  { x: 1050, y: proportionalSize(150) },
  { x: 2500, y: proportionalSize(450) },
  { x: 2900, y: proportionalSize(400) },
  { x: 3150, y: proportionalSize(350) },
  { x: 3900, y: proportionalSize(450) },
  { x: 4200, y: proportionalSize(400) },
  { x: 4400, y: proportionalSize(200) },
  { x: 4700, y: proportionalSize(150) },
];

const platforms = platformPositions.map(
  (platform) => new Platform(platform.x, platform.y)
);

const checkpointPositions = [
  { x: 1170, y: proportionalSize(80), z: 1 },
  { x: 2900, y: proportionalSize(330), z: 2 },
  { x: 4800, y: proportionalSize(80), z: 3 },
];

const checkpoints = checkpointPositions.map(
  (checkpoint) => new CheckPoint(checkpoint.x, checkpoint.y, checkpoint.z)
);

const animate = () => {
  requestAnimationFrame(animate);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  platforms.forEach((platform) => {
    platform.draw();
  });

  checkpoints.forEach(checkpoint => {
    checkpoint.draw();
  });

  player.update();

  if (keys.rightKey.pressed && player.position.x < proportionalSize(400)) {
    player.velocity.x = 5;
  } else if (keys.leftKey.pressed && player.position.x > proportionalSize(100)) {
    player.velocity.x = -5;
  } else {
    player.velocity.x = 0;

    if (keys.rightKey.pressed && isCheckpointCollisionDetectionActive) {
      platforms.forEach((platform) => {
        platform.position.x -= 5;
      });

      checkpoints.forEach((checkpoint) => {
        checkpoint.position.x -= 5;
      });
    
    } else if (keys.leftKey.pressed && isCheckpointCollisionDetectionActive) {
      platforms.forEach((platform) => {
        platform.position.x += 5;
      });

      checkpoints.forEach((checkpoint) => {
        checkpoint.position.x += 5;
      });
    }
  }

  platforms.forEach((platform) => {
    const collisionDetectionRules = [
      player.position.y + player.height <= platform.position.y,
      player.position.y + player.height + player.velocity.y >= platform.position.y,
      player.position.x >= platform.position.x - player.width / 2,
      player.position.x <=
        platform.position.x + platform.width - player.width / 3,
    ];

    if (collisionDetectionRules.every((rule) => rule)) {
      player.velocity.y = 0;
      return;
    }

    const platformDetectionRules = [
      player.position.x >= platform.position.x - player.width / 2,
      player.position.x <=
        platform.position.x + platform.width - player.width / 3,
      player.position.y + player.height >= platform.position.y,
      player.position.y <= platform.position.y + platform.height,
    ];

    if (platformDetectionRules.every(rule => rule)) {
      player.position.y = platform.position.y + player.height;
      player.velocity.y = gravity;
    };
  });

  checkpoints.forEach((checkpoint, index, checkpoints) => {
    const checkpointDetectionRules = [
      player.position.x >= checkpoint.position.x,
      player.position.y >= checkpoint.position.y,
      player.position.y + player.height <=
        checkpoint.position.y + checkpoint.height,
      isCheckpointCollisionDetectionActive,
      player.position.x - player.width <=
        checkpoint.position.x - checkpoint.width + player.width * 0.9,
      index === 0 || checkpoints[index - 1].claimed === true,
    ];

    if (checkpointDetectionRules.every((rule) => rule)) {
      checkpoint.claim();


      if (index === checkpoints.length - 1) {
        isCheckpointCollisionDetectionActive = false;
        showCheckpointScreen("You reached the final checkpoint!");
        movePlayer("ArrowRight", 0, false);
      } else if (player.position.x >= checkpoint.position.x && player.position.x <= checkpoint.position.x + 40) {
        showCheckpointScreen("You reached a checkpoint!");
      }


    };
  });
}


const keys = {
  rightKey: {
    pressed: false
  },
  leftKey: {
    pressed: false
  }
};

const movePlayer = (key, xVelocity, isPressed) => {
  if (!isCheckpointCollisionDetectionActive) {
    player.velocity.x = 0;
    player.velocity.y = 0;
    return;
  }

  switch (key) {
    case "ArrowLeft":
      keys.leftKey.pressed = isPressed;
      if (xVelocity === 0) {
        player.velocity.x = xVelocity;
      }
      player.velocity.x -= xVelocity;
      break;
    case "ArrowUp":
    case " ":
    case "Spacebar":
      player.velocity.y -= 8;
      break;
    case "ArrowRight":
      keys.rightKey.pressed = isPressed;
      if (xVelocity === 0) {
        player.velocity.x = xVelocity;
      }
      player.velocity.x += xVelocity;
  }
}

const startGame = () => {
  canvas.style.display = "block";
  startScreen.style.display = "none";
  animate();
}

const showCheckpointScreen = (msg) => {
  checkpointScreen.style.display = "block";
  checkpointMessage.textContent = msg;
  if (isCheckpointCollisionDetectionActive) {
    setTimeout(() => (checkpointScreen.style.display = "none"), 2000);
  }
};

startBtn.addEventListener("click", startGame);

window.addEventListener("keydown", ({ key }) => {
  movePlayer(key, 8, true);
});

window.addEventListener("keyup", ({ key }) => {
  movePlayer(key, 0, false);
});
```

</TabItem> 

<TabItem value="commented" label="explained">

```html
<!DOCTYPE html>
<!-- üéÆ HTML5 DECLARATION: "Welcome to our 2D Platformer Game!" -->
<!-- It's like placing the foundation for our digital playground! üèóÔ∏è -->

<html lang="en">
<!-- üåç MAIN CONTAINER: The entire game universe -->
<!-- lang="en" = English language, universal for coding experiences -->

  <head>
    <!-- üß† THE COMMAND CENTER: Where we set up the game environment -->
    <!-- Like the control room of an arcade machine! üïπÔ∏è -->
    
    <meta charset="UTF-8" />
    <!-- üìù CHARACTER ENCODING: Supports all text symbols needed for our game -->
    <!-- UTF-8 ensures everything from game text to code comments displays correctly -->
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- üîÑ BROWSER COMPATIBILITY: Ensures modern IE rendering -->
    <!-- Tells Internet Explorer to use its most modern rendering engine -->
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- üì± RESPONSIVE SETUP: "This game adapts to any screen!" -->
    <!-- Makes our game properly sized on all devices from phones to desktops -->
    
    <title>Learn Intermediate OOP by Building a Platformer Game</title>
    <!-- üìë TAB TITLE: Educational purpose clearly defined -->
    <!-- OOP = Object-Oriented Programming, the foundation of modern game development -->
    
    <style>
      /* üé® ===== CSS STYLES: The Visual Game World ===== */
      
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        /* üßπ CLEAN SLATE: Reset all browser default spacing */
        /* Ensures our game looks consistent across all browsers */
        /* Like leveling the ground before building our game world */
      }
      
      :root {
        --main-bg-color: #0a0a23;
        --section-bg-color: #ffffff;
        --golden-yellow: #feac32;
        /* üé® COLOR VARIABLES: Central palette definition */
        /* Using CSS variables makes theme changes easy and consistent */
        /* Like defining the main colors for our game world */
      }
      
      body {
        background-color: var(--main-bg-color);
        /* üåå DEEP BLUE BACKGROUND: Creates an immersive atmosphere */
        /* Dark backgrounds reduce eye strain during gameplay */
      }
      
      .start-screen {
        background-color: var(--section-bg-color);
        width: 100%;
        position: absolute;
        top: 50%;
        left: 50%;
        margin-right: -50%;
        transform: translate(-50%, -50%);
        /* ‚öñÔ∏è PERFECT CENTERING: The transform trick centers the element precisely */
        /* Horizontally AND vertically centered regardless of content size */
        
        border-radius: 30px;
        /* üîÑ ROUNDED CORNERS: Soften the visual appearance */
        /* Creates a more modern, friendly UI for players */
        
        padding: 20px;
        padding-bottom: 5px;
        /* üìè INTERNAL SPACING: Breathing room for content */
        /* Different top/bottom padding creates visual balance */
      }
      
      .main-title {
        text-align: center;
        /* ‚öñÔ∏è CENTERED TITLE: Focal point of the start screen */
        /* First thing players see - creates hierarchy and focus */
      }
      
      .instructions {
        text-align: center;
        font-size: 1.2rem;
        margin: 15px;
        line-height: 2rem;
        /* üìù CLEAR INSTRUCTIONS: Readability optimized text */
        /* font-size: 1.2rem = 20% larger than default text */
        /* line-height: 2rem = double-spaced for easier reading */
        /* Ensures players understand how to play before starting */
      }
      
      .btn {
        cursor: pointer;
        /* üëÜ HAND CURSOR: Visual cue that element is clickable */
        
        width: 100px;
        margin: 10px;
        /* üìè BUTTON DIMENSIONS: Comfortable click target size */
        /* 100px wide with 10px margin creates good spacing */
        
        color: #0a0a23;
        font-size: 18px;
        /* üî§ TEXT STYLE: Dark text on light button for readability */
        /* 18px font ensures text is easily readable on all devices */
        
        background-color: var(--golden-yellow);
        background-image: linear-gradient(#fecc4c, #ffac33);
        /* üåÖ GRADIENT BACKGROUND: Creates 3D button effect */
        /* Top lighter, bottom darker creates illusion of light from above */
        
        border-color: var(--golden-yellow);
        border-width: 3px;
        /* üî≤ BORDER STYLE: Thick border matches background */
        /* 3px width makes the border clearly visible */
      }
      
      .btn:hover {
        background-image: linear-gradient(#ffcc4c, #f89808);
        /* ‚ú® HOVER EFFECT: Button brightens when mouse hovers */
        /* Visual feedback before clicking improves user experience */
        /* Slightly different gradient creates "activated" appearance */
      }
      
      .btn-container {
        display: flex;
        align-items: center;
        justify-content: center;
        /* üì¶ FLEXBOX CENTERING: Perfect horizontal alignment */
        /* Modern approach to centering with CSS */
        /* Ensures button is perfectly centered regardless of screen size */
      }
      
      .checkpoint-screen {
        position: absolute;
        left: 0;
        right: 0;
        margin-left: auto;
        margin-right: auto;
        /* ‚öñÔ∏è HORIZONTAL CENTERING: Old-school technique */
        /* Setting both left/right to 0 with auto margins centers the element */
        
        width: 100%;
        text-align: center;
        background-color: var(--section-bg-color);
        border-radius: 20px;
        padding: 10px;
        /* üìã POPUP STYLING: Clean, readable notification */
        /* White background with rounded corners for a modern look */
        
        display: none;
        /* üôà INITIALLY HIDDEN: Only appears at checkpoints */
        /* JavaScript will change this to "block" when needed */
      }
      
      #canvas {
        display: none;
        /* üôà HIDDEN CANVAS: Revealed when game starts */
        /* Initially hidden to show start screen instead */
      }
      
      @media (min-width: 768px) {
        /* üì± RESPONSIVE BREAKPOINT: Tablet and larger screens */
        /* 768px is standard tablet portrait width */
        
        .start-screen {
          width: 60%;
          max-width: 700px;
          /* üìè DESKTOP SIZING: Narrower, centered panel */
          /* Prevents the start screen from stretching too wide on large screens */
          /* 60% width with 700px maximum creates ideal reading width */
        }
      
        .checkpoint-screen {
          max-width: 300px;
          /* üìè NOTIFICATION SIZING: Compact on larger screens */
          /* 300px is wide enough for content but not intrusive */
        }
      }
    </style>
  </head>
  <body>
    <!-- üéÆ ===== THE GAME INTERFACE: Player's View into the Game World ===== -->
    
    <div class="start-screen">
      <!-- üé¨ START SCREEN: The initial game menu -->
      <!-- Like the title screen of classic arcade games! -->
      
      <h1 class="main-title">freeCodeCamp Code Warrior</h1>
      <!-- üìë GAME TITLE: Establishes theme and branding -->
      <!-- "Code Warrior" suggests a coding-themed adventure -->
      
      <p class="instructions">
        Help the main player navigate to the yellow checkpoints.
      </p>
      <!-- üìù GAME OBJECTIVE: Clear description of goals -->
      <!-- Tells player exactly what they need to accomplish -->
      
      <p class="instructions">
        Use the keyboard arrows to move the player around.
      </p>
      <!-- üéÆ CONTROL SCHEME 1: Movement controls explained -->
      <!-- Arrow keys are intuitive for 2D movement -->
      
      <p class="instructions">You can also use the spacebar to jump.</p>
      <!-- üéÆ CONTROL SCHEME 2: Jump mechanic explained -->
      <!-- Spacebar is the standard jump button in most platformers -->

      <div class="btn-container">
        <!-- üì¶ BUTTON WRAPPER: Centers the start button -->
        
        <button class="btn" id="start-btn">Start Game</button>
        <!-- üéØ START BUTTON: Initiates the game -->
        <!-- Critical interactive element with unique ID for JavaScript -->
      </div>
    </div>

    <div class="checkpoint-screen">
      <!-- üèÜ CHECKPOINT NOTIFICATION: Appears when reaching goals -->
      <!-- Provides positive feedback for player achievements -->
      
      <h2>Congrats!</h2>
      <!-- üéâ CELEBRATION HEADER: Positive reinforcement -->
      <!-- Congratulatory message creates satisfaction -->
      
      <p>You reached the last checkpoint.</p>
      <!-- üìù ACHIEVEMENT MESSAGE: Clarifies what happened -->
      <!-- Will be updated via JavaScript for different checkpoints -->
    </div>

    <canvas id="canvas"></canvas>
    <!-- üñºÔ∏è CANVAS ELEMENT: The actual game rendering surface -->
    <!-- HTML5 Canvas is like a blank drawing board for our JavaScript -->
    <!-- All game visuals will be drawn here programmatically -->

    <script>
      /* üéÆ ===== JAVASCRIPT: The Game Engine! ===== */
      
      /* üîç ===== DOM ELEMENT SELECTION: Connecting JS to HTML ===== */
      
      const startBtn = document.getElementById("start-btn");
      /* üîò START BUTTON REFERENCE: Direct access by ID */
      /* getElementById is the fastest selector method - perfect for critical elements */
      /* Like grabbing the ignition switch for our game engine */
      
      const canvas = document.getElementById("canvas");
      /* üñºÔ∏è CANVAS REFERENCE: Our drawing surface */
      /* This element will become our entire game world */
      /* Like getting a blank canvas before painting a masterpiece */
      
      const startScreen = document.querySelector(".start-screen");
      /* üé¨ START SCREEN REFERENCE: Using class selector */
      /* querySelector finds the first matching element with this class */
      /* We'll hide this when the game starts */
      
      const checkpointScreen = document.querySelector(".checkpoint-screen");
      /* üèÜ CHECKPOINT SCREEN REFERENCE: For victory messages */
      /* This popup will appear when players reach checkpoints */
      
      const checkpointMessage = document.querySelector(".checkpoint-screen > p");
      /* üìù MESSAGE REFERENCE: Direct child selector */
      /* The ">" symbol selects ONLY direct children (not grandchildren) */
      /* We'll update this text when different checkpoints are reached */
      
      /* üé® ===== CANVAS SETUP: Preparing Our Drawing Surface ===== */
      
      const ctx = canvas.getContext("2d");
      /* üñåÔ∏è DRAWING CONTEXT: The actual drawing API */
      /* getContext("2d") gives us access to the Canvas drawing tools */
      /* Like getting a paintbrush to use on our canvas */
      /* This is what we'll use to draw shapes, colors, and the game world */
      
      canvas.width = innerWidth;
      canvas.height = innerHeight;
      /* üìè CANVAS DIMENSIONS: Full screen size */
      /* Setting width/height in JS overrides any CSS sizing */
      /* This creates a 1:1 pixel ratio for crisp rendering */
      /* Without this, canvas would default to 300x150px and look blurry when stretched */
      
      /* üåç ===== GAME PHYSICS CONSTANTS: The Rules of Our World ===== */
      
      const gravity = 0.5;
      /* ‚¨áÔ∏è GRAVITY CONSTANT: Force pulling player down */
      /* This isn't realistic Earth gravity (9.8 m/s¬≤) but a value that feels good */
      /* Each frame adds 0.5 to vertical velocity ‚Üí accelerating fall */
      /* Higher values = faster falling, lower values = floatier jumps */
      
      let isCheckpointCollisionDetectionActive = true;
      /* üö¶ COLLISION FLAG: Controls checkpoint detection */
      /* This boolean acts like an on/off switch for checkpoint interactions */
      /* When false, prevents the same checkpoint from triggering multiple times */
      /* Critical for avoiding the checkpoint triggering 60 times per second! */
      
      /* üìè ===== SCALING FUNCTION: Responsive Game Elements ===== */
      
      const proportionalSize = (size) => {
        return innerHeight < 500 ? Math.ceil((size / 500) * innerHeight) : size;
        /* üì± ADAPTIVE SCALING: Elements resize for small screens */
        /* If screen height < 500px: scales everything proportionally */
        /* Formula: (size √∑ reference height) √ó actual height */
        /* Math.ceil() rounds up to prevent zero-size elements */
        /* On taller screens: uses original size values */
        /* Like having a responsive blueprint for our game world */
      }
      
      /* üßç ===== PLAYER CLASS: The Main Character ===== */
      
      class Player {
        /* üìò CLASS DEFINITION: Blueprint for creating players */
        /* Classes are templates that define properties and behaviors */
        /* Like defining what makes a "player" in our game universe */
        
        constructor() {
          /* üèóÔ∏è CONSTRUCTOR METHOD: Runs when creating new Player */
          /* This method initializes all player properties */
          /* Like building the player character from scratch */
          
          this.position = {
            x: proportionalSize(10),
            y: proportionalSize(400),
          };
          /* üìç STARTING POSITION: Where player begins */
          /* Coordinates from top-left corner of screen */
          /* Using proportionalSize ensures this works on all screen sizes */
          
          this.velocity = {
            x: 0, /* Horizontal speed (pixels per frame) */
            y: 0, /* Vertical speed (pixels per frame) */
          };
          /* üèéÔ∏è VELOCITY VECTOR: Speed and direction */
          /* Separate x/y components allow independent horizontal/vertical movement */
          /* 0 means standing still in each direction */
          
          this.width = proportionalSize(40);
          this.height = proportionalSize(40);
          /* üìè PLAYER DIMENSIONS: Size of character */
          /* 40x40px creates a square player (responsive on small screens) */
          /* Size affects both visuals and collision detection */
        }
        
        draw() {
          /* üé® DRAWING METHOD: Renders player on screen */
          /* Called every frame to show the player */
          
          ctx.fillStyle = "#99c9ff";
          /* üé® PLAYER COLOR: Light blue */
          /* Sets the "paint color" before drawing */
          
          ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
          /* üì¶ DRAW RECTANGLE: Creates the player shape */
          /* fillRect(x, y, width, height) draws a filled rectangle */
          /* This simple square represents our character */
          /* In professional games, this would be replaced with sprite images */
        }
        
        update() {
          /* üîÑ UPDATE METHOD: Game physics and logic */
          /* Called every frame (60 times per second) */
          /* Heart of the player's behavior in the game */
          
          this.draw();
          /* üé® RENDER FIRST: Ensures player is visible */
          /* Always draw before moving to prevent visual glitches */
          
          this.position.x += this.velocity.x;
          this.position.y += this.velocity.y;
          /* üö∂ MOVEMENT PHYSICS: Position changes based on velocity */
          /* This is the core movement equation: position += velocity */
          /* The direction and speed of movement depend on velocity values */
          
          if (this.position.y + this.height + this.velocity.y <= canvas.height) {
            /* üå°Ô∏è GRAVITY CHECK: Is player still in the air? */
            /* Condition checks if player hasn't reached bottom of screen */
            /* Bottom edge position = y position + height */
            
            if (this.position.y < 0) {
              /* üõë TOP BOUNDARY CHECK: Is player trying to leave screen? */
              /* y < 0 means player is trying to jump above the canvas */
              
              this.position.y = 0;
              this.velocity.y = gravity;
              /* üîÑ CEILING COLLISION: Bounce player down */
              /* Prevents going above screen and starts falling */
            }
            
            this.velocity.y += gravity;
            /* ‚¨áÔ∏è APPLY GRAVITY: Increases falling speed */
            /* This creates acceleration - falling gets faster over time */
            /* The foundation of realistic jumping physics! */
          } else {
            /* üõë FLOOR COLLISION: Player reached bottom */
            
            this.velocity.y = 0;
            /* üõë STOP FALLING: Sets vertical velocity to zero */
            /* Prevents player from falling through the floor */
          }
      
          if (this.position.x < this.width) {
            /* üõë LEFT BOUNDARY CHECK: Prevent leaving screen left */
            
            this.position.x = this.width;
            /* üîô PUSH BACK: Sets position to edge of screen */
            /* Creates an invisible wall at the left screen edge */
          }
      
          if (this.position.x >= canvas.width - this.width * 2) {
            /* üõë RIGHT BOUNDARY CHECK: Prevent leaving screen right */
            
            this.position.x = canvas.width - this.width * 2;
            /* üîô PUSH BACK: Sets position to edge of screen */
            /* The multiplication creates a better visual boundary */
          }
        }
      }
      
      /* üß± ===== PLATFORM CLASS: The Solid Ground ===== */
      
      class Platform {
        /* üìò CLASS DEFINITION: Blueprint for platforms */
        /* Each platform is a surface the player can stand on */
        
        constructor(x, y) {
          /* üèóÔ∏è CONSTRUCTOR WITH PARAMETERS: Customizable platforms */
          /* Takes x,y coordinates to place platforms anywhere */
          /* Like placing building blocks in our world */
          
          this.position = {
            x, /* Shorthand for x: x */
            y, /* Shorthand for y: y */
          };
          /* üìç PLATFORM POSITION: Custom placement */
          /* Modern JS allows shorthand when property name = variable name */
          /* This creates the platform at the exact coordinates we specify */
          
          this.width = 200;
          this.height = proportionalSize(40);
          /* üìè PLATFORM SIZE: Width and height */
          /* 200px wide creates platforms player can run across */
          /* Height scales with screen size for consistency */
        }
        
        draw() {
          /* üé® DRAWING METHOD: Renders platform on screen */
          
          ctx.fillStyle = "#acd157";
          /* üé® PLATFORM COLOR: Light green */
          /* A grass-like color distinguishes platforms from player */
          
          ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
          /* üì¶ DRAW RECTANGLE: Creates the platform shape */
          /* Simple rectangle represents each platform */
        }
      }
      
      /* üö© ===== CHECKPOINT CLASS: The Goal Markers ===== */
      
      class CheckPoint {
        /* üìò CLASS DEFINITION: Blueprint for goal markers */
        /* These are the objectives player must reach */
        
        constructor(x, y, z) {
          /* üèóÔ∏è CONSTRUCTOR WITH PARAMETERS: Customizable checkpoints */
          /* x,y = position, z = checkpoint number/sequence */
          
          this.position = {
            x,
            y,
          };
          /* üìç CHECKPOINT POSITION: Custom placement */
          /* Uses same shorthand syntax as Platform */
          
          this.width = proportionalSize(40);
          this.height = proportionalSize(70);
          /* üìè CHECKPOINT SIZE: Tall and narrow */
          /* Taller than player to be easily visible */
          
          this.claimed = false;
          /* üö© CLAIMED FLAG: Tracks checkpoint status */
          /* false = not reached yet, true = already collected */
          /* Like a virtual "I was here" flag the player plants */
        };
      
        draw() {
          /* üé® DRAWING METHOD: Renders checkpoint on screen */
          
          ctx.fillStyle = "#f1be32";
          /* üé® CHECKPOINT COLOR: Golden yellow */
          /* Bright color makes checkpoints stand out as objectives */
          
          ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
          /* üì¶ DRAW RECTANGLE: Creates the checkpoint shape */
          /* Vertical rectangle resembles a finish flag */
        }
        
        claim() {
          /* üèÅ CLAIM METHOD: "Collects" the checkpoint */
          /* Called when player reaches this checkpoint */
          
          this.width = 0;
          this.height = 0;
          /* üôà MAKE INVISIBLE: Zero dimensions hide it */
          /* Rather than removing from array, we make it invisible */
          
          this.position.y = Infinity;
          /* üå† SEND AWAY: Moves far off-screen */
          /* Infinity ensures it can never be collided with again */
          /* This is safer than modifying the array during iteration */
          
          this.claimed = true;
          /* üö© MARK AS CLAIMED: Updates status flag */
          /* This helps track progress and checkpoint sequence */
          /* Used for conditional logic in collision detection */
        }
      };
      
      /* üè≠ ===== GAME OBJECT CREATION: Building the World ===== */
      
      const player = new Player();
      /* üßç CREATE PLAYER: Instance of Player class */
      /* new Player() calls the constructor and creates a functional object */
      /* Like hitting the "print" button on our player blueprint */
      
      const platformPositions = [
        { x: 500, y: proportionalSize(450) },
        { x: 700, y: proportionalSize(400) },
        { x: 850, y: proportionalSize(350) },
        { x: 900, y: proportionalSize(350) },
        { x: 1050, y: proportionalSize(150) },
        { x: 2500, y: proportionalSize(450) },  /* Big gap ‚Üí challenge! */
        { x: 2900, y: proportionalSize(400) },
        { x: 3150, y: proportionalSize(350) },
        { x: 3900, y: proportionalSize(450) },  /* Other gap */
        { x: 4200, y: proportionalSize(400) },
        { x: 4400, y: proportionalSize(200) },
        { x: 4700, y: proportionalSize(150) },
      ];
      /* üó∫Ô∏è LEVEL DESIGN: Platform coordinates array */
      /* Each object holds x,y position for one platform */
      /* This is our "level blueprint" - separating data from logic */
      /* The comments note where challenging gaps occur in the level */
      
      const platforms = platformPositions.map(
        (platform) => new Platform(platform.x, platform.y)
      );
      /* üè≠ PLATFORM CREATION: Transforms data into objects */
      /* map() converts each position into a functional Platform */
      /* This is like a factory assembly line: data in ‚Üí objects out */
      /* Arrow function with implicit return creates each Platform */
      
      const checkpointPositions = [
        { x: 1170, y: proportionalSize(80), z: 1 },
        { x: 2900, y: proportionalSize(330), z: 2 },
        { x: 4800, y: proportionalSize(80), z: 3 },
      ];
      /* üö© CHECKPOINT LOCATIONS: Objective coordinates */
      /* Three checkpoints are placed at strategic points in the level */
      /* z value tracks the checkpoint sequence number */
      
      const checkpoints = checkpointPositions.map(
        (checkpoint) => new CheckPoint(checkpoint.x, checkpoint.y, checkpoint.z)
      );
      /* üè≠ CHECKPOINT CREATION: Transforms data into objects */
      /* Same mapping pattern as platforms, creating CheckPoint objects */
      
      /* üîÑ ===== GAME LOOP: The Animation Engine ===== */
      
      const animate = () => {
        /* üé¨ MAIN GAME LOOP: Function runs every frame */
        /* This is the heartbeat of our game - everything happens here */
        
        requestAnimationFrame(animate);
        /* üîÑ LOOP CREATION: Browser animation API */
        /* Asks browser to call animate() before next repaint */
        /* Creates a smooth 60fps loop optimized for performance */
        /* Self-referential - animate calls itself creating infinite loop */
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        /* üßπ CLEAR CANVAS: Wipes previous frame */
        /* Like erasing a whiteboard before drawing the next state */
        /* Without this, movements would leave trails behind them */
      
        platforms.forEach((platform) => {
          platform.draw();
        });
        /* üé® DRAW PLATFORMS: Render all platforms */
        /* forEach executes the function on each array element */
        /* Each platform's draw() method is called to render it */
      
        checkpoints.forEach(checkpoint => {
          checkpoint.draw();
        });
        /* üé® DRAW CHECKPOINTS: Render all checkpoints */
        /* Same pattern as platforms - draw each checkpoint */
      
        player.update();
        /* üîÑ UPDATE PLAYER: Physics and rendering */
        /* This calls the player's update method which:
           1. Draws the player
           2. Updates position based on velocity
           3. Applies gravity and boundary checks */
      
        /* üì∑ ===== CAMERA MOVEMENT: Scrolling The World ===== */
        
        if (keys.rightKey.pressed && player.position.x < proportionalSize(400)) {
          /* üèÉ‚Äç‚ôÇÔ∏è PLAYER MOVEMENT RIGHT: Move player when away from center */
          /* When right key pressed AND player left of center point */
          
          player.velocity.x = 5;
          /* ‚û°Ô∏è SET VELOCITY: Move player right */
          /* 5 pixels per frame creates smooth movement */
        } else if (keys.leftKey.pressed && player.position.x > proportionalSize(100)) {
          /* üèÉ‚Äç‚ôÇÔ∏è PLAYER MOVEMENT LEFT: Move player when away from left edge */
          /* When left key pressed AND player right of left boundary */
          
          player.velocity.x = -5;
          /* ‚¨ÖÔ∏è SET VELOCITY: Move player left */
          /* Negative velocity means leftward movement */
        } else {
          /* üõë CENTRAL POSITION: Player near center or edges */
          
          player.velocity.x = 0;
          /* üõë STOP HORIZONTAL MOVEMENT: Player stationary */
          /* Reset velocity to zero - player stops moving horizontally */
      
          /* üåé WORLD SCROLLING: Move environment instead of player */
          /* This creates the illusion of a moving camera following the player */
          
          if (keys.rightKey.pressed && isCheckpointCollisionDetectionActive) {
            /* ‚û°Ô∏è SCROLL RIGHT: Move world when player centered */
            /* Active only when checkpoint collision is enabled */
            
            platforms.forEach((platform) => {
              platform.position.x -= 5;
              /* ‚¨ÖÔ∏è MOVE PLATFORMS LEFT: World scrolls opposite to player direction */
              /* Creates illusion of player moving right */
            });
      
            checkpoints.forEach((checkpoint) => {
              checkpoint.position.x -= 5;
              /* ‚¨ÖÔ∏è MOVE CHECKPOINTS LEFT: Keep synchronized with platforms */
              /* Everything in world moves together for consistent scrolling */
            });
          
          } else if (keys.leftKey.pressed && isCheckpointCollisionDetectionActive) {
            /* ‚¨ÖÔ∏è SCROLL LEFT: Move world when player centered */
            
            platforms.forEach((platform) => {
              platform.position.x += 5;
              /* ‚û°Ô∏è MOVE PLATFORMS RIGHT: World scrolls opposite to player direction */
              /* Creates illusion of player moving left */
            });
      
            checkpoints.forEach((checkpoint) => {
              checkpoint.position.x += 5;
              /* ‚û°Ô∏è MOVE CHECKPOINTS RIGHT: Keep synchronized with platforms */
            });
          }
        }
      
        /* üí• ===== PLATFORM COLLISION DETECTION ===== */
        
        platforms.forEach((platform) => {
          /* üîç CHECK EACH PLATFORM: Iterate through all platforms */
          
          const collisionDetectionRules = [
            player.position.y + player.height <= platform.position.y,
            /* ‚¨áÔ∏è RULE 1: Player's bottom above platform's top */
            /* Ensures player is descending onto platform from above */
            
            player.position.y + player.height + player.velocity.y >= platform.position.y,
            /* ‚¨áÔ∏è RULE 2: Player's next position will intersect platform */
            /* Predicts collision based on current velocity */
            
            player.position.x >= platform.position.x - player.width / 2,
            /* ‚¨ÖÔ∏è RULE 3: Player not too far left of platform */
            /* Horizontal position check - left edge */
            
            player.position.x <=
              platform.position.x + platform.width - player.width / 3,
            /* ‚û°Ô∏è RULE 4: Player not too far right of platform */
            /* Horizontal position check - right edge */
          ];
      
          if (collisionDetectionRules.every((rule) => rule)) {
            /* ‚úÖ ALL RULES TRUE: Standing on platform */
            /* every() checks if ALL conditions return true */
            /* This is like a logical AND between all conditions */
            
            player.velocity.y = 0;
            /* üõë STOP FALLING: Land on platform */
            /* Zero vertical velocity prevents falling through platform */
            
            return;
            /* üö™ EXIT LOOP: Skip remaining platforms */
            /* Once we've found a collision, no need to check others */
          }
      
          /* üí• COLLISION FROM BELOW: Hitting platform from underneath */
          
          const platformDetectionRules = [
            player.position.x >= platform.position.x - player.width / 2,
            /* ‚¨ÖÔ∏è RULE 1: Horizontal overlap check (left) */
            
            player.position.x <=
              platform.position.x + platform.width - player.width / 3,
            /* ‚û°Ô∏è RULE 2: Horizontal overlap check (right) */
            
            player.position.y + player.height >= platform.position.y,
            /* ‚¨ÜÔ∏è RULE 3: Player's bottom below platform's top */
            
            player.position.y <= platform.position.y + platform.height,
            /* ‚¨áÔ∏è RULE 4: Player's top above platform's bottom */
          ];
      
          if (platformDetectionRules.every(rule => rule)) {
            /* ‚úÖ ALL RULES TRUE: Hitting platform from below */
            
            player.position.y = platform.position.y + player.height;
            /* ‚¨áÔ∏è PUSH DOWN: Move player below platform */
            /* Prevents getting stuck inside platform */
            
            player.velocity.y = gravity;
            /* ‚¨áÔ∏è START FALLING: Apply gravity */
            /* Bounces player down after hitting head */
          };
        });
      
        /* üö© ===== CHECKPOINT COLLISION DETECTION ===== */
        
        checkpoints.forEach((checkpoint, index, checkpoints) => {
          /* üîç CHECK EACH CHECKPOINT: Iterate through all checkpoints */
          /* index = position in array, checkpoints = the full array */
          
          const checkpointDetectionRules = [
            player.position.x >= checkpoint.position.x,
            /* ‚û°Ô∏è RULE 1: Player right edge beyond checkpoint left */
            
            player.position.y >= checkpoint.position.y,
            /* ‚¨áÔ∏è RULE 2: Player below top of checkpoint */
            
            player.position.y + player.height <=
              checkpoint.position.y + checkpoint.height,
            /* ‚¨ÜÔ∏è RULE 3: Player within vertical bounds of checkpoint */
            
            isCheckpointCollisionDetectionActive,
            /* üö¶ RULE 4: Collision detection system is active */
            /* Prevents multiple activations when global switch is off */
            
            player.position.x - player.width <=
              checkpoint.position.x - checkpoint.width + player.width * 0.9,
            /* ‚¨ÖÔ∏è RULE 5: Complex horizontal alignment check */
            /* Ensures player is properly positioned relative to checkpoint */
            
            index === 0 || checkpoints[index - 1].claimed === true,
            /* üî¢ RULE 6: Checkpoint order check */
            /* Either this is the first checkpoint OR previous one was claimed */
            /* Forces sequential checkpoint collection */
          ];
      
          if (checkpointDetectionRules.every((rule) => rule)) {
            /* ‚úÖ ALL RULES TRUE: Checkpoint reached */
            
            checkpoint.claim();
            /* üèÅ CLAIM CHECKPOINT: Mark as reached */
            /* This hides the checkpoint and marks it claimed */
      
            if (index === checkpoints.length - 1) {
              /* üèÜ FINAL CHECKPOINT: Last in array */
              /* Length - 1 is the index of the last item */
              
              isCheckpointCollisionDetectionActive = false;
              /* üö´ DISABLE COLLISIONS: Game effectively ends */
              /* Prevents further checkpoint activations */
              
              showCheckpointScreen("You reached the final checkpoint!");
              /* üéâ VICTORY MESSAGE: Final achievement */
              /* Shows celebration message with custom text */
              
              movePlayer("ArrowRight", 0, false);
              /* üõë STOP PLAYER: Prevent movement after winning */
              /* Reset movement state to make player stand still */
            } else if (player.position.x >= checkpoint.position.x && player.position.x <= checkpoint.position.x + 40) {
              /* ‚úÖ REGULAR CHECKPOINT: Not the final one */
              /* Additional position check ensures proper trigger timing */
              
              showCheckpointScreen("You reached a checkpoint!");
              /* üéâ PROGRESS MESSAGE: Intermediate achievement */
            }
          };
        });
      }
      
      /* üéÆ ===== KEYBOARD STATE TRACKING ===== */
      
      const keys = {
        rightKey: {
          pressed: false
        },
        leftKey: {
          pressed: false
        }
      };
      /* üéÆ KEYBOARD STATE OBJECT: Tracks pressed keys */
      /* Nested objects: keys ‚Üí rightKey ‚Üí pressed */
      /* Using boolean flags instead of checking key state every frame */
      /* This allows for smooth, consistent movement */
      
      const movePlayer = (key, xVelocity, isPressed) => {
        /* üèÉ‚Äç‚ôÇÔ∏è PLAYER MOVEMENT FUNCTION: Processes key actions */
        /* key = which key was pressed */
        /* xVelocity = how fast to move */
        /* isPressed = key down or key up? */
        
        if (!isCheckpointCollisionDetectionActive) {
          /* üö´ GAME OVER CHECK: Block movement if game ended */
          
          player.velocity.x = 0;
          player.velocity.y = 0;
          /* üõë FREEZE PLAYER: Stop all movement */
          
          return;
          /* üö™ EXIT FUNCTION: Skip remaining code */
        }
      
        switch (key) {
          /* üîÄ KEY SWITCH: Different action for each key */
          /* Efficient way to handle multiple key options */
          
          case "ArrowLeft":
            /* ‚¨ÖÔ∏è LEFT ARROW: Move player left */
            
            keys.leftKey.pressed = isPressed;
            /* üîÑ UPDATE KEY STATE: Track if key is down */
            
            if (xVelocity === 0) {
              player.velocity.x = xVelocity;
              /* üõë ZERO VELOCITY: For key up event */
              /* When releasing key, stop moving immediately */
            }
            player.velocity.x -= xVelocity;
            /* ‚¨ÖÔ∏è APPLY VELOCITY: Move left */
            /* Subtract from x velocity to move left */
            break;
            
          case "ArrowUp":
          case " ":
          case "Spacebar":
            /* ‚¨ÜÔ∏è UP/SPACE: Jump action */
            /* Multiple cases handle different jump keys */
            /* Both arrow up and spacebar trigger jump */
            
            player.velocity.y -= 8;
            /* ‚¨ÜÔ∏è JUMP VELOCITY: Move upward */
            /* Negative y velocity means moving up */
            /* Value of 8 creates a satisfying jump height */
            break;
            
          case "ArrowRight":
            /* ‚û°Ô∏è RIGHT ARROW: Move player right */
            
            keys.rightKey.pressed = isPressed;
            /* üîÑ UPDATE KEY STATE: Track if key is down */
            
            if (xVelocity === 0) {
              player.velocity.x = xVelocity;
              /* üõë ZERO VELOCITY: For key up event */
            }
            player.velocity.x += xVelocity;
            /* ‚û°Ô∏è APPLY VELOCITY: Move right */
            /* Add to x velocity to move right */
        }
      }
      
      /* üéÆ ===== GAME MANAGEMENT FUNCTIONS ===== */
      
      const startGame = () => {
        /* üèÅ GAME STARTER: Initializes gameplay */
        
        canvas.style.display = "block";
        /* üñºÔ∏è SHOW CANVAS: Make game visible */
        /* Changes display from "none" to "block" */
        
        startScreen.style.display = "none";
        /* üôà HIDE START SCREEN: Remove menu */
        /* Once game starts, we don't need the menu */
        
        animate();
        /* üé¨ START ANIMATION: Begin game loop */
        /* This launches the core game engine */
      }
      
      const showCheckpointScreen = (msg) => {
        /* üèÜ CHECKPOINT NOTIFIER: Displays achievement message */
        /* msg = custom text for different checkpoints */
        
        checkpointScreen.style.display = "block";
        /* üìù SHOW MESSAGE: Make notification visible */
        
        checkpointMessage.textContent = msg;
        /* üìù SET TEXT: Update message content */
        /* Uses the parameter to customize the message */
        
        if (isCheckpointCollisionDetectionActive) {
          /* ‚è±Ô∏è TEMPORARY DISPLAY: Only if game still active */
          
          setTimeout(() => (checkpointScreen.style.display = "none"), 2000);
          /* ‚è±Ô∏è TIMED REMOVAL: Hide after 2 seconds */
          /* setTimeout runs the function after delay in milliseconds */
          /* Arrow function with parentheses around single statement */
        }
      };
      
      /* üñ±Ô∏è ===== EVENT LISTENERS: User Input Handling ===== */
      
      startBtn.addEventListener("click", startGame);
      /* üé¨ START BUTTON LISTENER: Begin game on click */
      /* Connects HTML button to JavaScript function */
      
      window.addEventListener("keydown", ({ key }) => {
        /* üéÆ KEY PRESS LISTENER: Detect when keys are pressed */
        /* { key } uses destructuring to extract key property from event */
        /* Much cleaner than writing (event) and then event.key */
        
        movePlayer(key, 8, true);
        /* üèÉ‚Äç‚ôÇÔ∏è HANDLE KEY PRESS: Move at speed 8, key is pressed */
        /* true = key is pressed (keydown event) */
      });
      
      window.addEventListener("keyup", ({ key }) => {
        /* üéÆ KEY RELEASE LISTENER: Detect when keys are released */
        /* Counterpart to keydown - needed for smooth controls */
        
        movePlayer(key, 0, false);
        /* üõë HANDLE KEY RELEASE: Stop movement, key is released */
        /* 0 = zero velocity (stop moving) */
        /* false = key is released (keyup event) */
      });
    </script>
  </body>
</html>

<!-- üéØ ===== PLATFORMER GAME SUMMARY ===== -->
<!-- 
üéÆ GAME ARCHITECTURE:
‚îÇ
‚îú‚îÄ‚îÄ üñ•Ô∏è HTML STRUCTURE
‚îÇ   ‚îú‚îÄ‚îÄ üìã Start screen with instructions
‚îÇ   ‚îú‚îÄ‚îÄ üèÜ Checkpoint notification popup
‚îÇ   ‚îî‚îÄ‚îÄ üñºÔ∏è Canvas game surface
‚îÇ
‚îú‚îÄ‚îÄ üé® CSS STYLING
‚îÇ   ‚îú‚îÄ‚îÄ üéÆ Game interface components
‚îÇ   ‚îú‚îÄ‚îÄ üîò Interactive button styling
‚îÇ   ‚îî‚îÄ‚îÄ üì± Responsive design for all screens
‚îÇ
‚îî‚îÄ‚îÄ üß† JAVASCRIPT GAME ENGINE
    ‚îú‚îÄ‚îÄ üì¶ Object-Oriented Programming (Classes)
    ‚îÇ   ‚îú‚îÄ‚îÄ üßç Player with physics and collision
    ‚îÇ   ‚îú‚îÄ‚îÄ üß± Platforms for navigation
    ‚îÇ   ‚îî‚îÄ‚îÄ üö© Checkpoints for objectives
    ‚îÇ
    ‚îú‚îÄ‚îÄ üéÆ Game Mechanics
    ‚îÇ   ‚îú‚îÄ‚îÄ ‚¨áÔ∏è Gravity and jumping physics
    ‚îÇ   ‚îú‚îÄ‚îÄ üì∑ Camera scrolling system
    ‚îÇ   ‚îú‚îÄ‚îÄ üí• Collision detection
    ‚îÇ   ‚îî‚îÄ‚îÄ üèÜ Progressive checkpoint system
    ‚îÇ
    ‚îî‚îÄ‚îÄ üîÑ Technical Implementation
        ‚îú‚îÄ‚îÄ üé¨ RequestAnimationFrame loop
        ‚îú‚îÄ‚îÄ üìè Proportional sizing for responsiveness
        ‚îú‚îÄ‚îÄ üéÆ Event-driven keyboard controls
        ‚îî‚îÄ‚îÄ üéØ State management for game progress

This project demonstrates core principles of game development through OOP!
From physics simulation to collision detection, it's a complete mini-game engine!
-->
```
</TabItem>

</Tabs>

### The Three Revelations

There are 3 concepts that struck me in this project: **APIs**, **requestAnimationFrame**, and **Infinity**.

#### APIs: Standing on the Shoulders of Giants

I find it incredible how a simple API call gives us as end users the feeling of ease, but behind the scenes there are countless lines of code that compose it.<br />
I now recognize the great work of backend developers: whether they're software engineers from various browsers or developers contributing to open source. I recognize that I'm literally **standing on the shoulders of giants**.<br />
Every time I write `requestAnimationFrame()` or `canvas.getContext('2d')`, I'm using the result of years of optimizations, technical discussions, and iterations.

#### requestAnimationFrame: Intelligent Efficiency

Take the `requestAnimationFrame()` API as an example. Thanks to this simple call, the browser knows exactly when it's about to redraw the screen (refresh cycle).<br />
**It goes from 60 to 0 fps depending on whether there's activity or not**, resulting in energy and memory savings. When the tab button isn't active, the browser simply stops calling the function. Zero wasted cycles.<br />
It's clever because instead of an infinite loop that always runs (even when not needed), the browser synchronizes the code with its native rendering cycle.

#### Infinity: The "Disable, Don't Destroy" Pattern

Checkpoints in this game are set to `Infinity` when obtained. But why not destroy the object? Why not remove it from the array entirely?

**With `claim()` we have 4 levels of defense:**

```javascript
claim() {
  this.width = 0;           // 1. Impossible geometry
  this.height = 0;          // 2. Zero dimensions
  this.position.y = Infinity; // 3. Out of the world
  this.claimed = true;      // 4. Already used
}
```

It's clear there's no intention to remove them from the array. I wondered why: removing them would also free up precious memory, I thought. Well, that's true but the price to pay would be very high.

Each layer protects against a different type of access. In fact, setting **width and height to zero** protects with mathematics: when the code performs collision detection, it calculates if two rectangles overlap, but with null dimensions the overlap becomes impossible. Even if the code executes, the geometric calculations automatically fail.

Setting **position.y to Infinity** protects with space. Any player position (100, 500, even 9999) will always be less than `Infinity`. The checkpoint has literally fallen out of the game world, and any vertical position comparison fails.

The **claimed = true** protects with logic and is the most efficient check. It's a guard clause, meaning a check that exits the function immediately, that tells the code "this checkpoint has already been used, don't waste time checking collisions". It prevents useless calculations allowing a quick exit from the check. In short, if one of the checks fails due to a future bug, the others save you.<br />

**The saved memory isn't worth the problems created:**

Removing with `checkpoints.splice(index, 1)` would create more problems than it solves. At 60fps, the array indices change while you're iterating, potentially causing visible bugs. Each removal also requires memory reallocation and activates the garbage collector (the system that automatically cleans memory), not to mention that modifying the array while others are reading it causes race conditions (situations where multiple parts of the code access the same resource simultaneously creating unpredictable bugs).<br />
With `claim()` there's no allocation, no garbage collection, zero pauses. Therefore, "turning off/on" existing objects is decidedly better.

### What I Learned

**Intermediate OOP:**
- **Inheritance:** Extending base classes to create object variants
- **Composition:** Combining simpler objects to create complex behaviors
- **Encapsulation:** Hiding implementation details behind clean interfaces
- **Object Pooling:** Reusing objects instead of creating/destroying them continuously

**Game Development Patterns:**
- **Game Loop:** Main update ‚Üí render cycle synchronized with `requestAnimationFrame()`
- **Delta Time:** Frame-rate independent handling for smooth movement
- **State Management:** Managing game states (menu, playing, paused, game over)
- **Collision Detection:** AABB (Axis-Aligned Bounding Box) to detect collisions

**Canvas API:**
- `getContext('2d')` to get the drawing context
- `clearRect()` to clear the canvas every frame
- `fillRect()` and `strokeRect()` to draw shapes
- `drawImage()` for sprites and textures

**Physics Simulation:**
- Gravity as constant downward acceleration
- Velocity and acceleration as 2D vectors
- Friction for natural slowdown
- Jump mechanics with vertical impulse

**Performance Optimization:**
- `requestAnimationFrame()` for synchronization with refresh rate
- Reduced DOM calls
- Spatial partitioning for efficient collision detection
- Boolean flags for early exit (guard clauses)

**Event Handling:**
- `keydown` and `keyup` for keyboard input
- Simultaneous multiple input handling (jump + movement)
- Preventing default browser behaviors

**Defensive Programming:**
- Intentional redundancy for robustness
- Guard clauses to prevent useless calculations
- Boundary checking to avoid out-of-bounds
- Fallback values for edge case situations

<br />
Ready to start the next project!

***

**Next Project**: Review Algorithmic Thinking by Building a Dice Game
